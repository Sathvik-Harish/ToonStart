import React, { useRef, useEffect, useState, useCallback } from 'react';

<script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
// -------------------------------------------------------------------------

// Main App component for the animation editor
const App = () => {
    // Refs for the canvas element and its 2D rendering context
    const canvasRef = useRef(null);
    const contextRef = useRef(null);
    // Ref for the animation interval ID, so it can be cleared
    const animationIntervalRef = useRef(null);

    // State variables for drawing functionality
    const [isDrawing, setIsDrawing] = useState(false); // True when mouse is down and drawing
    const [brushColor, setBrushColor] = useState('#000000'); // Current drawing color (default black)
    const [brushSize, setBrushSize] = useState(5); // Current brush size (default 5px)
    const [tool, setTool] = useState('brush'); // Current selected tool: 'brush', 'eraser', or 'fill'
    const [message, setMessage] = useState(''); // For user messages/feedback
    const [showIdeaModal, setShowIdeaModal] = useState(false); // Controls visibility of the idea generator modal
    const [ideaPrompt, setIdeaPrompt] = useState(''); // User input for the idea generator
    const [generatedIdea, setGeneratedIdea] = useState(''); // Stores the idea generated by Gemini
    const [isGeneratingIdea, setIsGeneratingIdea] = useState(false); // Loading state for idea generation

    // State variables for frame management
    // Each frame is stored as a data URL (image representation of the canvas)
    const [frames, setFrames] = useState([]); // Array of all animation frames
    const [currentFrameIndex, setCurrentFrameIndex] = useState(0); // Index of the currently active frame

    // State variables for animation playback
    const [isPlaying, setIsPlaying] = useState(false); // True when animation is playing
    const [animationSpeed, setAnimationSpeed] = useState(10); // Frames per second (FPS)

    // State variables for GIF export
    const [isExporting, setIsExporting] = useState(false); // True when GIF is being generated
    const [exportProgress, setExportProgress] = useState(0); // GIF export progress (0-1)

    // State variables for Onion Skinning
    const [onionSkinEnabled, setOnionSkinEnabled] = useState(false);
    const [onionSkinPrevCount, setOnionSkinPrevCount] = useState(1); // Number of previous frames to show
    const [onionSkinNextCount, setOnionSkinNextCount] = useState(1); // Number of next frames to show
    const [onionSkinOpacity, setOnionSkinOpacity] = useState(0.3); // Opacity for onion skin frames
    const [onionSkinColor, setOnionSkinColor] = useState('#ff0000'); // Default red tint for onion skin

    // Helper function to convert hex color to RGBA array
    const hexToRgba = (hex, alpha = 255) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b, alpha];
    };

    // Function to render all canvas content including onion skins
    const renderCanvasContent = useCallback(() => {
        const canvas = canvasRef.current;
        const context = contextRef.current;
        if (!canvas || !context) return;

        // Clear the canvas completely for a fresh redraw
        context.clearRect(0, 0, canvas.width, canvas.height);

        // Helper to load and draw an image with optional tint
        const loadImageAndDraw = (imageData, alpha, tintColor = null) => {
            if (typeof imageData === 'string' && imageData.startsWith('data:image/png;base64,')) {
                const img = new Image();
                img.src = imageData;
                img.onload = () => {
                    // Save context state before drawing to isolate changes
                    context.save();

                    // Draw the base image fully opaque
                    context.globalAlpha = 1.0;
                    context.drawImage(img, 0, 0, canvas.width, canvas.height);

                    // Apply tint if specified
                    if (tintColor) {
                        context.globalCompositeOperation = 'source-atop'; // Draw tint over the image
                        context.fillStyle = tintColor;
                        context.globalAlpha = alpha; // Use the desired opacity for the tint
                        context.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    
                    // Restore context state after drawing
                    context.restore();
                };
                img.onerror = () => {
                    console.error("Error loading image data for onion skin/frame:", imageData);
                };
            } else {
                // console.warn("Invalid image data provided for drawing:", imageData);
            }
        };

        // 1. Draw previous frames (onion skin)
        if (onionSkinEnabled) {
            for (let i = onionSkinPrevCount; i >= 1; i--) { // Draw further frames first
                const prevFrameIndex = currentFrameIndex - i;
                if (prevFrameIndex >= 0) {
                    loadImageAndDraw(frames[prevFrameIndex], onionSkinOpacity, onionSkinColor);
                }
            }
        }

        // 2. Draw the current frame (full opacity, no tint)
        loadImageAndDraw(frames[currentFrameIndex], 1.0); // No tint for current frame

        // 3. Draw next frames (onion skin)
        if (onionSkinEnabled) {
            for (let i = 1; i <= onionSkinNextCount; i++) {
                const nextFrameIndex = currentFrameIndex + i;
                if (nextFrameIndex < frames.length) {
                    loadImageAndDraw(frames[nextFrameIndex], onionSkinOpacity, onionSkinColor);
                }
            }
        }
        // Ensure globalAlpha and globalCompositeOperation are reset for subsequent drawing operations (brush/eraser)
        context.globalAlpha = 1.0;
        context.globalCompositeOperation = 'source-over';
    }, [frames, currentFrameIndex, onionSkinEnabled, onionSkinPrevCount, onionSkinNextCount, onionSkinOpacity, onionSkinColor]);


    // Effect hook to initialize the canvas and drawing context
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        // Set canvas dimensions to be responsive and fill its container
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        const context = canvas.getContext('2d');
        if (!context) return;

        contextRef.current = context;

        // Set initial drawing styles
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.strokeStyle = brushColor;
        context.lineWidth = brushSize;

        // Initialize with one blank frame if no frames exist
        if (frames.length === 0) {
            // Get a blank canvas data URL
            const blankCanvasData = canvas.toDataURL('image/png');
            setFrames([blankCanvasData]);
        } else {
            // Draw the current frame if frames already exist (e.g., on component re-mount)
            renderCanvasContent();
        }

        // Function to handle canvas resize
        const handleResize = () => {
            // Save current frame's image data
            const currentFrameData = canvas.toDataURL('image/png');
            // Update canvas dimensions
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            // Redraw the saved image data onto the resized canvas
            const img = new Image();
            img.src = currentFrameData;
            img.onload = () => {
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(img, 0, 0, canvas.width, canvas.height);
                // Reapply drawing styles after resize
                context.lineCap = 'round';
                context.lineJoin = 'round';
                context.strokeStyle = brushColor;
                context.lineWidth = brushSize;
            };
        };

        // Add event listener for window resize
        window.addEventListener('resize', handleResize);

        // Cleanup function to remove event listener
        return () => {
            window.removeEventListener('resize', handleResize);
        };
    }, []); // Empty dependency array ensures this runs only once on mount

    // Effect hook to update context styles when brushColor or brushSize changes
    useEffect(() => {
        if (contextRef.current) {
            contextRef.current.strokeStyle = brushColor;
            contextRef.current.lineWidth = brushSize;
        }
    }, [brushColor, brushSize]);

    // Effect hook to redraw the canvas when the current frame changes or onion skin settings change
    useEffect(() => {
        renderCanvasContent();
    }, [currentFrameIndex, frames, renderCanvasContent]);

    // Function to save the current canvas state to the current frame in the frames array
    const saveCurrentFrame = useCallback(() => {
        const canvas = canvasRef.current;
        if (canvas) {
            const updatedFrames = [...frames];
            updatedFrames[currentFrameIndex] = canvas.toDataURL('image/png');
            setFrames(updatedFrames);
        }
    }, [frames, currentFrameIndex]);

    // Function to start drawing when the mouse is pressed down
    const startDrawing = useCallback(({ nativeEvent }) => {
        const { offsetX, offsetY } = nativeEvent;
        const context = contextRef.current;
        if (!context) return;

        // If 'fill' tool is selected, perform flood fill
        if (tool === 'fill') {
            const canvas = canvasRef.current;
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const targetColor = hexToRgba(brushColor); // The color to fill with

            // Get the color of the pixel clicked
            const startPixelIndex = (offsetY * canvas.width + offsetX) * 4;
            const startColor = [
                pixels[startPixelIndex],
                pixels[startPixelIndex + 1],
                pixels[startPixelIndex + 2],
                pixels[startPixelIndex + 3]
            ];

            // If the start color is already the target color, do nothing
            if (startColor[0] === targetColor[0] &&
                startColor[1] === targetColor[1] &&
                startColor[2] === targetColor[2] &&
                startColor[3] === targetColor[3]) {
                return;
            }

            const pixelStack = [[offsetX, offsetY]];

            while (pixelStack.length) {
                const [x, y] = pixelStack.pop();

                // Check bounds
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;

                const currentPixelIndex = (y * canvas.width + x) * 4;
                const currentColor = [
                    pixels[currentPixelIndex],
                    pixels[currentPixelIndex + 1],
                    pixels[currentPixelIndex + 2],
                    pixels[currentPixelIndex + 3]
                ];

                // Check if current pixel matches the starting color (with a small tolerance for anti-aliasing)
                const colorMatch = (c1, c2) => {
                    const tolerance = 5; // Adjust tolerance as needed
                    return Math.abs(c1[0] - c2[0]) < tolerance &&
                           Math.abs(c1[1] - c2[1]) < tolerance &&
                           Math.abs(c1[2] - c2[2]) < tolerance &&
                           Math.abs(c1[3] - c2[3]) < tolerance;
                };

                if (colorMatch(currentColor, startColor)) {
                    // Set pixel to target color
                    pixels[currentPixelIndex] = targetColor[0];
                    pixels[currentPixelIndex + 1] = targetColor[1];
                    pixels[currentPixelIndex + 2] = targetColor[2];
                    pixels[currentPixelIndex + 3] = targetColor[3]; // Keep alpha same or set to target alpha

                    // Add neighbors to stack
                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            context.putImageData(imageData, 0, 0);
            saveCurrentFrame(); // Save the filled frame
            renderCanvasContent(); // Redraw with onion skins
        } else {
            // For brush and eraser tools
            // Before drawing, redraw the current frame without onion skins
            // This ensures drawing operations only affect the current frame's content
            const currentFrameData = frames[currentFrameIndex];
            context.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
            if (currentFrameData && currentFrameData.startsWith('data:image/png;base64,')) {
                const img = new Image();
                img.src = currentFrameData;
                img.onload = () => {
                    context.drawImage(img, 0, 0, canvasRef.current.width, canvasRef.current.height);
                    // Start path after image is drawn
                    context.beginPath();
                    context.moveTo(offsetX, offsetY);
                    setIsDrawing(true);
                };
                img.onerror = () => {
                    // If image fails to load, start drawing on a clear canvas
                    context.beginPath();
                    context.moveTo(offsetX, offsetY);
                    setIsDrawing(true);
                };
            } else {
                // If no valid current frame data, start drawing on a clear canvas
                context.beginPath();
                context.moveTo(offsetX, offsetY);
                setIsDrawing(true);
            }
        }
    }, [tool, frames, currentFrameIndex, brushColor, saveCurrentFrame, renderCanvasContent]);


    // Function to draw as the mouse moves
    const draw = useCallback(({ nativeEvent }) => {
        if (!isDrawing) return; // Only draw if drawing is active

        const { offsetX, offsetY } = nativeEvent;
        const context = contextRef.current;
        if (!context) return;

        // If tool is eraser, change globalCompositeOperation to 'destination-out'
        context.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';

        context.lineTo(offsetX, offsetY); // Draw a line to the current mouse position
        context.stroke(); // Apply the stroke
    }, [isDrawing, tool]);

    // Function to stop drawing when the mouse is released or leaves the canvas
    const stopDrawing = useCallback(() => {
        const context = contextRef.current;
        if (!context) return;

        // Only close path and save if it was a drawing tool (not fill)
        if (tool !== 'fill') {
            context.closePath(); // Close the current drawing path
            setIsDrawing(false); // Set drawing state to false
            context.globalCompositeOperation = 'source-over'; // Reset blend mode after drawing
            saveCurrentFrame(); // Save the changes to the current frame
            renderCanvasContent(); // Redraw with onion skins after saving
        }
    }, [saveCurrentFrame, renderCanvasContent, tool]);

    // Function to clear the current frame
    const clearCurrentFrame = useCallback(() => {
        const canvas = canvasRef.current;
        const context = contextRef.current;
        if (!canvas || !context) return;

        context.clearRect(0, 0, canvas.width, canvas.height); // Clear all pixels on current frame
        saveCurrentFrame(); // Save the cleared state
        setMessage('Current frame cleared!');
        setTimeout(() => setMessage(''), 2000);
    }, [saveCurrentFrame]);

    // Function to add a new blank frame
    const addFrame = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        // Save the current frame's state before adding a new one
        saveCurrentFrame();

        // Create a new blank frame (empty canvas data URL)
        const blankCanvasData = canvas.toDataURL('image/png'); // Capture current blank state
        const newFrames = [...frames];
        newFrames.splice(currentFrameIndex + 1, 0, blankCanvasData); // Insert after current frame
        setFrames(newFrames);
        setCurrentFrameIndex(currentFrameIndex + 1); // Move to the new frame
        setMessage('New frame added!');
        setTimeout(() => setMessage(''), 2000);
    }, [frames, currentFrameIndex, saveCurrentFrame]);

    // Function to delete the current frame
    const deleteFrame = useCallback(() => {
        if (frames.length <= 1) {
            setMessage('Cannot delete the last frame!');
            setTimeout(() => setMessage(''), 2000);
            return;
        }

        const newFrames = frames.filter((_, index) => index !== currentFrameIndex);
        setFrames(newFrames);

        // Adjust currentFrameIndex if the deleted frame was the last one
        if (currentFrameIndex >= newFrames.length) {
            setCurrentFrameIndex(newFrames.length - 1);
        }
        setMessage('Frame deleted!');
        setTimeout(() => setMessage(''), 2000);
    }, [frames, currentFrameIndex]);

    // Function to duplicate the current frame
    const duplicateFrame = useCallback(() => {
        const currentFrameData = frames[currentFrameIndex];
        const newFrames = [...frames];
        newFrames.splice(currentFrameIndex + 1, 0, currentFrameData); // Insert copy after current frame
        setFrames(newFrames);
        setCurrentFrameIndex(currentFrameIndex + 1); // Move to the duplicated frame
        setMessage('Frame duplicated!');
        setTimeout(() => setMessage(''), 2000);
    }, [frames, currentFrameIndex]);

    // Function to save the entire animation project to local storage
    const saveProject = useCallback(() => {
        // Ensure the current frame's drawing is saved before saving the project
        saveCurrentFrame();
        localStorage.setItem('animationProject', JSON.stringify(frames));
        localStorage.setItem('currentFrameIndex', currentFrameIndex.toString());
        setMessage('Animation project saved!');
        setTimeout(() => setMessage(''), 2000);
    }, [frames, currentFrameIndex, saveCurrentFrame]);

    // Function to load an entire animation project from local storage
    const loadProject = useCallback(() => {
        const savedProject = localStorage.getItem('animationProject');
        const savedIndex = localStorage.getItem('currentFrameIndex');

        if (!savedProject) {
            setMessage('No saved animation project found!');
            setTimeout(() => setMessage(''), 2000);
            return;
        }

        try {
            const loadedFrames = JSON.parse(savedProject);
            if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                setFrames(loadedFrames);
                const loadedIndex = savedIndex ? parseInt(savedIndex, 10) : 0;
                setCurrentFrameIndex(Math.min(loadedIndex, loadedFrames.length - 1));
                setMessage('Animation project loaded!');
            } else {
                setMessage('Saved project data is corrupt or empty.');
            }
        } catch (error) {
            console.error("Error parsing loaded project:", error);
            setMessage('Error loading project data.');
        } finally {
            setTimeout(() => setMessage(''), 2000);
        }
    }, []);

    // Playback functions
    const playAnimation = useCallback(() => {
        if (frames.length === 0) {
            setMessage('No frames to play!');
            setTimeout(() => setMessage(''), 2000);
            return;
        }
        if (isPlaying) return; // Prevent multiple intervals

        setIsPlaying(true);
        // Temporarily disable onion skinning during playback for smoother animation
        setOnionSkinEnabled(false);
        const interval = 1000 / animationSpeed; // Milliseconds per frame

        animationIntervalRef.current = setInterval(() => {
            setCurrentFrameIndex(prevIndex => {
                const nextIndex = (prevIndex + 1) % frames.length;
                return nextIndex;
            });
        }, interval);
        setMessage('Playing animation...');
    }, [frames, isPlaying, animationSpeed]);

    const pauseAnimation = useCallback(() => {
        if (animationIntervalRef.current) {
            clearInterval(animationIntervalRef.current);
            animationIntervalRef.current = null;
        }
        setIsPlaying(false);
        setMessage('Animation paused.');
        setTimeout(() => setMessage(''), 2000);
    }, []);

    const stopAnimation = useCallback(() => {
        pauseAnimation(); // Clear interval
        setCurrentFrameIndex(0); // Go back to the first frame
        setMessage('Animation stopped.');
        setTimeout(() => setMessage(''), 2000);
    }, [pauseAnimation]);

    // Clear interval when component unmounts or when animation stops
    useEffect(() => {
        return () => {
            if (animationIntervalRef.current) {
                clearInterval(animationIntervalRef.current);
            }
        };
    }, []);

    // Function to export animation as GIF
    const exportGif = useCallback(() => {
        // --- FIX: Check for GIF.js availability after the script tag is loaded ---
        // The script tag is now included at the top level of the immersive.
        // This check ensures 'GIF' is defined before trying to use it.
        if (typeof GIF === 'undefined') {
            setMessage('GIF.js library not loaded. Please try again or refresh.');
            setTimeout(() => setMessage(''), 3000);
            console.error('GIF.js is not available. Ensure the script is loaded.');
            return;
        }
        // --- END FIX ---

        if (frames.length === 0) {
            setMessage('No frames to export!');
            setTimeout(() => setMessage(''), 2000);
            return;
        }

        setIsExporting(true);
        setExportProgress(0);
        setMessage('Generating GIF...');

        const gif = new GIF({
            workers: 2, // Number of web workers to use for encoding
            quality: 10, // Lower is better quality, but larger file size (1-100)
            delay: 1000 / animationSpeed, // Delay between frames in ms
            width: canvasRef.current.width,
            height: canvasRef.current.height,
            background: '#ffffff', // Set a default background color for transparency
            transparent: '#ffffff' // Make white transparent if desired
        });

        // Add each frame to the GIF
        frames.forEach(frameData => {
            if (typeof frameData === 'string' && frameData.startsWith('data:image/png;base64,')) {
                const img = new Image();
                img.src = frameData;
                // GIF.js needs the image to be loaded before adding.
                // For simplicity, we assume images are ready or handle errors.
                // In a production app, you'd pre-load these.
                gif.addFrame(img, { delay: 1000 / animationSpeed });
            }
        });

        gif.on('progress', function(p) {
            setExportProgress(Math.floor(p * 100));
        });

        gif.on('finished', function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'animation.gif';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up the URL object

            setIsExporting(false);
            setExportProgress(0);
            setMessage('GIF exported successfully!');
            setTimeout(() => setMessage(''), 2000);
        });

        gif.on('error', function(error) {
            console.error('GIF generation error:', error);
            setIsExporting(false);
            setExportProgress(0);
            setMessage('Error exporting GIF.');
            setTimeout(() => setMessage(''), 2000);
        });

        gif.render(); // Start the rendering process
    }, [frames, animationSpeed]);


    // Function to call Gemini API for generating frame ideas
    const generateFrameIdea = useCallback(async () => {
        if (!ideaPrompt.trim()) {
            setMessage('Please enter a prompt for the idea generator.');
            setTimeout(() => setMessage(''), 2000);
            return;
        }

        setIsGeneratingIdea(true);
        setGeneratedIdea(''); // Clear previous idea

        try {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${ideaPrompt}". Keep it concise and focused on visual elements.` }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // API key will be provided by Canvas runtime
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                // Corrected access to the generated text
                const text = result.candidates[0].content.parts[0].text;
                setGeneratedIdea(text);
                setMessage('Idea generated successfully!');
            } else {
                setGeneratedIdea('Could not generate an idea. Please try again.');
                setMessage('Error generating idea.');
            }
        } catch (error) {
            console.error('Error calling Gemini API:', error);
            setGeneratedIdea('Failed to generate an idea due to an error.');
            setMessage('Error generating idea.');
        } finally {
            setIsGeneratingIdea(false);
            setTimeout(() => setMessage(''), 2000);
        }
    }, [ideaPrompt]);

    return (
        // Main container with responsive flex layout, now using h-screen for better fit
        <div className="h-screen bg-gray-100 font-inter flex flex-col items-center p-4 sm:p-6 md:p-8 overflow-hidden">
            {/* Header section */}
            <h1 className="text-4xl sm:text-5xl font-extrabold text-blue-800 mb-4 text-center">
                Aurora Animation Editor
            </h1>

            {/* Message display */}
            {message && (
                <div className="bg-blue-500 text-white px-4 py-2 rounded-lg mb-4 shadow-md transition-opacity duration-500 opacity-100">
                    {message}
                </div>
            )}

            {/* Main editor area: tools + canvas */}
            <div className="flex flex-col md:flex-row w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow">
                {/* Toolbox / Controls Panel */}
                <div className="w-full md:w-1/4 lg:w-1/5 bg-gray-50 p-4 sm:p-6 border-b md:border-b-0 md:border-r border-gray-200 flex flex-col space-y-4 overflow-y-auto">
                    <h2 className="text-xl font-semibold text-gray-700 mb-2">Tools</h2>

                    {/* Tool selection buttons with emojis */}
                    <div className="flex flex-wrap gap-2 mb-4">
                        <button
                            onClick={() => setTool('brush')}
                            className={`flex-1 min-w-[100px] px-4 py-2 rounded-lg transition-all duration-200 text-2xl ${
                                tool === 'brush' ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-200 text-gray-700 hover:bg-blue-100'
                            }`}
                        >
                            ✏️
                        </button>
                        <button
                            onClick={() => setTool('eraser')}
                            className={`flex-1 min-w-[100px] px-4 py-2 rounded-lg transition-all duration-200 text-2xl ${
                                tool === 'eraser' ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-200 text-gray-700 hover:bg-blue-100'
                            }`}
                        >
                            🩹
                        </button>
                        <button
                            onClick={() => setTool('fill')}
                            className={`flex-1 min-w-[100px] px-4 py-2 rounded-lg transition-all duration-200 text-2xl ${
                                tool === 'fill' ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-200 text-gray-700 hover:bg-blue-100'
                            }`}
                        >
                             🪣
                        </button>
                    </div>

                    {/* Brush Color Picker */}
                    <div className="flex flex-col">
                        <label htmlFor="brushColor" className="text-gray-700 font-medium mb-2">Brush Color:</label>
                        <input
                            type="color"
                            id="brushColor"
                            value={brushColor}
                            onChange={(e) => setBrushColor(e.target.value)}
                            className="w-full h-10 rounded-lg border-2 border-gray-300 cursor-pointer"
                        />
                    </div>

                    {/* Brush Size Slider */}
                    <div className="flex flex-col">
                        <label htmlFor="brushSize" className="text-gray-700 font-medium mb-2">Brush Size: <span className="font-bold">{brushSize}px</span></label>
                        <input
                            type="range"
                            id="brushSize"
                            min="1"
                            max="50"
                            value={brushSize}
                            onChange={(e) => setBrushSize(parseInt(e.target.value))}
                            className="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                        />
                    </div>

                    {/* Frame Actions */}
                    <div className="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                        <h2 className="text-xl font-semibold text-gray-700 mb-2">Frame Actions</h2>
                        <button
                            onClick={addFrame}
                            className="bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-600 transition-colors duration-200"
                        >
                            Add New Frame
                        </button>
                        <button
                            onClick={deleteFrame}
                            className="bg-red-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-600 transition-colors duration-200"
                        >
                            Delete Current Frame
                        </button>
                        <button
                            onClick={duplicateFrame}
                            className="bg-green-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-green-600 transition-colors duration-200"
                        >
                            Duplicate Current Frame
                        </button>
                        <button
                            onClick={clearCurrentFrame}
                            className="bg-orange-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-600 transition-colors duration-200"
                        >
                            Clear Current Frame
                        </button>
                    </div>

                    {/* Project Save/Load/Export Actions */}
                    <div className="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                        <h2 className="text-xl font-semibold text-gray-700 mb-2">Project Actions</h2>
                        <button
                            onClick={saveProject}
                            className="bg-indigo-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-indigo-600 transition-colors duration-200"
                        >
                            Save Project
                        </button>
                        <button
                            onClick={loadProject}
                            className="bg-purple-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-purple-600 transition-colors duration-200"
                        >
                            Load Project
                        </button>
                        <button
                            onClick={exportGif}
                            disabled={isExporting || frames.length === 0}
                            className="bg-teal-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-teal-600 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            {isExporting ? `Exporting GIF... ${exportProgress}%` : '🖼️ Export GIF'}
                        </button>
                    </div>

                    {/* Onion Skinning Controls */}
                    <div className="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                        <h2 className="text-xl font-semibold text-gray-700 mb-2">Onion Skinning</h2>
                        <label className="flex items-center space-x-2 cursor-pointer">
                            <input
                                type="checkbox"
                                checked={onionSkinEnabled}
                                onChange={(e) => setOnionSkinEnabled(e.target.checked)}
                                className="form-checkbox h-5 w-5 text-blue-600 rounded"
                            />
                            <span className="text-gray-700">Enable Onion Skin</span>
                        </label>

                        {onionSkinEnabled && (
                            <>
                                <div className="flex flex-col">
                                    <label htmlFor="onionPrev" className="text-gray-700 font-medium mb-1">Previous Frames: <span className="font-bold">{onionSkinPrevCount}</span></label>
                                    <input
                                        type="range"
                                        id="onionPrev"
                                        min="0"
                                        max="5"
                                        value={onionSkinPrevCount}
                                        onChange={(e) => setOnionSkinPrevCount(parseInt(e.target.value))}
                                        className="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>
                                <div className="flex flex-col">
                                    <label htmlFor="onionNext" className="text-gray-700 font-medium mb-1">Next Frames: <span className="font-bold">{onionSkinNextCount}</span></label>
                                    <input
                                        type="range"
                                        id="onionNext"
                                        min="0"
                                        max="5"
                                        value={onionSkinNextCount}
                                        onChange={(e) => setOnionSkinNextCount(parseInt(e.target.value))}
                                        className="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>
                                <div className="flex flex-col">
                                    <label htmlFor="onionOpacity" className="text-gray-700 font-medium mb-1">Opacity: <span className="font-bold">{(onionSkinOpacity * 100).toFixed(0)}%</span></label>
                                    <input
                                        type="range"
                                        id="onionOpacity"
                                        min="0.1"
                                        max="0.8"
                                        step="0.05"
                                        value={onionSkinOpacity}
                                        onChange={(e) => setOnionSkinOpacity(parseFloat(e.target.value))}
                                        className="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>
                                {/* Onion Skin Color Picker */}
                                <div className="flex flex-col">
                                    <label htmlFor="onionSkinColor" className="text-gray-700 font-medium mb-1">Onion Skin Color:</label>
                                    <input
                                        type="color"
                                        id="onionSkinColor"
                                        value={onionSkinColor}
                                        onChange={(e) => setOnionSkinColor(e.target.value)}
                                        className="w-full h-10 rounded-lg border-2 border-gray-300 cursor-pointer"
                                    />
                                </div>
                            </>
                        )}
                    </div>

                    {/* Gemini API Feature: Frame Idea Generator */}
                    <div className="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                        <h2 className="text-xl font-semibold text-gray-700 mb-2">Creative Ideas</h2>
                        <button
                            onClick={() => setShowIdeaModal(true)}
                            className="bg-yellow-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-yellow-600 transition-colors duration-200"
                        >
                            ✨ Generate Frame Idea
                        </button>
                    </div>
                </div>

                {/* Canvas Drawing Area and Playback Controls */}
                <div className="w-full md:w-3/4 lg:w-4/5 p-4 sm:p-6 flex flex-col relative flex-grow">
                    <div className="flex-grow flex justify-center items-center relative">
                        <canvas
                            ref={canvasRef}
                            onMouseDown={startDrawing}
                            onMouseMove={draw}
                            onMouseUp={stopDrawing}
                            onMouseLeave={stopDrawing} // Stop drawing if mouse leaves canvas
                            className="border-2 border-gray-300 rounded-lg shadow-inner bg-white w-full h-full"
                            style={{ touchAction: 'none' }} // Prevent default touch actions like scrolling/zooming
                        ></canvas>
                    </div>

                    {/* Playback Controls */}
                    <div className="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                        <h3 className="text-lg font-semibold text-gray-700">Playback:</h3>
                        <div className="flex gap-2">
                            <button
                                onClick={playAnimation}
                                disabled={isPlaying || frames.length === 0}
                                className="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                ▶️ Play
                            </button>
                            <button
                                onClick={pauseAnimation}
                                disabled={!isPlaying}
                                className="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                ⏸️ Pause
                            </button>
                            <button
                                onClick={stopAnimation}
                                disabled={frames.length === 0}
                                className="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                ⏹️ Stop
                            </button>
                        </div>
                        <div className="flex items-center gap-2 mt-2 sm:mt-0">
                            <label htmlFor="animationSpeed" className="text-gray-700">FPS:</label>
                            <input
                                type="range"
                                id="animationSpeed"
                                min="1"
                                max="30"
                                value={animationSpeed}
                                onChange={(e) => {
                                    setAnimationSpeed(parseInt(e.target.value));
                                    // If playing, restart animation with new speed
                                    if (isPlaying) {
                                        pauseAnimation();
                                        playAnimation();
                                    }
                                }}
                                className="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
                            />
                            <span className="font-bold text-gray-800">{animationSpeed}</span>
                        </div>
                    </div>

                    {/* Frame Timeline */}
                    <div className="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner overflow-x-auto">
                        <h3 className="text-lg font-semibold text-gray-700 mb-3">Timeline</h3>
                        <div className="flex space-x-2 pb-2">
                            {frames.map((_, index) => (
                                <button
                                    key={index}
                                    onClick={() => {
                                        // Pause animation if playing when selecting a frame
                                        if (isPlaying) pauseAnimation();
                                        setCurrentFrameIndex(index);
                                    }}
                                    className={`flex-shrink-0 w-16 h-16 border-2 rounded-lg flex items-center justify-center text-sm font-bold transition-all duration-200
                                        ${index === currentFrameIndex ? 'border-blue-600 bg-blue-100 text-blue-800 shadow-md scale-105' : 'border-gray-300 bg-white text-gray-600 hover:border-blue-400'}
                                    `}
                                >
                                    F{index + 1}
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            </div>

            {/* Frame Idea Generator Modal */}
            {showIdeaModal && (
                <div className="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50">
                    <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
                        <h3 className="text-2xl font-bold text-gray-800 mb-4">✨ Generate Frame Idea</h3>
                        <p className="text-gray-600 mb-4">
                            Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
                        </p>
                        <input
                            type="text"
                            value={ideaPrompt}
                            onChange={(e) => setIdeaPrompt(e.target.value)}
                            placeholder="Enter your prompt here..."
                            className="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            disabled={isGeneratingIdea}
                        />
                        <button
                            onClick={generateFrameIdea}
                            className="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={isGeneratingIdea}
                        >
                            {isGeneratingIdea ? 'Generating...' : 'Get Idea'}
                        </button>

                        {generatedIdea && (
                            <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                                <h4 className="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                                <p className="text-gray-700 whitespace-pre-wrap">{generatedIdea}</p>
                            </div>
                        )}

                        <button
                            onClick={() => {
                                setShowIdeaModal(false);
                                setIdeaPrompt('');
                                setGeneratedIdea('');
                            }}
                            className="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200"
                        >
                            Close
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
};

export default App;
