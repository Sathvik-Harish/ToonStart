<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        /* Basic styling for the body and core layout */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent accidental scrolling on the main page */
        }
        /* Canvas specific styles to make it fill its container and look nice */
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            width: 100%; /* Make the canvas responsive to its parent's width */
            height: 100%; /* Make the canvas responsive to its parent's height */
            touch-action: none; /* Crucial for drawing apps to prevent browser gestures like pinch-zoom */
        }
        /* Utility class for flex containers that should grow */
        .flex-grow-container {
            flex-grow: 1;
            min-height: 0; /* Important for flex items in a column to shrink correctly */
        }
        /* Custom scroll behavior for overflow, just in case */
        .overflow-y-auto-custom {
            overflow-y: auto;
        }
        /* Styling for the main sidebar toolbox */
        #staticToolbox {
            flex-shrink: 0; /* Don't let it shrink */
            width: 256px; /* Fixed width for the toolbox */
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            overflow-y: auto; /* Allow scrolling within the toolbox if content overflows */
            -webkit-overflow-scrolling: touch; /* Smoother scrolling on iOS */
        }
        /* Sections within the toolbox */
        .toolbox-section {
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }
        /* No top border for the very first section */
        .toolbox-section:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        /* Headings for toolbox sections */
        .toolbox-section h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.75rem;
        }
        /* Labels for inputs */
        .toolbox-section label {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            display: block;
        }
        /* Styling for range inputs (sliders) */
        .toolbox-section input[type="range"] {
            width: 100%;
            height: 0.5rem;
        }
        /* Styling for color input */
        .toolbox-section input[type="color"] {
            width: 100%;
            height: 2.5rem;
        }
        /* Styling for tool buttons */
        .tool-button {
            padding: 0.625rem 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s; /* Smooth transition for hover/active states */
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            min-width: 50px;
        }
        /* Styles for help text within modals */
        .zoom-info {
            font-size: 0.875rem;
            color: #4b5563;
            line-height: 1.5;
        }
        .zoom-info ul {
            padding-left: 1.25rem;
        }
        /* Keyboard key styling for instructions */
        .zoom-info kbd {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            font-size: 0.875em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            line-height: 1;
            color: #4a5568;
            background-color: #edf2f7;
            border: 1px solid #cbd5e0;
            border-bottom-color: #a0aec0;
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 #a0aec0;
        }
        /* Small help icon for palm rejection */
        .help-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px; /* Makes it a perfect circle */
            background-color: #9ca3af;
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s;
        }
        .help-icon:hover {
            background-color: #6b7280;
        }
    </style>
</head>
<body class="h-screen bg-gray-100 flex flex-col items-center p-4 sm:p-6 md:p-8">

    <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-800 mb-4 text-center">
        ToonStart Animation Editor <span class="text-xs font-normal align-top ml-2 text-gray-600">S.H. - S.S.</span>
    </h1>

    <div id="messageDisplay" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md transition-opacity duration-500 opacity-0 z-1000 hidden"></div>

    <div class="flex w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow flex-grow-container">
        <div id="staticToolbox">
            <div class="flex flex-col space-y-4">
                <div class="toolbox-section">
                    <h2>Tools</h2>
                    <div class="flex flex-wrap gap-1">
                        <button id="pencilTool" class="tool-button bg-blue-600 text-white shadow-md">‚úèÔ∏è</button>
                        <button id="eraserTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü©π</button>
                        <button id="fillTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™£</button>
                        <button id="eyedropperTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üíâ</button>
                        <button id="panTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚úã</button>
                    </div>
                    <div class="mt-4 flex items-center">
                        <input type="checkbox" id="stylusOnlyModeToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="stylusOnlyModeToggle" class="text-sm font-medium text-gray-700">Palm Rejection</label>
                        <span id="palmRejectionHelpIcon" class="help-icon">?</span>
                    </div>
                </div>

                <div class="toolbox-section">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#000000" class="rounded-lg border-2 border-gray-300 cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="brushSize">Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <h2>Frames</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="addFrame" class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-blue-600 text-sm">Add New</button>
                        <button id="deleteFrame" class="bg-red-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-red-600 text-sm">Delete</button>
                        <button id="duplicateFrame" class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-green-600 text-sm">Duplicate</button>
                        <button id="clearCurrentFrame" class="bg-orange-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-orange-600 text-sm">Clear</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>History</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="undoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü©Ô∏è Undo</button>
                        <button id="redoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü™Ô∏è Redo</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Project</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="saveProject" class="bg-indigo-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-indigo-600 text-sm">Save</button>
                        <button id="loadProject" class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-purple-600 text-sm">Load</button>
                        <button id="exportGif" class="bg-teal-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-teal-600 text-sm">
                            üñºÔ∏è Export GIF
                        </button>
                        <button id="customizeBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚öôÔ∏è Customize
                        </button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Ideas</h2>
                    <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-yellow-600 text-sm w-full">
                        ‚ú® Generate Idea
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Info</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="helpBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì Help
                        </button>
                        <button id="faqBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì FAQ
                        </button>
                        <button id="updatesBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ú® Updates
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="flex flex-col relative flex-grow p-4 sm:p-6">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                        üé¨
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200">
                        ‚è∏Ô∏è
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200">
                        üõë
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner max-h-24">
                <div id="timelineContainer" class="overflow-x-auto pb-2">
                    <div id="timeline" class="flex flex-nowrap space-x-2 items-center">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4 flex-shrink-0">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 flex-shrink-0">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 flex-shrink-0">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden flex-grow overflow-y-auto">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">‚ùì Help & View Tips</h3>
            <p class="zoom-info mb-4">
                If parts of the editor content appear cut off or you want to see more, you can adjust your browser's zoom level.
            </p>
            <ul class="zoom-info list-disc list-inside space-y-2">
                <li>
                    <span class="font-semibold">Browser Zoom Out:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>-</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>-</kbd> (Windows)
                </li>
                <li>
                    <span class="font-semibold">Browser Reset Zoom to 100%:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>0</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>0</kbd> (Windows)
                </li>
                <li>
                    <span class="font-semibold">If browser zooming in and out doesn't work as expected, try setting your browser zoom to 150% and then refresh the page. This can sometimes resolve layout issues and bring the timeline back into view.</span>
                </li>
                <li>
                    <span class="font-semibold">Canvas Pan:</span> Click and drag with the "‚úã Hand" tool to pan.
                </li>
                <li>
                    <span class="font-semibold">Line Smoothness:</span> If lines appear jagged or pixelated (especially at smaller brush sizes or high canvas resolutions), ensure your browser's "image smoothing" is enabled. This feature is enabled by default in ToonStart to improve line quality.
                </li>
                <li>
                    <span class="font-semibold">Brush Selection:</span> Double-click the 'Pencil' tool to open a menu and choose between 'Brush', 'Pen', and 'Pencil' drawing styles. Each style offers a distinct drawing feel.
                </li>
            </ul>
            <button id="closeHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="palmRejectionHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">üñêÔ∏è What is Palm Rejection?</h3>
            <p class="text-gray-700 mb-4">
                When "Palm Rejection" is enabled, the drawing canvas will <strong>only respond to input from a digital pen or stylus</strong>.
            </p>
            <p class="text-gray-700 mb-4">
                Touches from your fingers or palm will be ignored, allowing you to rest your hand on the screen while drawing without making accidental marks.
            </p>
            <p class="text-gray-700 text-sm italic">
                Note: This feature relies on your device and browser accurately reporting stylus input. Passive styluses (rubber-tip) may still be detected as finger touches.
            </p>
            <button id="closePalmRejectionHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="updatesModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® ToonStart Updates</h3>
            <div id="updatesContent" class="text-gray-700 space-y-4 flex-grow overflow-y-auto">
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Fixed Modal Scrolling</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Modal Scrolling:</strong> The "Generate Idea" and "Updates" modals now correctly handle long content by allowing the content to scroll while keeping the "Close" button fixed at the bottom.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Brush Selection Persistence Fix</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Selection:</strong> Fixed an issue where the selected brush type (Brush, Pen, or Pencil) wasn't consistently active after choosing it from the double-click menu. Your brush choice will now stick!</li>
                        <li><strong>Pencil Tool Behavior:</strong> The main 'Pencil' tool button in the sidebar will now *only* open the brush selection menu on double-click, preventing accidental changes to your brush type.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Improved Brush Selection Highlight</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Clearer Selection:</strong> When you open the brush selection menu, the currently active brush style (Brush, Pen, or Pencil) will now be clearly highlighted, making it easier to see your current choice.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Enhanced Brush Styles & Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Behavior:</strong> The 'Brush', 'Pen', and 'Pencil' tools now have distinct drawing feels:
                            <ul>
                                <li>'Pencil' offers a light, sketchy line.</li>
                                <li>'Pen' draws a solid, straightforward line.</li>
                                <li>'Brush' provides a slightly softer, more "painterly" stroke.</li>
                            </ul>
                        </li>
                        <li><strong>Tool Selection Reliability:</strong> Fixed an issue where selecting a brush type from the double-click menu wasn't consistently applying the chosen tool.</li>
                        <li><strong>Pencil Tool Feedback:</strong> The main 'Pencil' tool button will now stay highlighted whenever 'Brush', 'Pen', or 'Pencil' is the active drawing style.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Refined Brush Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Streamlined Tools:</strong> The main toolbox now features only the 'Pencil' tool for drawing.</li>
                        <li><strong>Intuitive Brush Menu:</strong> Double-clicking the 'Pencil' tool will bring up a menu, allowing you to select between 'Brush', 'Pen', and 'Pencil' drawing styles.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - New Brush Tools</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>New Brushes:</strong> Added 'Pen' and 'Pencil' tools for more drawing variety.</li>
                        <li><strong>Brush Selection Menu:</strong> Double-clicking the 'Pencil' tool now brings up a menu to easily switch between 'Brush', 'Pen', and 'Pencil' modes.</li>
                        <li><strong>Pencil Feel:</strong> The 'Pencil' tool now draws with a lighter, sketchier appearance.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Updated GIF Export Logic</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>GIF Export:</strong> Updated the GIF export logic to explicitly draw each frame onto a temporary canvas before adding it to the GIF, ensuring consistent output.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Improved Drawing Smoothness</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Shape & Diagonal Lines:</strong> Fixed issues where circular brush strokes would appear square or jagged, especially on diagonals or after canvas resizing. Image smoothing is now explicitly enabled for both drawing and display contexts to ensure smoother line rendering.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Added FAQ Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>FAQ Button:</strong> Added a new "FAQ" button in the "Info" section linking to the help page.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Fixed Canvas Resizing</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Canvas Resizing:</strong> Lines and existing drawings now maintain their original thickness when resizing the project canvas.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Zoom Feature Removed</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature Removed:</strong> Zoom functionality has been removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 29, 2025 - Zoom Feature & UI Polish</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature:</strong> Added zoom functionality via scroll wheel and a dedicated slider in the new "Zoom & Pan" section.</li>
                        <li><strong>"Zoom & Pan" Section:</strong> New toolbox section for zoom and pan controls.</li>
                        <li><strong>Timeline Text Removed:</strong> "Timeline" heading removed as requested.</li>
                        <li><strong>Help Text Updated:</strong> Included instructions for the new zoom feature.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 28, 2025 - Canvas Resizing & UI Refinements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Canvas Resizing:</strong> Added ability to change project width and height in Customize modal. Existing frames scale proportionally.</li>
                        <li><strong>Customize Button Relocated:</strong> Moved to the "Project" section for better organization.</li>
                        <li><strong>Onion Skinning Removed:</strong> Feature removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Layout & Drawing Stability</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Brush Offset:</strong> Drawing now consistently aligns with cursor regardless of timeline changes.</li>
                        <li><strong>Timeline Horizontal Scroll:</strong> Timeline now scrolls horizontally when many frames are added, preventing vertical layout shifts.</li>
                        <li><strong>Improved GIF Export:</strong> More reliable GIF generation due to consistent internal canvas dimensions.</li>
                        <li>**Help Text Updated:** Added a new tip regarding browser zoom and refreshing.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 25, 2025 - Critical Bug Fixes & Improvements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Drawing:</strong> Drawing tools now work correctly and responsively.</li>
                        <li><strong>Fixed Undo/Redo:</strong> History system is fully functional.</li>
                        <li><strong>Fixed Generate Idea:</strong> AI idea generator now works as expected.</li>
                        <li><strong>Fixed Updates Button:</strong> The updates modal now opens correctly.</li>
                        <li><strong>Restored Message Display:</strong> Temporary on-screen messages are back for user feedback.</li>
                        <li><strong>Fixed Fill Tool:</strong> Now accurately fills areas regardless of pan.</li>
                        <li><strong>Fixed Eyedropper Tool:</strong> Accurately picks colors from the canvas.</li>
                        <li>**Enhanced Responsiveness:** Significant performance improvements for drawing and canvas interactions.</li>
                        <li>**Removed Zoom Feature:** Canvas no longer supports zoom, focusing on direct drawing.</li>
                        <li>**Pipette Icon Update:** Changed to üíâ emoji.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 23, 2025 - Initial Feature Enhancements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Undo/Redo History:</strong> Easily correct mistakes with multiple steps.</li>
                        <li><strong>Pan Tool:</strong> Navigate the canvas for detailed work or overview.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 22, 2025 - Basic Drawing & Animation</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Basic Drawing Tools:</strong> Brush, Eraser, Fill.</li>
                        <li><strong>Frame Management:</strong> Add, delete, duplicate, clear frames.</li>
                        <li><strong>Animation Playback:</strong> Play, pause, stop animation with adjustable speed.</li>
                        <li><strong>Project Save/Load:</strong> Save and load your animation projects locally.</li>
                        <li><strong>GIF Export:</strong> Export your animation as a GIF.</li>
                        <li><strong>AI Idea Generator:</strong> Get creative ideas for your frames.</li>
                        <li><strong>Touch Support:</strong> Basic drawing on touch devices like iPad.</li>
                        <li><strong>Palm Rejection:</strong> Option to enable stylus-only drawing.</li>
                    </ul>
                </div>
            </div>
            <button id="closeUpdatesModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="customizeModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚öôÔ∏è Customize Editor</h3>
            <div class="space-y-4">
                <div>
                    <label for="projectWidth" class="block text-sm font-medium text-gray-700">Project Width (px):</label>
                    <input type="number" id="projectWidth" min="100" max="2000" value="800"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="projectHeight" class="block text-sm font-medium text-gray-700">Project Height (px):</label>
                    <input type="number" id="projectHeight" min="100" max="1500" value="600"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyCanvasSizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Canvas Size
                </button>
                <button id="resetCanvasSizeBtn" class="w-full bg-gray-300 text-gray-800 px-4 py-2 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Reset to Default (800x600)
                </button>
            </div>
            <button id="closeCustomizeModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="brushSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-xs">
            <h3 class="text-xl font-bold text-gray-800 mb-4 text-center">Choose Brush</h3>
            <div class="flex flex-col space-y-3">
                <button id="selectBrushTool" class="bg-blue-500 text-white px-4 py-2 rounded-lg shadow-sm hover:bg-blue-600">Brush</button>
                <button id="selectPenTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pen</button>
                <button id="selectPencilTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pencil</button>
            </div>
            <button id="closeBrushSelectionModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>


    <script>
        // Get references to the main canvas and its 2D rendering context
        const mainCanvas = document.getElementById('drawingCanvas');
        const mainCtx = mainCanvas.getContext('2d');

        // Create an offscreen canvas for drawing operations to prevent flickering
        // This is a common technique for smoother drawing performance.
        const bufferCanvas = document.createElement('canvas');
        const bufferCtx = bufferCanvas.getContext('2d');

        // Initial project dimensions. These can be customized later.
        let projWidth = 800;
        let projHeight = 600;

        // Element to display temporary messages to the user
        const msgDisplay = document.getElementById('messageDisplay');

        // References to all the tool buttons and input elements
        const pencilToolBtn = document.getElementById('pencilTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const eyedropperToolBtn = document.getElementById('eyedropperTool');
        const panToolBtn = document.getElementById('panTool');
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');

        // Palm rejection toggle and its associated help icon
        const stylusOnlyModeToggle = document.getElementById('stylusOnlyModeToggle');
        let isStylusOnlyModeEnabled = false;

        // Frame management buttons
        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        // Project save/load/export buttons
        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');

        // Animation playback controls
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animSpeedInput = document.getElementById('animationSpeed');
        const animSpeedValueSpan = document.getElementById('animationSpeedValue');

        // Timeline elements
        const timelineDiv = document.getElementById('timeline');
        const timelineContainer = document.getElementById('timelineContainer');

        // AI Idea generation modal elements
        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');

        // Help modal elements
        const helpBtn = document.getElementById('helpBtn'); 
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');

        // FAQ and Updates buttons/modals
        const faqBtn = document.getElementById('faqBtn');
        const updatesBtn = document.getElementById('updatesBtn');
        const updatesModal = document.getElementById('updatesModal');
        const closeUpdatesModalBtn = document.getElementById('closeUpdatesModalBtn');

        // Undo/Redo buttons
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        // Palm rejection help modal elements
        const palmRejectionHelpIcon = document.getElementById('palmRejectionHelpIcon');
        const palmRejectionHelpModal = document.getElementById('palmRejectionHelpModal');
        const closePalmRejectionHelpModalBtn = document.getElementById('closePalmRejectionHelpModalBtn');

        // Customize canvas size modal elements
        const customizeBtn = document.getElementById('customizeBtn');
        const customizeModal = document.getElementById('customizeModal');
        const closeCustomizeModalBtn = document.getElementById('closeCustomizeModalBtn');
        const projectWidthInput = document.getElementById('projectWidth');
        const projectHeightInput = document.getElementById('projectHeight');
        const applyCanvasSizeBtn = document.getElementById('applyCanvasSizeBtn');
        const resetCanvasSizeBtn = document.getElementById('resetCanvasSizeBtn');

        // Brush selection modal elements
        const brushSelectionModal = document.getElementById('brushSelectionModal');
        const selectBrushToolBtn = document.getElementById('selectBrushTool');
        const selectPenToolBtn = document.getElementById('selectPenTool');
        const selectPencilToolBtn = document.getElementById('selectPencilTool');
        const closeBrushSelectionModalBtn = document.getElementById('closeBrushSelectionModalBtn');

        // Core state variables for drawing and animation
        let drawingActive = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let currentTool = 'brush'; // Default tool, 'brush' is a good starting point

        // Animation frames stored as Data URLs
        let framesData = [];
        let currentFrameIdx = 0;

        // Playback state
        let animPlaying = false;
        let fps = 10;
        let animInterval = null;

        // GIF export state
        let exporting = false;
        let exportProg = 0;

        // Undo/Redo history management
        let historyStates = [];
        let historyPtr = -1;
        const MAX_HISTORY_STATES = 50; // Limit history to prevent excessive memory use

        // Panning state
        let panOffset = { x: 0, y: 0 };
        let panningActive = false;
        let lastPanPt = { x: 0, y: 0 }; // Stores the last mouse position during a pan

        // Cache for loaded images (Data URLs) to avoid re-loading
        const imageCache = new Map();

        /**
         * Shows a temporary message to the user.
         * @param {string} msg - The message to display.
         */
        function showUserMessage(msg) {
            // Clear any existing timeout to ensure the new message is fully visible
            if (msgDisplay._timeoutId) {
                clearTimeout(msgDisplay._timeoutId);
            }
            msgDisplay.textContent = msg;
            msgDisplay.classList.remove('hidden', 'opacity-0');
            msgDisplay.classList.add('opacity-100');
            
            // Set a timeout to fade out and hide the message
            msgDisplay._timeoutId = setTimeout(() => {
                msgDisplay.classList.remove('opacity-100');
                msgDisplay.classList.add('opacity-0');
                // After fade out, truly hide the element
                msgDisplay._timeoutId = setTimeout(() => msgDisplay.classList.add('hidden'), 500);
            }, 2000); // Message visible for 2 seconds
        }

        /**
         * Converts a hex color string to an RGBA array.
         * @param {string} hex - Like "#RRGGBB".
         * @returns {number[]} [R, G, B, A] where A is always 255.
         */
        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255]; // Alpha is always 255 (fully opaque) for our purposes
        }

        /**
         * Converts RGBA components back to a hex color string.
         * @param {number} r - Red (0-255).
         * @param {number} g - Green (0-255).
         * @param {number} b - Blue (0-255).
         * @returns {string} The hex color string.
         */
        function rgbaToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        /**
         * Loads an image from a Data URL, caching it for speed.
         * @param {string} src - The image Data URL.
         * @returns {Promise<HTMLImageElement>} Promise of the loaded Image object.
         */
        function loadImage(src) {
            // Check if the image is already in our cache
            if (imageCache.has(src)) {
                return Promise.resolve(imageCache.get(src));
            }
            // If not, load it and then cache it
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache.set(src, img); // Store in cache for future use
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        /**
         * Saves the current frames state to the history stack for undo/redo.
         */
        function saveStateToHistory() {
            // If we've undone some actions, discard the "future" history
            if (historyPtr < historyStates.length - 1) {
                historyStates = historyStates.slice(0, historyPtr + 1);
            }
            // Add the current set of frames to the history
            historyStates.push(JSON.parse(JSON.stringify(framesData)));
            historyPtr++;

            // Keep history stack from growing too large
            if (historyStates.length > MAX_HISTORY_STATES) {
                historyStates.shift(); // Remove the oldest state
                historyPtr--;
            }
            updateUndoRedoButtons(); // Update button states
        }

        /**
         * Reverts the editor to the previous state.
         */
        function performUndo() {
            if (historyPtr > 0) {
                historyPtr--;
                // Restore frames from the history
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr]));
                // Load the active frame into the offscreen buffer and then render
                loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateUndoRedoButtons();
                showUserMessage('Undo successful!');
            }
        }

        /**
         * Reapplies the last undone action.
         */
        function performRedo() {
            if (historyPtr < historyStates.length - 1) {
                historyPtr++;
                // Restore frames from the history
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr]));
                // Load the active frame into the offscreen buffer and then render
                loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateUndoRedoButtons();
                showUserMessage('Redo successful!');
            }
        }

        /**
         * Updates the disabled state of the Undo and Redo buttons.
         */
        function updateUndoRedoButtons() {
            undoBtn.disabled = !(historyPtr > 0);
            redoBtn.disabled = !(historyPtr < historyStates.length - 1);
        }

        /**
         * Loads a frame's image data into the offscreen drawing buffer.
         * This is where actual drawing happens before displaying.
         * @param {string} frameData - The Data URL of the frame.
         */
        async function loadFrameIntoBuffer(frameData) {
            // Clear the offscreen buffer first
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);

            // If there's actual frame data, draw it
            if (frameData && typeof frameData === 'string' && frameData.startsWith('data:image/png;base64,')) {
                try {
                    // Try to get from cache, otherwise load it
                    const img = imageCache.get(frameData) || await loadImage(frameData);
                    bufferCtx.drawImage(img, 0, 0, bufferCanvas.width, bufferCanvas.height);
                } catch (error) {
                    console.error("Oops, couldn't load frame data into the buffer:", error);
                }
            }
        }

        /**
         * Renders the content from the offscreen buffer onto the main visible canvas.
         * This is called frequently to update the display.
         */
        async function renderCanvasDisplay() {
            // Clear the visible canvas
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            mainCtx.fillStyle = '#ffffff';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            mainCtx.save(); // Save the current transformation state

            // Apply panning offset
            mainCtx.translate(panOffset.x, panOffset.y);
            
            // Calculate dimensions to draw the project content scaled to fit the display canvas
            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            // Adjust if height is too large for the display canvas
            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            // Center the drawing within the display canvas
            const offsetX = (mainCanvas.width - displayContentWidth) / 2;
            const offsetY = (mainCanvas.height - displayContentHeight) / 2;

            // Draw the content from the offscreen buffer
            mainCtx.globalAlpha = 1.0;
            mainCtx.globalCompositeOperation = 'source-over';
            mainCtx.drawImage(bufferCanvas, offsetX, offsetY, displayContentWidth, displayContentHeight);

            // Draw a dashed border to show the actual project boundaries
            mainCtx.strokeStyle = '#888888';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]); // Dashed line
            mainCtx.strokeRect(offsetX, offsetY, displayContentWidth, displayContentHeight);
            mainCtx.setLineDash([]); // Reset line dash

            mainCtx.restore(); // Restore the transformation state
            mainCtx.globalAlpha = 1.0; // Reset alpha
            mainCtx.globalCompositeOperation = 'source-over'; // Reset composite operation
        }

        /**
         * Saves the current drawing from the offscreen buffer into the active frame.
         */
        function saveCurrentFrameData() {
            framesData[currentFrameIdx] = bufferCanvas.toDataURL('image/png');
        }

        /**
         * Transforms mouse/touch coordinates on the main canvas to coordinates within the project's drawing space.
         * Accounts for panning and scaling.
         * @param {number} clientX - The clientX coordinate from the event.
         * @param {number} clientY - The clientY coordinate from the event.
         * @returns {{x: number, y: number}} The transformed coordinates.
         */
        function getTransformedDrawingCoords(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            // Calculate current display dimensions of the project content on the canvas
            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            const displayOffsetX = (mainCanvas.width - displayContentWidth) / 2;
            const displayOffsetY = (mainCanvas.height - displayContentHeight) / 2;

            // Adjust for pan offset and the centering offset
            const transformedX = (canvasX - panOffset.x - displayOffsetX);
            const transformedY = (canvasY - panOffset.y - displayOffsetY);

            // Scale back to the original project dimensions
            const x = transformedX * (projWidth / displayContentWidth);
            const y = transformedY * (projHeight / displayContentHeight);

            return { x, y };
        }

        /**
         * Handles the start of a drawing or tool interaction (mousedown/touchstart).
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function handleInteractionStart(e) {
            e.preventDefault(); // Prevent default browser actions like scrolling/zooming

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // If palm rejection is enabled, ignore non-stylus touches
            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct'; // 'direct' usually means finger
                if (touchType === 'direct') {
                    drawingActive = false; // Don't start drawing
                    return; // Exit early
                }
            }

            // Handle Eyedropper tool
            if (currentTool === 'eyedropper') {
                const rect = mainCanvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                // Get pixel data from the *visible* canvas
                const imageData = mainCtx.getImageData(canvasX, canvasY, 1, 1).data;
                brushColor = rgbaToHex(imageData[0], imageData[1], imageData[2]);
                brushColorInput.value = brushColor; // Update the color picker UI
                bufferCtx.strokeStyle = brushColor; // Set drawing color
                
                currentTool = 'brush'; // Switch back to brush after picking
                updateToolButtonStates(); // Update UI to reflect tool change
                showUserMessage('Color picked!');
                return; // Interaction handled, no drawing
            }

            // Handle Pan tool
            if (currentTool === 'pan') {
                panningActive = true;
                lastPanPt = { x: clientX, y: clientY }; // Store starting point for panning
                return; // Interaction handled, no drawing
            }

            // Handle Fill tool (Flood Fill)
            if (currentTool === 'fill') {
                // Load the current frame into the buffer before performing fill
                loadFrameIntoBuffer(framesData[currentFrameIdx]).then(() => {
                    const { x, y } = getTransformedDrawingCoords(clientX, clientY);
                    // Perform the flood fill operation
                    floodFill(x, y, hexToRgba(brushColor), bufferCtx, bufferCanvas.width, bufferCanvas.height);
                    saveCurrentFrameData(); // Save the modified frame
                    renderCanvasDisplay(); // Update the display
                    saveStateToHistory(); // Record for undo/redo
                    showUserMessage('Fill applied!');
                }).catch(error => {
                    console.error("Error loading frame for fill operation:", error);
                    showUserMessage('Error applying fill.');
                });
                return; // Interaction handled, no drawing
            }

            // For drawing tools (pencil, brush, pen, eraser)
            bufferCtx.lineCap = 'round'; // Round line endings
            bufferCtx.lineJoin = 'round'; // Round line joins
            bufferCtx.strokeStyle = brushColor;
            bufferCtx.lineWidth = brushSize;
            bufferCtx.globalCompositeOperation = 'source-over'; // Default blend mode

            // Apply specific alpha (opacity) for different brush types
            if (currentTool === 'pencil') {
                bufferCtx.globalAlpha = 0.4; // Lighter, sketchy feel
            } else if (currentTool === 'brush') {
                bufferCtx.globalAlpha = 0.7; // Slightly softer, painterly
            } else { // 'pen' tool
                bufferCtx.globalAlpha = 1.0; // Solid, opaque line
            }

            // Get transformed coordinates to start drawing
            const { x, y } = getTransformedDrawingCoords(clientX, clientY);
            bufferCtx.beginPath(); // Start a new path
            bufferCtx.moveTo(x, y); // Move to the starting point
            drawingActive = true; // Set drawing flag
        }

        /**
         * Handles drawing or tool interaction during movement (mousemove/touchmove).
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function handleInteractionMove(e) {
            e.preventDefault(); // Prevent default browser actions

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // If palm rejection is enabled, ignore non-stylus touches during move
            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    drawingActive = false; // Stop drawing if a finger is detected mid-stroke
                    return;
                }
            }

            // Handle Panning logic
            if (currentTool === 'pan' && panningActive) {
                const dx = clientX - lastPanPt.x;
                const dy = clientY - lastPanPt.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPt = { x: clientX, y: clientY }; // Update last position
                renderCanvasDisplay(); // Re-render canvas with new pan offset
                return; // Panning handled, no drawing
            }

            // If not drawing, just exit
            if (!drawingActive) return;

            // Get transformed coordinates for the current point
            const { x, y } = getTransformedDrawingCoords(clientX, clientY);
            
            // Set composite operation for eraser (makes pixels transparent)
            if (currentTool === 'eraser') {
                bufferCtx.globalCompositeOperation = 'destination-out';
            } else {
                bufferCtx.globalCompositeOperation = 'source-over'; // Back to normal for drawing tools
            }

            bufferCtx.lineTo(x, y); // Draw a line segment to the current point
            bufferCtx.stroke(); // Apply the stroke
            renderCanvasDisplay(); // Update the visible canvas
        }

        /**
         * Handles the end of a drawing or tool interaction (mouseup/touchend/mouseleave).
         * @param {MouseEvent|TouchEvent} e - The event object.
         */
        function handleInteractionEnd(e) {
            e.preventDefault(); // Prevent default browser actions

            // Only save state if a drawing tool was active and drawing occurred
            if (currentTool !== 'fill' && currentTool !== 'eyedropper' && currentTool !== 'pan') {
                if (drawingActive) {
                    bufferCtx.closePath(); // Close the current drawing path
                    bufferCtx.globalCompositeOperation = 'source-over'; // Reset blend mode
                    bufferCtx.globalAlpha = 1.0; // Reset opacity
                    saveCurrentFrameData(); // Save the final stroke to the current frame
                    saveStateToHistory(); // Record this state for undo/redo
                }
            }
            drawingActive = false; // Reset drawing flag
            panningActive = false; // Reset panning flag
            renderCanvasDisplay(); // Ensure the display is updated one last time
        }

        /**
         * Implements a basic flood fill algorithm.
         * @param {number} startX - X coordinate to start fill from.
         * @param {number} startY - Y coordinate to start fill from.
         * @param {number[]} fillColor - RGBA array of the color to fill with.
         * @param {CanvasRenderingContext2D} ctx - The context to draw on (offscreen buffer context).
         * @param {number} width - Width of the canvas.
         * @param {number} height - Height of the canvas.
         */
        function floodFill(startX, startY, fillColor, ctx, width, height) {
            // Get all pixel data from the canvas
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            // Helper to get color of a pixel
            const getPixelColor = (x, y) => {
                // Check bounds first
                if (x < 0 || x >= width || y < 0 || y >= height) return [-1, -1, -1, -1];
                const index = (y * width + x) * 4; // Each pixel has 4 components (RGBA)
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            // Helper to set color of a pixel
            const setPixelColor = (x, y, color) => {
                const index = (y * width + x) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            // Get the color of the starting pixel
            const startColor = getPixelColor(Math.floor(startX), Math.floor(startY));

            // If the start color is out of bounds or already the fill color, do nothing
            if (startColor[0] === -1 || (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3])) {
                return;
            }

            // Use a stack for the fill algorithm
            const pixelStack = [[Math.floor(startX), Math.floor(startY)]];
            const visited = new Set(); // Keep track of visited pixels to avoid infinite loops

            // Function to check if two colors are "close enough" (with a tolerance)
            const colorsMatch = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            // Main fill loop
            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop();
                const key = `${x},${y}`; // Unique key for visited set

                if (visited.has(key)) continue; // Skip if already visited
                visited.add(key); // Mark as visited

                // If current pixel is within bounds and matches the starting color
                if (x >= 0 && x < width && y >= 0 && y < height && colorsMatch(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor); // Set its color to the fill color

                    // Add neighboring pixels to the stack to be checked
                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0); // Put the modified pixel data back
        }

        /**
         * Updates the visual representation of the timeline with frame buttons.
         */
        function updateTimelineDisplay() {
            timelineDiv.innerHTML = ''; // Clear existing buttons
            framesData.forEach((_, index) => {
                const frameButton = document.createElement('button');
                frameButton.textContent = `F${index + 1}`; // Display "F1", "F2", etc.
                frameButton.classList.add('flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold', 'transition-all', 'duration-200');
                
                // Highlight the currently active frame
                if (index === currentFrameIdx) {
                    frameButton.classList.add('border-blue-600', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                } else {
                    frameButton.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                }
                
                // Set click handler to switch frames
                frameButton.onclick = () => {
                    if (animPlaying) pauseAnimationPlayback(); // Pause if playing
                    currentFrameIdx = index; // Set new active frame
                    loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and render
                    updateTimelineDisplay(); // Re-render timeline to update highlight
                };
                timelineDiv.appendChild(frameButton);
            });
        }

        /**
         * Adds a new blank frame after the current active frame.
         */
        function addFrame() {
            saveCurrentFrameData(); // Save current frame's drawing before switching

            // Create a blank canvas image data
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const blankFrameData = bufferCanvas.toDataURL('image/png');

            // Insert the new blank frame into the sequence
            framesData.splice(currentFrameIdx + 1, 0, blankFrameData);
            currentFrameIdx++; // Move to the new frame
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display
            updateTimelineDisplay(); // Update timeline UI
            saveStateToHistory(); // Record for undo/redo
            showUserMessage('New frame added!');
        }

        /**
         * Deletes the current active frame. Prevents deleting the last frame.
         */
        function deleteFrame() {
            if (framesData.length <= 1) {
                showUserMessage('Cannot delete the last frame! You need at least one.');
                return;
            }
            framesData.splice(currentFrameIdx, 1); // Remove the current frame
            // Adjust active frame index if the last frame was deleted
            if (currentFrameIdx >= framesData.length) {
                currentFrameIdx = framesData.length - 1;
            }
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display
            updateTimelineDisplay(); // Update timeline UI
            saveStateToHistory(); // Record for undo/redo
            showUserMessage('Frame deleted!');
        }

        /**
         * Duplicates the current active frame and inserts it after.
         */
        function duplicateFrame() {
            const currentFrameData = framesData[currentFrameIdx]; // Get data of current frame
            framesData.splice(currentFrameIdx + 1, 0, currentFrameData); // Insert a copy
            currentFrameIdx++; // Move to the duplicated frame
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display
            updateTimelineDisplay(); // Update timeline UI
            saveStateToHistory(); // Record for undo/redo
            showUserMessage('Frame duplicated!');
        }

        /**
         * Clears all drawing from the current active frame.
         */
        function clearCurrentFrame() {
            // Clear the offscreen buffer completely
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            saveCurrentFrameData(); // Save the now blank frame
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display
            saveStateToHistory(); // Record for undo/redo
            showUserMessage('Current frame cleared!');
        }

        /**
         * Saves the entire animation project to local storage.
         */
        function saveProject() {
            saveCurrentFrameData(); // Ensure the current frame's drawing is saved
            localStorage.setItem('animationProject', JSON.stringify(framesData));
            localStorage.setItem('currentFrameIndex', currentFrameIdx.toString());
            localStorage.setItem('projectWidth', projWidth.toString());
            localStorage.setItem('projectHeight', projHeight.toString());
            showUserMessage('Animation project saved!');
        }

        /**
         * Loads an animation project from local storage.
         */
        function loadProject() {
            const savedProjectData = localStorage.getItem('animationProject');
            const savedActiveIndex = localStorage.getItem('currentFrameIndex');
            const savedProjectWidth = localStorage.getItem('projectWidth');
            const savedProjectHeight = localStorage.getItem('projectHeight');

            if (!savedProjectData) {
                showUserMessage('No saved animation project found! Start drawing something new!');
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProjectData);
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    framesData = loadedFrames;
                    currentFrameIdx = Math.min(parseInt(savedActiveIndex, 10) || 0, framesData.length - 1);
                    
                    const newWidth = parseInt(savedProjectWidth, 10) || 800;
                    const newHeight = parseInt(savedProjectHeight, 10) || 600;
                    
                    // If project dimensions changed, apply them
                    if (newWidth !== projWidth || newHeight !== projHeight) {
                        projWidth = newWidth;
                        projHeight = newHeight;
                        projectWidthInput.value = projWidth;
                        projectHeightInput.value = projHeight;
                    }
                    
                    // Reset history when loading a new project
                    historyStates = [];
                    historyPtr = -1;
                    saveStateToHistory(); // Save the loaded state as the first history entry
                    loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay);
                    updateTimelineDisplay();
                    showUserMessage('Animation project loaded successfully!');
                } else {
                    showUserMessage('Hmm, saved project data seems a bit off or empty.');
                }
            } catch (error) {
                console.error("Error trying to parse loaded project data:", error);
                showUserMessage('Something went wrong loading the project data.');
            }
        }

        /**
         * Starts playing the animation sequence.
         */
        function startAnimationPlayback() {
            if (framesData.length === 0) {
                showUserMessage('Can\'t play an animation with no frames!');
                return;
            }
            if (animPlaying) return; // Already playing

            animPlaying = true;
            
            renderCanvasDisplay(); // Render the current frame immediately

            const frameDelay = 1000 / fps; // Calculate delay based on FPS
            animInterval = setInterval(() => {
                // Move to the next frame, looping back to start if at the end
                currentFrameIdx = (currentFrameIdx + 1) % framesData.length;
                loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay);
                updateTimelineDisplay(); // Keep timeline highlight updated
            }, frameDelay);
            
            // Update button states
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            showUserMessage('Playing animation...');
        }

        /**
         * Pauses the currently playing animation.
         */
        function pauseAnimationPlayback() {
            if (animInterval) {
                clearInterval(animInterval); // Stop the interval timer
                animInterval = null;
            }
            animPlaying = false;
            // Update button states
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            showUserMessage('Animation paused.');
        }

        /**
         * Stops the animation and resets to the first frame.
         */
        function stopAnimationPlayback() {
            pauseAnimationPlayback(); // First, pause it
            currentFrameIdx = 0; // Go back to the first frame
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay);
            updateTimelineDisplay(); // Update timeline highlight
            // Update button states
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            showUserMessage('Animation stopped.');
        }

        /**
         * Exports the entire animation sequence as a GIF file.
         */
        async function exportGifAnimation() {
            // Check if GIF.js library is available
            if (typeof GIF === 'undefined') {
                showUserMessage('GIF.js library not loaded. Cannot export GIF.');
                console.error('GIF.js is missing! Make sure the script is loaded.');
                return;
            }
            if (framesData.length === 0) {
                showUserMessage('Nothing to export! Add some frames first.');
                return;
            }

            exporting = true;
            exportProg = 0;
            // Update UI to show export progress
            exportGifBtn.textContent = 'Exporting GIF... 0%';
            exportGifBtn.disabled = true;
            showUserMessage('Generating GIF, this might take a moment...');

            // Initialize GIF.js with desired settings
            const gifEncoder = new GIF({
                workers: 2, // Use multiple web workers for faster generation
                quality: 10, // Lower quality = smaller file, faster generation
                delay: 1000 / fps, // Delay between frames based on FPS
                width: projWidth, // Use the project's actual width
                height: projHeight, // Use the project's actual height
                background: '#ffffff' // Set a default background for the GIF
            });

            // Add each frame to the GIF generator
            for (let i = 0; i < framesData.length; i++) {
                try {
                    const frameImage = await loadImage(framesData[i]);

                    // Create a temporary canvas to draw each frame at the correct project dimensions
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = projWidth;
                    tempCanvas.height = projHeight;
                    tempCtx.imageSmoothingEnabled = true; // Ensure smooth lines for export

                    tempCtx.fillStyle = '#ffffff'; // Fill with white background
                    tempCtx.fillRect(0, 0, projWidth, projHeight);
                    tempCtx.drawImage(frameImage, 0, 0, projWidth, projHeight);

                    // Add the frame from the temporary canvas
                    gifEncoder.addFrame(tempCtx, { copy: true, delay: 1000 / fps });
                } catch (error) {
                    console.error(`Problem loading frame ${i} for GIF export:`, error);
                }
            }

            // Listen for progress updates
            gifEncoder.on('progress', function(p) {
                exportProg = Math.floor(p * 100);
                exportGifBtn.textContent = `Exporting GIF... ${exportProg}%`;
            });

            // Handle successful GIF generation
            gifEncoder.on('finished', function(blob) {
                const url = URL.createObjectURL(blob); // Create a URL for the generated GIF
                const dlLink = document.createElement('a');
                dlLink.href = url;
                dlLink.download = 'animation.gif'; // Suggest a filename
                document.body.appendChild(dlLink);
                dlLink.click(); // Programmatically click to trigger download
                document.body.removeChild(dlLink);
                URL.revokeObjectURL(url); // Clean up the object URL

                exporting = false;
                exportProg = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF'; // Reset button text
                exportGifBtn.disabled = false; // Re-enable button
                showUserMessage('GIF exported successfully!');
            });

            // Handle errors during GIF generation
            gifEncoder.on('error', function(error) {
                console.error('GIF generation failed:', error);
                exporting = false;
                exportProg = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showUserMessage('Error exporting GIF.');
            });

            gifEncoder.render(); // Start the GIF rendering process
        }

        /**
         * Generates a creative drawing idea using the Gemini API.
         */
        async function generateFrameIdea() {
            const ideaPromptText = ideaPromptInput.value.trim();
            if (!ideaPromptText) {
                showUserMessage('Please type in a little prompt for the idea generator first!');
                return;
            }

            // Disable UI elements and show loading state
            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden'); // Hide previous output
            ideaText.textContent = ''; // Clear previous idea

            try {
                // Prepare chat history for the API call
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${ideaPromptText}". Keep it concise and focused on visual elements."` }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // This will be provided by the Canvas environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                // Make the API call
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                // Process the API response
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const aiIdeaText = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = aiIdeaText; // Display the idea
                    generatedIdeaOutput.classList.remove('hidden'); // Show the output area
                    showUserMessage('Idea generated successfully!');
                } else {
                    ideaText.textContent = 'Couldn\'t quite generate an idea this time. Please try a different prompt!';
                    generatedIdeaOutput.classList.remove('hidden');
                    showUserMessage('Error generating idea.');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to a network or API error.';
                generatedIdeaOutput.classList.remove('hidden');
                showUserMessage('Error generating idea.');
            } finally {
                // Re-enable UI elements
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }

        /**
         * Updates the visual state (highlighting) of the tool buttons.
         */
        function updateToolButtonStates() {
            // Get all tool buttons
            const allToolButtons = [pencilToolBtn, eraserToolBtn, fillToolBtn, eyedropperToolBtn, panToolBtn];
            
            // Reset all buttons to default gray style
            allToolButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            // Special handling: if any of the brush types are selected, the main pencil tool button should be highlighted
            if (currentTool === 'brush' || currentTool === 'pen' || currentTool === 'pencil') {
                pencilToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                pencilToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
            } else {
                // For other tools (eraser, fill, eyedropper, pan), highlight their specific button
                const currentToolButton = document.getElementById(`${currentTool}Tool`);
                if (currentToolButton) {
                    currentToolButton.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                    currentToolButton.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                }
            }

            // Also update the buttons within the brush selection modal
            const brushModalButtons = [selectBrushToolBtn, selectPenToolBtn, selectPencilToolBtn];
            brushModalButtons.forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-700');
            });

            // Highlight the currently selected brush type in the modal
            if (currentTool === 'brush') {
                selectBrushToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectBrushToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pen') {
                selectPenToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPenToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pencil') {
                selectPencilToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPencilToolBtn.classList.add('bg-blue-500', 'text-white');
            }
        }

        /**
         * Resizes the project canvas and scales existing frames proportionally.
         * @param {number} newWidth - The new width for the project canvas.
         * @param {number} newHeight - The new height for the project canvas.
         */
        async function resizeDrawingBufferAndFrames(newWidth, newHeight) {
            const oldFramesData = [...framesData]; // Take a copy of current frames
            const newFramesData = [];

            const oldProjWidth = projWidth;
            const oldProjHeight = projHeight;

            // Update global project dimensions
            projWidth = newWidth;
            projHeight = newHeight;

            // Resize the offscreen drawing buffer
            bufferCanvas.width = newWidth;
            bufferCanvas.height = newHeight;
            bufferCtx.imageSmoothingEnabled = true; // Ensure smooth scaling

            // Iterate through all old frames and redraw them onto new dimensions
            for (let i = 0; i < oldFramesData.length; i++) {
                const frameData = oldFramesData[i];
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
                tempCtx.imageSmoothingEnabled = true;

                tempCtx.fillStyle = '#ffffff'; // Fill with white background
                tempCtx.fillRect(0, 0, newWidth, newHeight);

                if (frameData && frameData.startsWith('data:image/png;base64,')) {
                    try {
                        const img = await loadImage(frameData);
                        // Calculate offset to center the old drawing within the new canvas
                        const offsetX = (newWidth - oldProjWidth) / 2;
                        const offsetY = (newHeight - oldProjHeight) / 2;

                        // Draw the old frame onto the new size
                        tempCtx.drawImage(img, offsetX, offsetY, oldProjWidth, oldProjHeight);
                    } catch (error) {
                        console.error("Trouble scaling frame during resize:", error);
                    }
                }
                newFramesData.push(tempCanvas.toDataURL('image/png')); // Add scaled frame to new sequence
            }
            
            framesData = newFramesData; // Replace old frames with new scaled ones

            // Load and render the active frame with new dimensions
            await loadFrameIntoBuffer(framesData[currentFrameIdx]);
            renderCanvasDisplay();
            updateTimelineDisplay();
            saveStateToHistory(); // Record this canvas resize for undo/redo
            showUserMessage(`Canvas successfully resized to ${newWidth}x${newHeight}!`);
        }

        /**
         * Initializes the editor when the window loads.
         */
        window.onload = async function() {
            // Load saved project dimensions or use defaults
            projWidth = parseInt(localStorage.getItem('projectWidth')) || 800;
            projHeight = parseInt(localStorage.getItem('projectHeight')) || 600;
            projectWidthInput.value = projWidth;
            projectHeightInput.value = projHeight;

            // Set the offscreen buffer dimensions
            bufferCanvas.width = projWidth;
            bufferCanvas.height = projHeight;

            // Enable image smoothing for both contexts for better drawing quality
            mainCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingEnabled = true;

            // Set initial drawing styles for the offscreen buffer
            bufferCtx.lineCap = 'round';
            bufferCtx.lineJoin = 'round';
            bufferCtx.strokeStyle = brushColor;
            bufferCtx.lineWidth = brushSize;
            
            // Fill the offscreen buffer with white initially
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);

            // Set the display canvas dimensions to match its CSS size
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;


            // If no frames exist, create an initial blank one
            if (framesData.length === 0) {
                const initialCanvasData = bufferCanvas.toDataURL('image/png');
                framesData.push(initialCanvasData);
                saveStateToHistory(); // Save this initial state
            }
            
            // Load the current active frame and render it
            await loadFrameIntoBuffer(framesData[currentFrameIdx]);
            renderCanvasDisplay();
            
            // Update UI elements
            updateTimelineDisplay();
            updateToolButtonStates();
            updateUndoRedoButtons();

            // Set initial button states for playback and export
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            exportGifBtn.disabled = false;

            /* --- Event Listeners Setup --- */

            // Double-click on pencil tool to open brush selection modal
            pencilToolBtn.addEventListener('dblclick', () => {
                brushSelectionModal.classList.remove('hidden');
                updateToolButtonStates(); // Ensure modal buttons are highlighted correctly on open
            });

            // Tool selection click handlers
            eraserToolBtn.addEventListener('click', () => {
                currentTool = 'eraser';
                updateToolButtonStates();
            });
            fillToolBtn.addEventListener('click', () => {
                currentTool = 'fill';
                updateToolButtonStates();
            });
            eyedropperToolBtn.addEventListener('click', () => {
                currentTool = 'eyedropper';
                updateToolButtonStates();
            });
            panToolBtn.addEventListener('click', () => {
                currentTool = 'pan';
                updateToolButtonStates();
            });

            // Palm rejection toggle handler
            stylusOnlyModeToggle.addEventListener('change', (e) => {
                isStylusOnlyModeEnabled = e.target.checked;
            });

            // Brush color input handler
            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                bufferCtx.strokeStyle = brushColor; // Update drawing color
            });

            // Brush size slider handler
            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`; // Update display value
                bufferCtx.lineWidth = brushSize; // Update drawing thickness
            });

            // Drawing/Interaction event listeners for the main canvas
            mainCanvas.addEventListener('mousedown', handleInteractionStart);
            mainCanvas.addEventListener('mousemove', handleInteractionMove);
            mainCanvas.addEventListener('mouseup', handleInteractionEnd);
            mainCanvas.addEventListener('mouseleave', handleInteractionEnd); // Stop drawing if mouse leaves

            // Touch event listeners for mobile/tablet drawing
            mainCanvas.addEventListener('touchstart', handleInteractionStart);
            mainCanvas.addEventListener('touchmove', handleInteractionMove);
            mainCanvas.addEventListener('touchend', handleInteractionEnd);
            mainCanvas.addEventListener('touchcancel', handleInteractionEnd); // Handle interrupted touches

            // Frame management button handlers
            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
            duplicateFrameBtn.addEventListener('click', duplicateFrame);
            clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            // Project save/load/export handlers
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGifAnimation);

            // Animation playback button handlers
            playBtn.addEventListener('click', startAnimationPlayback);
            pauseBtn.addEventListener('click', pauseAnimationPlayback);
            stopBtn.addEventListener('click', stopAnimationPlayback);
            animSpeedInput.addEventListener('input', (e) => {
                fps = parseInt(e.target.value);
                animSpeedValueSpan.textContent = fps; // Update display value
                if (animPlaying) {
                    // If animation is playing, restart it with the new speed
                    pauseAnimationPlayback();
                    startAnimationPlayback();
                }
            });

            // Idea generation modal handlers
            generateIdeaBtn.addEventListener('click', () => {
                ideaModal.classList.remove('hidden');
                generatedIdeaOutput.classList.add('hidden');
                ideaText.textContent = '';
                ideaPromptInput.value = '';
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                ideaModal.classList.add('hidden');
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea);

            // Help modal handlers
            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            // FAQ button links to external help page
            faqBtn.addEventListener('click', () => {
                window.open('https://sathvik-harish.github.io/ToonStart-Help/', '_blank');
            });

            // Palm rejection help modal handlers
            palmRejectionHelpIcon.addEventListener('click', () => {
                palmRejectionHelpModal.classList.remove('hidden');
            });
            closePalmRejectionHelpModalBtn.addEventListener('click', () => {
                palmRejectionHelpModal.classList.add('hidden');
            });

            // Updates modal handlers
            updatesBtn.addEventListener('click', () => {
                updatesModal.classList.remove('hidden');
            });
            closeUpdatesModalBtn.addEventListener('click', () => {
                updatesModal.classList.add('hidden');
            });

            // Customize modal handlers
            customizeBtn.addEventListener('click', () => {
                customizeModal.classList.remove('hidden');
            });
            closeCustomizeModalBtn.addEventListener('click', () => {
                customizeModal.classList.add('hidden');
            });

            // Apply custom canvas size from modal
            applyCanvasSizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(projectWidthInput.value, 10);
                const newHeight = parseInt(projectHeightInput.value, 10);
                // Basic validation for dimensions
                if (isNaN(newWidth) || newWidth < 100 || newWidth > 2000 || isNaN(newHeight) || newHeight < 100 || newHeight > 1500) {
                    showUserMessage('Please enter valid dimensions (Width: 100-2000px, Height: 100-1500px).');
                    return;
                }
                resizeDrawingBufferAndFrames(newWidth, newHeight);
                showUserMessage(`Canvas size set to ${newWidth}x${newHeight}.`);
            });

            // Reset canvas size to default
            resetCanvasSizeBtn.addEventListener('click', () => {
                projectWidthInput.value = 800;
                projectHeightInput.value = 600;
                resizeDrawingBufferAndFrames(800, 600);
                showUserMessage('Canvas size reset to default (800x600).');
            });

            // Undo/Redo button handlers
            undoBtn.addEventListener('click', performUndo);
            redoBtn.addEventListener('click', performRedo);

            // Brush selection modal button handlers
            selectBrushToolBtn.addEventListener('click', () => {
                currentTool = 'brush';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden'); // Hide modal after selection
            });
            selectPenToolBtn.addEventListener('click', () => {
                currentTool = 'pen';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            selectPencilToolBtn.addEventListener('click', () => {
                currentTool = 'pencil';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            closeBrushSelectionModalBtn.addEventListener('click', () => {
                brushSelectionModal.classList.add('hidden');
            });


            // Handle window resizing to make the main canvas responsive
            window.addEventListener('resize', () => {
                // Save current frame data temporarily before resizing
                const currentFrameData = bufferCanvas.toDataURL('image/png');
                
                // Update main canvas dimensions to match its current CSS size
                mainCanvas.width = mainCanvas.offsetWidth;
                mainCanvas.height = mainCanvas.offsetHeight;

                // Re-enable image smoothing (can sometimes be reset on resize)
                mainCtx.imageSmoothingEnabled = true;

                // Load the saved frame data back into the buffer and re-render
                loadFrameIntoBuffer(currentFrameData).then(() => {
                    // Re-apply drawing styles as they might be lost on context resize
                    bufferCtx.lineCap = 'round';
                    bufferCtx.lineJoin = 'round';
                    bufferCtx.strokeStyle = brushColor;
                    bufferCtx.lineWidth = brushSize;
                    
                    renderCanvasDisplay(); // Render the updated display
                });
            });
        };
    </script>
</body>
</html>
