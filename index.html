<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            background-color: #f3f4f6; /* gray-100 */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        #mainContainer {
            display: flex;
            width: 100%;
            max-width: 96rem; /* Equivalent to max-w-7xl from Tailwind, a bit more generous */
            background-color: #ffffff;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            overflow: hidden;
            flex-grow: 1;
            margin: 1rem; /* Adjust margin for overall container */
        }
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #staticToolbox {
            flex-shrink: 0;
            width: 256px;
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #9ca3af #f9fafb;
        }
        #staticToolbox::-webkit-scrollbar {
            width: 8px;
        }
        #staticToolbox::-webkit-scrollbar-track {
            background: #f9fafb;
        }
        #staticToolbox::-webkit-scrollbar-thumb {
            background-color: #9ca3af;
            border-radius: 10px;
            border: 2px solid #f9fafb;
        }
        .toolbox-section {
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }
        .toolbox-section:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        .toolbox-section h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.75rem;
        }
        .toolbox-section label {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            display: block;
        }
        .toolbox-section input[type="range"] {
            width: 100%;
            height: 0.5rem;
            background: #d1d5db; /* Tailwind gray-300 */
            border-radius: 9999px; /* Full rounded */
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        .toolbox-section input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1rem; /* 16px */
            height: 1rem; /* 16px */
            border-radius: 50%;
            background: #2563eb; /* Tailwind blue-700 */
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            margin-top: -0.25rem; /* Center thumb vertically */
        }
        .toolbox-section input[type="range"]::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toolbox-section input[type="color"] {
            width: 100%;
            height: 2.5rem;
            border-radius: 0.5rem;
            border: 2px solid #e2e8f0;
            cursor: pointer;
        }
        .tool-button {
            padding: 0.625rem 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            min-width: 50px;
            background-color: #e2e8f0;
            color: #4b5563;
        }
        .tool-button:hover {
            background-color: #cbd5e0;
        }
        .tool-button.active-tool {
            background-color: #3b82f6;
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .zoom-info {
            font-size: 0.875rem;
            color: #4b5563;
            line-height: 1.5;
        }
        .zoom-info ul {
            padding-left: 1.25rem;
        }
        .zoom-info kbd {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            font-size: 0.875em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            line-height: 1;
            color: #4a5568;
            background-color: #edf2f7;
            border: 1px solid #cbd5e0;
            border-bottom-color: #a0aec0;
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 #a0aec0;
        }
        .help-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            background-color: #9ca3af;
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s;
        }
        .help-icon:hover {
            background-color: #6b7280;
        }
        .frame-button {
            opacity: 0.7; /* Slightly faded when not active */
        }
        .frame-button.dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa;
            background-color: #bfdbfe;
        }
        .frame-button.drag-over {
            border: 2px dashed #3b82f6;
            background-color: #dbeafe;
        }
        .sticker-button {
            font-size: 2.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #e2e8f0;
            transition: background-color 0.2s;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .sticker-button:hover {
            background-color: #cbd5e0;
        }
        .bg-image-button {
            width: 100%;
            height: 60px;
            background-size: cover;
            background-position: center;
            border-radius: 0.5rem;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: border-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .bg-image-button:hover {
            border-color: #3b82f6;
        }
        .bg-image-button.active {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .bg-upload-button {
            background-color: #60a5fa;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
        }
        .bg-upload-button:hover {
            background-color: #3b82f6;
        }
        #installAppInAppBtn {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background-color: #10B981;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            z-index: 100;
            display: none;
        }
        #installAppInAppBtn:hover {
            background-color: #059669;
            transform: translateY(-2px);
        }
        #installAppInAppBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .history-button-small {
            width: 2rem;
            height: 2rem;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.375rem;
            font-size: 1rem;
            line-height: 1;
            background-color: #e2e8f0;
            color: #4b5563;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .history-button-small:hover {
            background-color: #cbd5e0;
        }
        .history-button-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Timeline Scroll Indicators (Shadows) */
        #timelineContainer {
            position: relative;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        #timelineContainer::-webkit-scrollbar {
            display: none;
        }
        #timelineContainer::before,
        #timelineContainer::after {
            content: '';
            position: absolute;
            top: 0;
            height: 100%;
            width: 20px;
            pointer-events: none;
            z-index: 10;
            opacity: var(--left-shadow-opacity, 0);
            transition: opacity 0.3s ease-in-out;
        }
        #timelineContainer::before {
            left: 0;
            box-shadow: inset 20px 0 10px -10px rgba(0, 0, 0, 0.2);
        }
        #timelineContainer::after {
            right: 0;
            box-shadow: inset -20px 0 10px -10px rgba(0, 0, 0, 0.2);
            opacity: var(--right-shadow-opacity, 1);
        }

        /* Modals universal close button */
        .modal-close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6b7280;
            cursor: pointer;
            transition: color 0.2s ease-in-out;
        }
        .modal-close-button:hover {
            color: #ef4444;
        }

        /* Modal Transitions */
        .modal-overlay {
            transition: opacity 0.3s ease-out;
            opacity: 0;
        }
        .modal-overlay.open {
            opacity: 1;
        }
        .modal-content {
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            transform: translateY(20px) scale(0.95);
            opacity: 0;
        }
        .modal-overlay.open .modal-content {
            transform: translateY(0) scale(1);
            opacity: 1;
        }

        /* Active Frame Border Animation */
        .frame-button.active-frame {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
            animation: pulse-border 1.5s infinite alternate ease-in-out;
            opacity: 1; /* Ensure active frame is fully opaque */
        }
        .frame-button:not(.active-frame):hover {
             opacity: 1; /* Show full opacity on hover for non-active frames */
        }

        @keyframes pulse-border {
            from {
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
            }
            to {
                box-shadow: 0 0 0 5px rgba(59, 130, 246, 0.8);
            }
        }

        /* Input Focus States */
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }

        /* Tooltip styles */
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            background-color: #333;
            color: #fff;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            bottom: calc(100% + 5px);
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }

        /* GIF Export Loading Indicator */
        #exportGifLoading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            z-index: 2000;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #exportGifLoading .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Mobile Refined Layout Specific Styles */
        @media (max-width: 767px) {
            #mainContainer {
                flex-direction: column;
                margin: 0.5rem;
            }
            #staticToolbox {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e5e7eb;
                padding: 0.75rem;
                max-height: 50vh; /* Allow toolbox to scroll if content is long */
            }
            .main-content-area {
                flex-grow: 1;
                padding: 0.75rem;
            }
            .playback-controls-area {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }
            .playback-controls-area > div {
                margin-top: 0.5rem;
            }
            .playback-controls-area h3 {
                margin-bottom: 0.5rem;
            }
        }
        /* Styles for refined mobile layout (default for small screens) */
        body.mobile-refined-layout #staticToolbox {
            order: 0; /* Move toolbox to the top */
        }
        body.mobile-refined-layout #mainCanvasArea {
            order: 1; /* Move canvas area below toolbox */
        }
        body.mobile-refined-layout #playbackControls {
            order: 2; /* Move playback controls to the bottom if desired */
        }
        body.mobile-refined-layout .playback-in-toolbox {
            display: flex; /* Show playback controls in toolbox */
            flex-direction: column;
            gap: 0.5rem;
        }
        body.mobile-refined-layout .playback-in-main-area {
            display: none; /* Hide playback controls from main area */
        }
        body.mobile-refined-layout .frame-navigation-in-toolbox {
            display: flex; /* Show frame navigation in toolbox */
            flex-direction: column;
            gap: 0.5rem;
        }
        .playback-in-toolbox, .frame-navigation-in-toolbox {
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body class="h-screen flex flex-col items-center p-4 sm:p-6 md:p-8">

    <div id="messageDisplay" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md transition-opacity duration-500 opacity-0 z-1000 hidden"></div>

    <!-- Undo/Redo buttons & Frame Number moved to top-right -->
    <div class="fixed top-4 right-4 z-50 flex items-center space-x-2">
        <span id="currentFrameNumberDisplay" class="text-gray-700 font-semibold text-sm">F1/1</span>
        <button id="undoBtn" class="history-button-small" data-tooltip="Undo Last Action">‚Ü©Ô∏è</button>
        <button id="redoBtn" class="history-button-small" data-tooltip="Redo Last Action">‚Ü™Ô∏è</button>
    </div>

    <div id="mainContainer" class="flex flex-grow">
        <div id="staticToolbox">
            <div class="flex flex-col space-y-4">
                <div class="toolbox-section">
                    <h2>Tools</h2>
                    <div class="flex flex-wrap gap-1">
                        <button id="pencilTool" class="tool-button active-tool" data-tooltip="Pencil (Double-click for brush styles)">‚úèÔ∏è</button>
                        <button id="eraserTool" class="tool-button" data-tooltip="Eraser">ü©π</button>
                        <button id="fillTool" class="tool-button" data-tooltip="Fill Bucket">ü™£</button>
                        <button id="eyedropperTool" class="tool-button" data-tooltip="Eyedropper">üíâ</button>
                        <button id="panTool" class="tool-button" data-tooltip="Pan Canvas">‚úã</button>
                        <button id="textTool" class="tool-button" data-tooltip="Add Text">üÖ∞Ô∏è</button>
                        <button id="lassoTool" class="tool-button" data-tooltip="Lasso Selection">ü™¢</button>
                        <button id="editTool" class="tool-button" data-tooltip="Move Selection">‚úÇÔ∏è</button>
                        <button id="resizeTool" class="tool-button" data-tooltip="Resize Selection">üìè</button>
                        <button id="stickerTool" class="tool-button" data-tooltip="Add Sticker">‚ú®</button>
                    </div>
                    <div class="mt-4 flex items-center">
                        <input type="checkbox" id="stylusOnlyModeToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500" data-tooltip="Enable Palm Rejection">
                        <label for="stylusOnlyModeToggle" class="text-sm font-medium text-gray-700">Palm Rejection</label>
                        <span id="palmRejectionHelpIcon" class="help-icon" data-tooltip="What is Palm Rejection?">?</span>
                    </div>
                </div>

                <div class="toolbox-section">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#000000" class="rounded-lg border-2 border-gray-300 cursor-pointer" data-tooltip="Select Brush Color">
                </div>

                <div class="toolbox-section">
                    <label for="brushSize">Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" class="bg-gray-300 rounded-lg appearance-none cursor-pointer" data-tooltip="Adjust Brush Size">
                </div>

                <div class="toolbox-section">
                    <label for="opacitySlider">Opacity: <span id="opacityValue" class="font-bold">100%</span></label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100" class="bg-gray-300 rounded-lg appearance-none cursor-pointer" data-tooltip="Adjust Brush Opacity">
                </div>

                <div id="watercolorFlowSection" class="toolbox-section hidden">
                    <label for="flowSlider">Flow: <span id="flowValue" class="font-bold">50%</span></label>
                    <input type="range" id="flowSlider" min="0" max="100" value="50" class="bg-gray-300 rounded-lg appearance-none cursor-pointer" data-tooltip="Adjust Watercolor Flow">
                </div>

                <!-- Playback Controls in Toolbox (for Refined Mobile) -->
                <div id="playbackControlsInToolbox" class="toolbox-section playback-in-toolbox">
                    <h2>Playback</h2>
                    <div class="flex gap-2">
                        <button id="playBtnToolbox" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200" data-tooltip="Play Animation">üé¨</button>
                        <button id="pauseBtnToolbox" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200" data-tooltip="Pause Animation">‚è∏Ô∏è</button>
                        <button id="stopBtnToolbox" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200" data-tooltip="Stop Animation">üõë</button>
                    </div>
                    <div class="flex items-center gap-2 mt-2">
                        <label for="animationSpeedToolbox">FPS:</label>
                        <input type="range" id="animationSpeedToolbox" min="1" max="30" value="10" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer" data-tooltip="Adjust Animation Speed">
                        <span id="animationSpeedValueToolbox" class="font-bold text-gray-800">10</span>
                    </div>
                </div>

                <!-- Frame Navigation in Toolbox (for Refined Mobile) -->
                <div id="frameNavigationInToolbox" class="toolbox-section frame-navigation-in-toolbox">
                    <h2>Frame Navigation</h2>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="goToFirstFrameBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" data-tooltip="Go to First Frame">‚èÆÔ∏è First</button>
                        <button id="goToLastFrameBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" data-tooltip="Go to Last Frame">‚è≠Ô∏è Last</button>
                        <button id="goToPreviousFrameBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" data-tooltip="Go to Previous Frame">‚¨ÖÔ∏è Previous</button>
                        <button id="goToNextFrameBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" data-tooltip="Go to Next Frame">‚û°Ô∏è Next</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Background</h2>
                    <input type="file" id="uploadBackground" accept="image/*" class="hidden">
                    <button id="uploadBackgroundBtn" class="bg-upload-button w-full mb-2" data-tooltip="Upload Background Image">
                        Upload Image
                    </button>
                    <button id="clearBackgroundBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm w-full" data-tooltip="Clear Current Background">
                        Clear Background
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Frames</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="addFrame" class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-blue-600 text-sm" data-tooltip="Add New Frame">Add New</button>
                        <button id="deleteFrame" class="bg-red-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-red-600 text-sm" data-tooltip="Delete Current Frame">Delete</button>
                        <button id="duplicateFrame" class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-green-600 text-sm" data-tooltip="Duplicate Current Frame">Duplicate</button>
                        <button id="clearCurrentFrame" class="bg-orange-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-orange-600 text-sm" data-tooltip="Clear Drawing on Current Frame">Clear Frame</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Project</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="saveProject" class="bg-indigo-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-indigo-600 text-sm" data-tooltip="Save Project to Browser">Save</button>
                        <button id="loadProject" class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-purple-600 text-sm" data-tooltip="Load Project from Browser">Load</button>
                        <button id="exportGif" class="bg-teal-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-teal-600 text-sm" data-tooltip="Export Animation as GIF">
                            üñºÔ∏è Export GIF
                        </button>
                        <button id="customizeBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full" data-tooltip="Customize Canvas Size">
                            ‚öôÔ∏è Customize
                        </button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Ideas</h2>
                    <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-yellow-600 text-sm w-full" data-tooltip="Generate Drawing Idea with AI">
                        ‚ú® Generate Idea
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Info</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="helpBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full" data-tooltip="View Help Tips">
                            ‚ùì Help
                        </button>
                        <button id="faqBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full" data-tooltip="Frequently Asked Questions">
                            ‚ùì FAQ
                        </button>
                        <button id="updatesBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full" data-tooltip="View Latest Updates">
                            ‚ú® Updates
                        </button>
                    </div>
                </div>

                <!-- Download App Button (for Android Mobile Refined Layout) -->
                <div id="downloadAppContainer" class="toolbox-section hidden">
                    <button id="downloadAppBtnLeftbar" class="bg-green-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200 w-full" data-tooltip="Download ToonStart App">
                        Download App
                    </button>
                </div>

            </div>
        </div>

        <div id="mainCanvasArea" class="flex flex-col relative flex-grow p-4 sm:p-6">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <!-- Playback Controls in Main Area (default for desktop/tablet) -->
            <div id="playbackControlsMain" class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4 playback-in-main-area">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200" data-tooltip="Play Animation">
                        üé¨
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200" data-tooltip="Pause Animation">
                        ‚è∏Ô∏è
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200" data-tooltip="Stop Animation">
                        üõë
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer" data-tooltip="Adjust Animation Speed">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner max-h-24">
                <div id="timelineContainer" class="overflow-x-auto pb-2">
                    <div id="timeline" class="flex flex-nowrap space-x-2 items-center">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- GIF Export Loading Indicator -->
    <div id="exportGifLoading" class="hidden">
        <div class="spinner"></div>
        <p>Generating GIF...</p>
        <span id="exportProgressText">0%</span>
    </div>

    <div id="mobileWarningModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm text-center relative modal-content">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">üëã You are on Mobile!</h3>
            <p class="text-gray-700 mb-6">
                For a better experience, we recommend switching to a tablet or desktop.
            </p>
            <div class="flex flex-col space-y-4">
                <button id="continueMobileBtn" class="bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Continue on Mobile
                </button>
                <button id="refineForMobileBtn" class="bg-purple-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-purple-700 transition-colors duration-200 relative">
                    Refine for Mobile
                    <span id="refineHelpIcon" class="help-icon absolute -right-6 top-1/2 -translate-y-1/2" data-tooltip="What does 'Refine for Mobile' do?">?</span>
                </button>
                <button id="quitAppBtn" class="bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Quit App
                </button>
            </div>
        </div>
    </div>

    <div id="refineHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm relative modal-content">
            <button class="modal-close-button" id="closeRefineHelpModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">üì± Refine for Mobile</h3>
            <p class="text-gray-700 mb-4">
                This option optimizes the interface for smaller screens by moving playback and advanced navigation controls into a dedicated sidebar, providing a more streamlined experience on mobile devices.
            </p>
            <button id="closeRefineHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col relative modal-content" style="max-height: 90vh;">
            <button class="modal-close-button" id="closeIdeaModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4 flex-shrink-0">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 flex-shrink-0">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 flex-shrink-0">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden flex-grow overflow-y-auto">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col relative modal-content" style="max-height: 90vh;">
            <button class="modal-close-button" id="closeHelpModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ùì Help & View Tips</h3>
            <div class="flex-grow overflow-y-auto pr-2 py-2">
                <p class="zoom-info mb-4">
                    If parts of the editor content appear cut off or you want to see more, you can adjust your browser's zoom level.
                </p>
                <ul class="zoom-info list-disc list-inside space-y-2 pl-4">
                    <li>
                        <span class="font-semibold">Browser Zoom Out:</span>
                        <br>
                        <kbd>Cmd</kbd> + <kbd>-</kbd> (Mac)
                        <br>
                        <kbd>Ctrl</kbd> + <kbd>-</kbd> (Windows)
                    </li>
                    <li>
                        <span class="font-semibold">Browser Reset Zoom to 100%:</span>
                        <br>
                        <kbd>Cmd</kbd> + <kbd>0</kbd> (Mac)
                        <br>
                        <kbd>Ctrl</kbd> + <kbd>0</kbd> (Windows)
                    </li>
                    <li>
                        <span class="font-semibold">If browser zooming in and out doesn't work as expected, try setting your browser zoom to 150% and then refresh the page. This can sometimes resolve layout issues and bring the timeline back into view.</span>
                    </li>
                    <li>
                        <span class="font-semibold">Canvas Pan:</span> Click and drag with the "‚úã Hand" tool to pan.
                    </li>
                    <li>
                        <span class="font-semibold">Line Smoothness:</span> If lines appear jagged or pixelated (especially at smaller brush sizes or high canvas resolutions), ensure your browser's "image smoothing" is enabled. This feature is enabled by default in ToonStart to improve line quality.
                    </li>
                    <li>
                        <span class="font-semibold">Brush Selection:</span> Double-click the 'Pencil' tool to open a menu and choose between 'Brush', 'Pen', 'Pencil', and 'Watercolor' drawing styles. Each style offers a distinct drawing feel.
                    </li>
                    <li>
                        <span class="font-semibold">Opacity Control:</span> Use the 'Opacity' slider in the toolbox to adjust the transparency of your brush strokes.
                    </li>
                    <li>
                        <span class="font-semibold">Watercolor Flow:</span> When the 'Watercolor' tool is selected, a 'Flow' slider will appear. This controls how much the color spreads out and and accumulates with each stroke, mimicking real watercolor effects.
                    </li>
                    <li>
                        <span class="font-semibold">Text Tool:</span> Select the 'Text' tool (üÖ∞Ô∏è) to add text to your canvas. A modal will appear where you can type your text, choose font family, size, and style (bold/italic). Click 'Place Text' and then click on the canvas to position your text.
                    </li>
                    <li>
                        <span class="font-semibold">Lasso Tool (ü™¢):</span> Draw a freehand selection. Once the selection is made, it will be cut from the canvas. You must then use the 'Edit' or 'Resize' tools to manipulate it.
                    </li>
                    <li>
                        <span class="font-semibold">Edit Tool (‚úÇÔ∏è):</span> After using the Lasso tool, select the 'Edit' tool. Click and drag on the canvas to move your lassoed selection. Click again to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Resize Tool (üìè):</span> After using the Lasso tool, select the 'Resize' tool. A modal will appear allowing you to input new dimensions for your lassoed selection. After applying, click on the canvas to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Sticker Tool (‚ú®):</span> Select the 'Sticker' tool to open a menu of emojis. Choose an emoji and then click on the canvas to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Backgrounds:</span> Add static background images to your frames. These backgrounds will not move with the pan or lasso tools.
                        <ul>
                            <li><strong>Upload Image:</strong> Use your own image file.</li>
                            <li><strong>Clear Background:</strong> Remove the current background image.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-semibold">Edit (For text only):</span> This option is currently a placeholder for a future enhancement, as text is rasterized upon placement. This means once text is placed, it becomes part of the image and cannot be directly edited as text again.
                    </li>
                </ul>
            </div>
            <button id="closeHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close

            </button>
        </div>
    </div>

    <div id="palmRejectionHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md relative modal-content">
            <button class="modal-close-button" id="closePalmRejectionHelpModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="2xl font-bold text-gray-800 mb-4">üñêÔ∏è What is Palm Rejection?</h3>
            <p class="text-gray-700 mb-4">
                When "Palm Rejection" is enabled, the drawing canvas will <strong>only respond to input from a digital pen or stylus</strong>.
            </p>
            <p class="text-gray-700 mb-4">
                Touches from your fingers or palm will be ignored, allowing you to rest your hand on the screen while drawing without making accidental marks.
            </p>
            <p class="text-gray-700 text-sm italic">
                Note: This feature relies on your device and browser accurately reporting stylus input. Passive styluses (rubber-tip) may still be detected as finger touches.
            </p>
            <button id="closePalmRejectionHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="updatesModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col relative modal-content" style="max-height: 90vh;">
            <button class="modal-close-button" id="closeUpdatesModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® ToonStart Updates</h3>
            <div id="updatesContent" class="text-gray-700 space-y-4 flex-grow overflow-y-auto pr-2 py-2">
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">June 16, 2025 - Critical Fix & Mobile Layout</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Critical Fix:</strong> Re-generated the entire application to resolve "black screen" and closing issues.</li>
                        <li><strong>Mobile Warning:</strong> Added an initial warning for mobile users recommending tablet/desktop.
                            <ul>
                                <li>Options: "Continue on Mobile", "Refine for Mobile", "Quit App".</li>
                            </ul>
                        </li>
                        <li><strong>Refined Mobile Layout:</strong>
                            <ul>
                                <li>Playback options moved to the Leftbar.</li>
                                <li>New frame navigation options added to Leftbar: "Go to First/Last/Previous/Next Frame".</li>
                                <li>Current frame number display added next to Undo/Redo buttons (e.g., "F1/10").</li>
                                <li>"Refine for Mobile" option explanation via a '?' help icon.</li>
                                <li>"Download App" button added to Leftbar (Android only, for users who choose to "Continue on Mobile").</li>
                                <li>This refined layout can also be enabled by desktop users via the Customize tab.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">June 16, 2025 - Upcoming UI Fixes (Phase 2)</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Refined Modal Transitions:</strong> Implementing smoother fade-in/fade-out and slight scale animations for all modals.</li>
                        <li><strong>Highlight Current Frame with Border Animation:</strong> The active frame in the timeline will now have a subtle pulsating border or more prominent highlight.</li>
                        <li><strong>Improved Input Field Focus States:</strong> Providing clearer visual indication when an input field is in focus (e.g., brush size, opacity, text input).</li>
                        <li><strong>Tooltips for Buttons:</strong> Adding simple tooltips for all action buttons (tools, frames, project actions) on hover to clarify their function.</li>
                        <li><strong>Loading Indicator for GIF Export:</strong> Displaying a more visually engaging loading indicator or progress bar specifically for the GIF export process.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">June 15, 2025 - Upcoming UI Fixes (Phase 1)</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Toolbox Scrollbar Styling:</strong> Implementing a more subtle and visually integrated vertical scrollbar in the toolbox.</li>
                        <li><strong>Timeline Scroll Indicators:</strong> Adding visual cues (e.g., subtle shadows) to the horizontal timeline to indicate scrollability when content overflows.</li>
                        <li><strong>Consistent Tool Button States:</strong> Refining hover and active states for all tool buttons for clearer visual feedback and consistency.</li>
                        <li><strong>Universal Modal Close Buttons:</strong> Adding a consistent "‚úñÔ∏è" close button in the top-right corner of all modals for improved accessibility.</li>
                        <li><strong>Improved Modal Content Padding:</strong> Adjusting padding within the content areas of help and update modals for better readability and a less cramped appearance.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">June 15, 2025 - UI Refinements & Mobile Gestures</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Cleaner UI:</strong> Removed the "ToonStart Animation Editor" text from the main display for a cleaner look.</li>
                        <li><strong>Mobile Undo/Redo Gestures:</strong>
                            <ul>
                                <li>Double-tap on the canvas to undo.</li>
                                <li>Triple-tap on the canvas to redo.</li>
                            </ul>
                        </li>
                        <li><strong>Compact Undo/Redo Buttons:</strong> Moved Undo (‚Ü©Ô∏è) and Redo (‚Ü™Ô∏è) buttons to the top-right corner, making them small and square using emoji icons to save space.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 31, 2025 - Backgrounds & No Layers</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Backgrounds:</strong> Added a new "Background" section in the toolbox.
                            <ul>
                                <li>Upload custom background images.</li>
                                <li>Clear the current background.</li>
                                <li>Backgrounds are fixed and do not move with the pan or lasso tools.</li>
                                <li>Background images automatically fit to the canvas size.</li>
                            </ul>
                        </li>
                        <li><strong>Layers Removed:</strong> The layer system has been removed for a simpler drawing experience.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 31, 2025 - Layers & Refined Stickers</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Layers:</strong> Added a full layer system! Each frame can now have multiple layers.
                            <ul>
                                <li>New "Layers" section in the toolbox with controls for adding, deleting, duplicating, clearing, and reordering layers.</li>
                                <li>Layer opacity slider for individual layers.</li>
                                <li>Drawing tools, text, and stickers now operate on the active layer.</li>
                            </ul>
                        </li>
                        <li><strong>Sticker Refinement:</strong> Curated the sticker collection to feature approximately 100 of the most commonly used and diverse emojis, ensuring no repeats.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Code Readability & Stickers</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Code Comments:</strong> Added extensive comments throughout the JavaScript code to explain logic, variables, and functions, improving readability and maintainability.</li>
                        <li><strong>HTML Comments:</strong> Added basic comments to HTML sections for better structure understanding.</li>
                        <li><strong>Sticker Tool (‚ú®):</strong> A new tool to add fun emoji stickers to your animation frames.</li>
                        <li><strong>Lasso/Edit/Resize Fixes:</strong> Resolved issues with object duplication, improved mouse alignment during moves, and ensured accurate display of pixel dimensions in the resize modal.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Separate Edit/Resize Tools for Lasso</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool (ü™¢):</strong> Now solely for drawing selections. Moving and resizing are handled by new dedicated tools.</li>
                        <li><strong>New Edit Tool (‚úÇÔ∏è):</strong> Move lassoed selections.</li>
                        <li><strong>New Resize Tool (üìè):</strong> Resize lassoed selections with precise dimensions.</li>
                        <li><strong>Help & Updates:</strong> Updated to reflect the new tool functionalities.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Enhanced Lasso Tool</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool Placement:</strong> Lassoed selections now require an explicit click to be placed on the canvas, giving you more control.</li>
                        <li><strong>Lasso Double-Click Options:</strong> Double-clicking the lasso tool now opens a menu with 'Move', 'Resize', and 'Edit (For text only)' options.</li>
                        <li><strong>Lasso Resize:</strong> You can now resize your lassoed selection by inputting new dimensions.</li>
                        <li><strong>Lasso Text Edit (Future):</strong> The 'Edit (For text only)' option is currently a placeholder for a future enhancement, as text is rasterized upon placement.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Movement Fix</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool:</strong> Corrected the behavior of the lasso tool so that selected areas now move precisely with the mouse/stylus and are placed accurately.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Fix & Fixed Help Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool Fix:</strong> Resolved issues where the lasso tool would clear the entire canvas. Now, only the selected area is cut and moved.</li>
                        <li><strong>Fixed Help Button:</strong> The "Close" button in the Help modal now remains fixed at the bottom, even when the content scrolls.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Tool Added</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool:</strong> A new tool (ü™¢) has been added, allowing you to draw freehand selections, cut them from the canvas, and then move and place them elsewhere.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Text Tool, Refined Watercolor, No Comments</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Text Tool:</strong> Added a new tool to place customizable text on the canvas, with options for font family, size, bold, and italic.</li>
                        <li><strong>Watercolor Flow Refinement:</strong> The 'Watercolor' tool now features an improved slow-spreading effect for more natural color accumulation.</li>
                        <li><strong>No Comments:</strong> All comments have been removed from the code for a cleaner, more human-written aesthetic.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - No Comments & Draggable Frames</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Comments Removed:</strong> All code comments (`/* */` and `//`) have been removed for a cleaner, more human-written aesthetic.</li>
                        <li><strong>Draggable Frames:</strong> You can now drag and drop frames in the timeline to easily reorder them.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Refined Watercolor Flow & Comment Style</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Watercolor Flow:</strong> Enhanced the 'Watercolor' tool to provide a more natural, spreading effect with gradual color accumulation.</li>
                        <li><strong>Comment Style:</strong> Replaced all block comments (`/* ... */`) with single-line comments (`// ...`) for a more human-written code aesthetic.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Opacity & Watercolor Flow</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Opacity Slider:</strong> Added a new slider to control the general transparency of all drawing tools.</li>
                        <li><strong>Watercolor Tool:</strong> Introduced a new 'Watercolor' brush type in the double-click menu.</li>
                        <li><strong>Flow Slider:</strong> A 'Flow' slider now appears when the 'Watercolor' tool is active, allowing for natural color accumulation in strokes.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Fixed Modal Scrolling</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Modal Scrolling:</strong> The "Generate Idea" and "Updates" modals now correctly handle long content by allowing the content to scroll while keeping the "Close" button fixed at the bottom.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Brush Selection Persistence Fix</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Selection:</strong> Fixed an issue where the selected brush type (Brush, Pen, or Pencil) wasn't consistently active after choosing it from the double-click menu. Your brush choice will now stick!</li>
                        <li><strong>Pencil Tool Behavior:</strong> The main 'Pencil' tool button in the sidebar will now *only* open the brush selection menu on double-click, preventing accidental changes to your brush type.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Improved Brush Selection Highlight</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Clearer Selection:</strong> When you open the brush selection menu, the currently active brush style (Brush, Pen, or Pencil) will now be clearly highlighted, making it easier to see your current choice.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Enhanced Brush Styles & Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Behavior:</strong> The 'Brush', 'Pen', and 'Pencil' tools now have distinct drawing feels:
                            <ul>
                                <li>'Pencil' offers a light, sketchy line.</li>
                                <li>'Pen' draws a solid, straightforward line.</li>
                                <li>'Brush' provides a slightly softer, more "painterly" stroke.</li>
                            </ul>
                        </li>
                        <li><strong>Tool Selection Reliability:</strong> Fixed an issue where selecting a brush type from the double-click menu wasn't consistently applying the chosen tool.</li>
                        <li><strong>Pencil Tool Feedback:</strong> The main 'Pencil' tool button will now stay highlighted whenever 'Brush', 'Pen', or 'Pencil' is the active drawing style.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Refined Brush Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Streamlined Tools:</strong> The main toolbox now features only the 'Pencil' tool for drawing.</li>
                        <li><strong>Intuitive Brush Menu:</strong> Double-clicking the 'Pencil' tool will bring up a menu, allowing you to select between 'Brush', 'Pen', and 'Pencil' drawing styles.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - New Brush Tools</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>New Brushes:</strong> Added 'Pen' and 'Pencil' tools for more drawing variety.</li>
                        <li><strong>Brush Selection Menu:</strong> Double-clicking the 'Pencil' tool now brings up a menu to easily switch between 'Brush', 'Pen', and 'Pencil' modes.</li>
                        <li><strong>Pencil Feel:</strong> The 'Pencil' tool now draws with a lighter, sketchier appearance.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Updated GIF Export Logic</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>GIF Export:</strong> Updated the GIF export logic to explicitly draw each frame onto a temporary canvas before adding it to the GIF, ensuring consistent output.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Improved Drawing Smoothness</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Shape & Diagonal Lines:</strong> Fixed issues where circular brush strokes would appear square or jagged, especially on diagonals or after canvas resizing. Image smoothing is now explicitly enabled for both drawing and display contexts to ensure smoother line rendering.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Added FAQ Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>FAQ Button:</strong> Added a new "FAQ" button in the "Info" section linking to the help page.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Fixed Canvas Resizing</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Canvas Resizing:</strong> Lines and existing drawings now maintain their original thickness when resizing the project canvas.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Zoom Feature Removed</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature Removed:</strong> Zoom functionality has been removed .</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 29, 2025 - Zoom Feature & UI Polish</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature:</strong> Added zoom functionality via scroll wheel and a dedicated slider in the new "Zoom & Pan" section.</li>
                        <li><strong>"Zoom & Pan" Section:</strong> New toolbox section for zoom and pan controls.</li>
                        <li><strong>Timeline Text Removed:</strong> "Timeline" heading removed as requested.</li>
                        <li><strong>Help Text Updated:</strong> Included instructions for the new zoom feature.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 28, 2025 - Canvas Resizing & UI Refinements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Canvas Resizing:</strong> Added ability to change project width and height in Customize modal. Existing frames scale proportionally.</li>
                        <li><strong>Customize Button Relocated:</b> Moved to the "Project" section for better organization.</li>
                        <li><strong>Onion Skinning Removed:</strong> Feature removed .</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Layout & Drawing Stability</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Brush Offset:</strong> Drawing now consistently aligns with cursor regardless of timeline changes.</li>
                        <li><strong>Timeline Horizontal Scroll:</strong> Timeline now scrolls horizontally when many frames are added, preventing vertical layout shifts.</li>
                        <li><strong>Improved GIF Export:</strong> More reliable GIF generation due to consistent internal canvas dimensions.</li>
                        <li>**Help Text Updated:** Added a new tip regarding browser zoom and refreshing.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 25, 2025 - Critical Bug Fixes & Improvements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Drawing:</strong> Drawing tools now work correctly and responsively.</li>
                        <li><strong>Fixed Undo/Redo:</strong> History system is fully functional.</li>
                        <li><strong>Fixed Generate Idea:</strong> AI idea generator now works as expected.</li>
                        <li><strong>Fixed Updates Button:</strong> The updates modal now opens correctly.</li>
                        <li><strong>Restored Message Display:</strong> Temporary on-screen messages are back for user feedback.</li>
                        <li><strong>Fixed Fill Tool:</strong> Now accurately fills areas regardless of pan.</li>
                        <li><strong>Fixed Eyedropper Tool:</strong> Accurately picks colors from the canvas.</li>
                        <li>**Enhanced Responsiveness:** Significant performance improvements for drawing and canvas interactions.</li>
                        <li>**Removed Zoom Feature:** Canvas no longer supports zoom, focusing on direct drawing.</li>
                        <li>**Pipette Icon Update:** Changed to üíâ emoji.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 23, 2025 - Initial Feature Enhancements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Undo/Redo History:</strong> Easily correct mistakes with multiple steps.</li>
                        <li><strong>Pan Tool:</strong> Navigate the canvas for detailed work or overview.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 22, 2025 - Basic Drawing & Animation</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Basic Drawing Tools:</strong> Brush, Eraser, Fill.</li>
                        <li><strong>Frame Management:</strong> Add, delete, duplicate, clear frames.</li>
                        <li><strong>Animation Playback:</strong> Play, pause, stop animation with adjustable speed.</li>
                        <li><strong>Project Save/Load:</strong> Save and load your animation projects locally.</li>
                        <li><strong>GIF Export:</strong> Export your animation as a GIF.</li>
                        <li><strong>AI Idea Generator:</strong> Get creative ideas for your frames.</li>
                        <li><strong>Touch Support:</strong> Basic drawing on touch devices like iPad.</li>
                        <li><strong>Palm Rejection:</strong> Option to enable stylus-only drawing.</li>
                    </ul>
                </div>
            </div>
            <button id="closeUpdatesModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="customizeModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md relative modal-content">
            <button class="modal-close-button" id="closeCustomizeModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚öôÔ∏è Customize Editor</h3>
            <div class="space-y-4">
                <div>
                    <label for="projectWidth" class="block text-sm font-medium text-gray-700">Project Width (px):</label>
                    <input type="number" id="projectWidth" min="100" max="2000" value="800"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="projectHeight" class="block text-sm font-medium text-gray-700">Project Height (px):</label>
                    <input type="number" id="projectHeight" min="100" max="1500" value="600"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyCanvasSizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Canvas Size
                </button>
                <button id="resetCanvasSizeBtn" class="w-full bg-gray-300 text-gray-800 px-4 py-2 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Reset to Default (800x600)
                </button>
                <div class="border-t border-gray-200 pt-4 mt-4">
                    <div class="flex items-center">
                        <input type="checkbox" id="enableRefinedMobileLayoutToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="enableRefinedMobileLayoutToggle" class="text-sm font-medium text-gray-700">Enable Refined Mobile Layout</label>
                    </div>
                </div>
            </div>
            <button id="closeCustomizeModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="brushSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-xs relative modal-content">
            <button class="modal-close-button" id="closeBrushSelectionModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="text-xl font-bold text-gray-800 mb-4 text-center">Choose Brush</h3>
            <div class="flex flex-col space-y-3">
                <button id="selectBrushTool" class="bg-blue-500 text-white px-4 py-2 rounded-lg shadow-sm hover:bg-blue-600">Brush</button>
                <button id="selectPenTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pen</button>
                <button id="selectPencilTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pencil</button>
                <button id="selectWatercolorTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Watercolor</button>
            </div>
            <button id="closeBrushSelectionModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="textToolModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col relative modal-content">
            <button class="modal-close-button" id="cancelTextBtnTop" data-tooltip="Cancel">‚úñÔ∏è</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">üÖ∞Ô∏è Add Text</h3>
            <textarea id="textInput" class="w-full p-3 border border-gray-300 rounded-lg mb-4 h-24 resize-y focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Type your text here..."></textarea>
            
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <div class="flex-1">
                    <label for="fontFamilySelect" class="block text-sm font-medium text-gray-700">Font Family:</label>
                    <select id="fontFamilySelect" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="Inter, sans-serif">Inter</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Courier New, monospace">Courier New</option>
                        <option value="Comic Sans MS, cursive">Comic Sans MS</option>
                    </select>
                </div>
                <div class="flex-1">
                    <label for="fontSizeInput" class="block text-sm font-medium text-gray-700">Font Size (px):</label>
                    <input type="number" id="fontSizeInput" min="10" max="200" value="30" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>

            <div class="flex gap-4 mb-4">
                <div class="flex items-center">
                    <input type="checkbox" id="fontBoldToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                    <label for="fontBoldToggle" class="text-sm font-medium text-gray-700">Bold</label>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="fontItalicToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                    <label for="fontItalicToggle" class="text-sm font-medium text-gray-700">Italic</label>
                </div>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Text Preview:</label>
                <canvas id="textPreviewCanvas" class="w-full border border-gray-300 rounded-lg bg-gray-50" width="400" height="100"></canvas>
            </div>

            <div class="flex gap-4 mt-auto">
                <button id="placeTextBtn" class="flex-1 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Place Text
                </button>
                <button id="cancelTextBtn" class="flex-1 bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <div id="resizeSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md relative modal-content">
            <button class="modal-close-button" id="cancelResizeBtnTop" data-tooltip="Cancel">‚úñÔ∏è</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Resize Selection</h3>
            <div class="space-y-4">
                <div>
                    <label for="resizeWidth" class="block text-sm font-medium text-gray-700">New Width (px):</label>
                    <input type="number" id="resizeWidth" min="1" value="100"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="resizeHeight" class="block text-sm font-medium text-gray-700">New Height (px):</label>
                    <input type="number" id="resizeHeight" min="1" value="100"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyResizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Resize
                </button>
            </div>
            <button id="cancelResizeBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Cancel
            </button>
        </div>
    </div>

    <div id="stickerSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 modal-overlay hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-lg flex flex-col relative modal-content">
            <button class="modal-close-button" id="closeStickerSelectionModalBtnTop" data-tooltip="Close">‚úñÔ∏è</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Choose a Sticker</h3>
            <div id="stickerContainer" class="grid grid-cols-5 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2 overflow-y-auto max-h-96 pb-4">
            </div>
            <button id="closeStickerSelectionModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <!-- New floating button for in-app install -->
    <button id="installAppInAppBtn" class="hidden" data-tooltip="Install ToonStart App">
        Install ToonStart App
    </button>

    <script>
        const mainCanvas = document.getElementById('drawingCanvas');
        const mainCtx = mainCanvas.getContext('2d');

        const bufferCanvas = document.createElement('canvas');
        const bufferCtx = bufferCanvas.getContext('2d');

        let projWidth = 800;
        let projHeight = 600;

        const msgDisplay = document.getElementById('messageDisplay');
        const currentFrameNumberDisplay = document.getElementById('currentFrameNumberDisplay');


        // Tool Buttons
        const pencilToolBtn = document.getElementById('pencilTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const eyedropperToolBtn = document.getElementById('eyedropperTool');
        const panToolBtn = document.getElementById('panTool');
        const textToolBtn = document.getElementById('textTool');
        const lassoToolBtn = document.getElementById('lassoTool');
        const editToolBtn = document.getElementById('editTool');
        const resizeToolBtn = document.getElementById('resizeTool');
        const stickerToolBtn = document.getElementById('stickerTool');

        // Brush/Color/Opacity
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValueSpan = document.getElementById('opacityValue');
        const watercolorFlowSection = document.getElementById('watercolorFlowSection');
        const flowSlider = document.getElementById('flowSlider');
        const flowValueSpan = document.getElementById('flowValue');

        // Stylus Mode
        const stylusOnlyModeToggle = document.getElementById('stylusOnlyModeToggle');
        let isStylusOnlyModeEnabled = false;

        // Background
        const uploadBackgroundInput = document.getElementById('uploadBackground');
        const uploadBackgroundBtn = document.getElementById('uploadBackgroundBtn');
        const clearBackgroundBtn = document.getElementById('clearBackgroundBtn');

        // Frame Management
        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        // Project Actions
        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');
        const exportGifLoading = document.getElementById('exportGifLoading');
        const exportProgressText = document.getElementById('exportProgressText');


        // Playback Controls (Main Area & Toolbox)
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animSpeedInput = document.getElementById('animationSpeed');
        const animSpeedValueSpan = document.getElementById('animationSpeedValue');

        const playBtnToolbox = document.getElementById('playBtnToolbox');
        const pauseBtnToolbox = document.getElementById('pauseBtnToolbox');
        const stopBtnToolbox = document.getElementById('stopBtnToolbox');
        const animSpeedInputToolbox = document.getElementById('animationSpeedToolbox');
        const animSpeedValueToolboxSpan = document.getElementById('animationSpeedValueToolbox');


        // Timeline
        const timelineDiv = document.getElementById('timeline');
        const timelineContainer = document.getElementById('timelineContainer');

        // Frame Navigation (for Refined Mobile)
        const goToFirstFrameBtn = document.getElementById('goToFirstFrameBtn');
        const goToLastFrameBtn = document.getElementById('goToLastFrameBtn');
        const goToPreviousFrameBtn = document.getElementById('goToPreviousFrameBtn');
        const goToNextFrameBtn = document.getElementById('goToNextFrameBtn');


        // AI Idea Generator
        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');
        const closeIdeaModalBtnTop = document.getElementById('closeIdeaModalBtnTop');


        // Help & Info Modals
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
        const closeHelpModalBtnTop = document.getElementById('closeHelpModalBtnTop');

        const faqBtn = document.getElementById('faqBtn');
        const updatesBtn = document.getElementById('updatesBtn');
        const updatesModal = document.getElementById('updatesModal');
        const closeUpdatesModalBtn = document.getElementById('closeUpdatesModalBtn');
        const closeUpdatesModalBtnTop = document.getElementById('closeUpdatesModalBtnTop');

        const palmRejectionHelpIcon = document.getElementById('palmRejectionHelpIcon');
        const palmRejectionHelpModal = document.getElementById('palmRejectionHelpModal');
        const closePalmRejectionHelpModalBtn = document.getElementById('closePalmRejectionHelpModalBtn');
        const closePalmRejectionHelpModalBtnTop = document.getElementById('closePalmRejectionHelpModalBtnTop');


        // Customize Modal
        const customizeBtn = document.getElementById('customizeBtn');
        const customizeModal = document.getElementById('customizeModal');
        const closeCustomizeModalBtn = document.getElementById('closeCustomizeModalBtn');
        const closeCustomizeModalBtnTop = document.getElementById('closeCustomizeModalBtnTop');

        const projectWidthInput = document.getElementById('projectWidth');
        const projectHeightInput = document.getElementById('projectHeight');
        const applyCanvasSizeBtn = document.getElementById('applyCanvasSizeBtn');
        const resetCanvasSizeBtn = document.getElementById('resetCanvasSizeBtn');
        const enableRefinedMobileLayoutToggle = document.getElementById('enableRefinedMobileLayoutToggle');


        // Brush Selection Modal
        const brushSelectionModal = document.getElementById('brushSelectionModal');
        const selectBrushToolBtn = document.getElementById('selectBrushTool');
        const selectPenToolBtn = document.getElementById('selectPenTool');
        const selectPencilToolBtn = document.getElementById('selectPencilTool');
        const selectWatercolorToolBtn = document.getElementById('selectWatercolorTool');
        const closeBrushSelectionModalBtn = document.getElementById('closeBrushSelectionModalBtn');
        const closeBrushSelectionModalBtnTop = document.getElementById('closeBrushSelectionModalBtnTop');


        // Text Tool Modal
        const textToolModal = document.getElementById('textToolModal');
        const textInput = document.getElementById('textInput');
        const fontFamilySelect = document.getElementById('fontFamilySelect');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const fontBoldToggle = document.getElementById('fontBoldToggle');
        const fontItalicToggle = document.getElementById('fontItalicToggle');
        const textPreviewCanvas = document.getElementById('textPreviewCanvas');
        const textPreviewCtx = textPreviewCanvas.getContext('2d');
        const placeTextBtn = document.getElementById('placeTextBtn');
        const cancelTextBtn = document.getElementById('cancelTextBtn');
        const cancelTextBtnTop = document.getElementById('cancelTextBtnTop');


        // Resize Selection Modal
        const resizeSelectionModal = document.getElementById('resizeSelectionModal');
        const resizeWidthInput = document.getElementById('resizeWidth');
        const resizeHeightInput = document.getElementById('resizeHeight');
        const applyResizeBtn = document.getElementById('applyResizeBtn');
        const cancelResizeBtn = document.getElementById('cancelResizeBtn');
        const cancelResizeBtnTop = document.getElementById('cancelResizeBtnTop');


        // Sticker Selection Modal
        const stickerSelectionModal = document.getElementById('stickerSelectionModal');
        const stickerContainer = document.getElementById('stickerContainer');
        const closeStickerSelectionModalBtn = document.getElementById('closeStickerSelectionModalBtn');
        const closeStickerSelectionModalBtnTop = document.getElementById('closeStickerSelectionModalBtnTop');


        // Mobile App Prompt elements
        const mobileWarningModal = document.getElementById('mobileWarningModal');
        const continueMobileBtn = document.getElementById('continueMobileBtn');
        const refineForMobileBtn = document.getElementById('refineForMobileBtn');
        const quitAppBtn = document.getElementById('quitAppBtn');
        const refineHelpIcon = document.getElementById('refineHelpIcon');
        const refineHelpModal = document.getElementById('refineHelpModal');
        const closeRefineHelpModalBtn = document.getElementById('closeRefineHelpModalBtn');
        const closeRefineHelpModalBtnTop = document.getElementById('closeRefineHelpModalBtnTop');
        const downloadAppBtnLeftbar = document.getElementById('downloadAppBtnLeftbar');
        const downloadAppContainer = document.getElementById('downloadAppContainer');


        // New in-app install button
        const installAppInAppBtn = document.getElementById('installAppInAppBtn');

        // Undo/Redo buttons (now global, not in toolbox)
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');


        let drawingActive = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let currentOpacity = 100;
        let watercolorFlow = 50;
        let currentTool = 'brush'; // Default tool

        let framesData = [];
        let currentFrameIdx = 0;

        let animPlaying = false;
        let fps = 10;
        let animInterval = null;

        let exporting = false;
        let exportProg = 0;

        let historyStates = [];
        let historyPtr = -1;
        const MAX_HISTORY_STATES = 50;

        let panOffset = { x: 0, y: 0 };
        let panningActive = false;
        let lastPanPt = { x: 0, y: 0 };

        const imageCache = new Map();

        let draggedFrameIndex = null;

        let awaitingTextPlacement = false;
        let textToPlace = '';
        let textFont = '';

        let lassoPoints = [];
        let isLassoing = false;
        let selectedImageData = null;
        let isMovingSelection = false;
        let selectionOffset = { x: 0, y: 0 };
        let selectionStartProjectPoint = { x: 0, y: 0 };
        let initialSelectionOffsetAtDragStart = { x: 0, y: 0 };

        let awaitingStickerPlacement = false;
        let stickerToPlace = null;

        let mobileRefinedMode = false; // State for refined mobile layout

        // For mobile tap gestures
        let lastTapTime = 0;
        let tapCount = 0;
        const TAP_TIMEOUT = 300; // ms to detect multiple taps

        const availableStickers = [
            { emoji: 'üòÄ', size: 50 }, { emoji: 'üòÇ', size: 50 }, { emoji: 'üòç', size: 50 },
            { emoji: 'ü§©', size: 50 }, { emoji: 'ü•≥', size: 50 }, { emoji: 'üòá', size: 50 },
            { emoji: 'üòé', size: 50 }, { emoji: 'ü§ì', size: 50 }, { emoji: 'ü§î', size: 50 },
            { emoji: 'üòè', size: 50 }, { emoji: 'ü•∫', size: 50 }, { emoji: 'ü§Ø', size: 50 },
            { emoji: 'üëç', size: 50 }, { emoji: '‚ù§Ô∏è', size: 50 }, { emoji: 'üåü', size: 50 },
            { emoji: 'üåà', size: 50 }, { emoji: 'üöÄ', size: 50 }, { emoji: 'üí°', size: 50 },
            { emoji: 'üéâ', size: 50 }, { emoji: 'üî•', size: 50 }, { emoji: 'üíØ', size: 50 },
            { emoji: '‚úÖ', size: 50 }, { emoji: 'üé∂', size: 50 }, { emoji: 'üê±', size: 50 },
            { emoji: 'üê∂', size: 50 }, { emoji: 'üêº', size: 50 }, { emoji: 'üçé', size: 50 },
            { emoji: 'üçï', size: 50 }, { emoji: '‚òï', size: 50 }, { emoji: 'üéà', size: 50 },
            { emoji: 'üå∏', size: 50 }, { emoji: 'üåº', size: 50 }, { emoji: 'üåª', size: 50 },
            { emoji: 'üçÄ', size: 50 }, { emoji: 'üçÑ', size: 50 }, { emoji: 'üçÇ', size: 50 },
            { emoji: 'üçÅ', size: 50 }, { emoji: '‚ùÑÔ∏è', size: 50 }, { emoji: '‚òÄÔ∏è', size: 50 },
            { emoji: '‚ö°', size: 50 }, { emoji: '‚òÅÔ∏è', size: 50 }, { emoji: '‚òî', size: 50 },
            { emoji: 'üåô', size: 50 }, { emoji: 'üåç', size: 50 }, { emoji: 'üåä', size: 50 },
            { emoji: 'üå≤', size: 50 }, { emoji: 'üå≥', size: 50 }, { emoji: 'üåµ', size: 50 },
            { emoji: 'üå∑', size: 50 }, { emoji: 'üåπ', size: 50 }, { emoji: 'üå∫', size: 50 },
            { emoji: 'üåæ', size: 50 }, { emoji: 'üå∞', size: 50 }, { emoji: 'üçá', size: 50 },
            { emoji: 'üçâ', size: 50 }, { emoji: 'üçä', size: 50 }, { emoji: 'üçã', size: 50 },
            { emoji: 'üçå', size: 50 }, { emoji: 'üçç', size: 50 }, { emoji: 'ü•≠', size: 50 },
            { emoji: 'üçì', size: 50 }, { emoji: 'üçí', size: 50 }, { emoji: 'üçë', size: 50 },
            { emoji: 'ü•ù', size: 50 }, { emoji: 'ü•ë', size: 50 }, { emoji: 'ü•¶', size: 50 },
            { emoji: 'ü•ï', size: 50 }, { emoji: 'üå∂Ô∏è', size: 50 }, { emoji: 'ü•î', size: 50 },
            { emoji: 'üåΩ', size: 50 }, { emoji: 'üçû', size: 50 }, { emoji: 'ü•ê', size: 50 },
            { emoji: 'ü•®', size: 50 }, { emoji: 'üßÄ', size: 50 }, { emoji: 'ü•ö', size: 50 },
            { emoji: 'üç≥', size: 50 }, { emoji: 'ü•ì', size: 50 }, { emoji: 'üçî', size: 50 },
            { emoji: 'üçü', size: 50 }, { emoji: 'üå≠', size: 50 }, { emoji: 'ü•™', size: 50 },
            { emoji: 'üåÆ', size: 50 }, { emoji: 'üåØ', size: 50 }, { emoji: 'ü•ô', size: 50 },
            { emoji: 'üç¶', size: 50 }, { emoji: 'üç©', size: 50 }, { emoji: 'üç™', size: 50 },
            { emoji: 'üéÇ', size: 50 }, { emoji: 'üç∞', size: 50 }, { emoji: 'üßÅ', size: 50 },
            { emoji: 'ü•ß', size: 50 }, { emoji: 'üç´', size: 50 }, { emoji: 'üç¨', size: 50 },
            { emoji: 'üç≠', size: 50 }, { emoji: 'üçÆ', size: 50 }, { emoji: 'üçØ', size: 50 },
            { emoji: 'ü•õ', size: 50 }, { emoji: '‚òï', size: 50 }, { emoji: 'üçµ', size: 50 },
            { emoji: 'üç∂', size: 50 }, { emoji: 'üçæ', size: 50 }, { emoji: 'üç∑', size: 50 },
            { emoji: 'üç∏', size: 50 }, { emoji: 'üçπ', size: 50 }, { emoji: 'üç∫', size: 50 },
            { emoji: 'üçª', size: 50 }, { emoji: 'ü•Ç', size: 50 }, { emoji: 'ü•É', size: 50 },
            { emoji: 'ü•§', size: 50 }, { emoji: 'üßã', size: 50 }, { emoji: 'üöó', size: 50 },
            { emoji: 'üöï', size: 50 }, { emoji: 'üöô', size: 50 }, { emoji: 'üöå', size: 50 },
            { emoji: 'üèéÔ∏è', size: 50 }, { emoji: 'üöì', size: 50 }, { emoji: 'üöë', size: 50 },
            { emoji: 'üöí', size: 50 }, { emoji: 'üöê', size: 50 }, { emoji: 'üöö', size: 50 },
            { emoji: 'üöõ', size: 50 }, { emoji: 'üöú', size: 50 }, { emoji: 'üö≤', size: 50 },
            { emoji: 'üõ¥', size: 50 }, { emoji: 'üõµ', size: 50 }, { emoji: 'üèçÔ∏è', size: 50 },
            { emoji: 'üö®', size: 50 }, { emoji: 'üöî', size: 50 }, { emoji: 'üöç', size: 50 },
            { emoji: 'üöò', size: 50 }, { emoji: 'üöñ', size: 50 }, { emoji: 'üöÜ', size: 50 },
            { emoji: 'üöá', size: 50 }, { emoji: 'üöà', size: 50 }, { emoji: 'üöâ', size: 50 },
            { emoji: 'üöä', size: 50 }, { emoji: 'üöÉ', size: 50 }, { emoji: 'üöã', size: 50 },
            { emoji: 'üöÑ', size: 50 }, { emoji: 'üöÖ', size: 50 }, { emoji: 'üöÇ', size: 50 },
            { emoji: 'üöÜ', size: 50 }, { emoji: 'üöá', size: 50 }, { emoji: 'üöà', size: 50 },
            { emoji: 'üöâ', size: 50 }, { emoji: 'üöä', size: 50 }, { emoji: 'üöÉ', size: 50 },
            { emoji: 'üöã', size: 50 }, { emoji: 'üöù', size: 50 }, { emoji: 'üöû', size: 50 },
            { emoji: 'üöü', size: 50 }, { emoji: 'üö†', size: 50 }, { emoji: 'üö°', size: 50 },
            { emoji: 'üö¢', size: 50 }, { emoji: 'üõ•Ô∏è', size: 50 }, { emoji: 'üö§', size: 50 },
            { emoji: '‚õ¥Ô∏è', size: 50 }, { emoji: '‚öì', size: 50 }, { emoji: 'üöÄ', size: 50 },
            { emoji: '‚úàÔ∏è', size: 50 }, { emoji: 'üõ´', size: 50 }, { emoji: 'üõ¨', size: 50 },
            { emoji: 'üí∫', size: 50 }, { emoji: 'üöÅ', size: 50 }, { emoji: 'üõ∞Ô∏è', size: 50 },
            { emoji: 'üõ∏', size: 50 }, { emoji: 'üè†', size: 50 }, { emoji: 'üè°', size: 50 },
            { emoji: 'üèòÔ∏è', size: 50 }, { emoji: 'üè¢', size: 50 }, { emoji: 'üè£', size: 50 },
            { emoji: 'üè§', size: 50 }, { emoji: 'üè•', size: 50 }, { emoji: 'üè¶', size: 50 },
            { emoji: 'üè®', size: 50 }, { emoji: 'üè©', size: 50 }, { emoji: 'üè™', size: 50 },
            { emoji: 'üè´', size: 50 }, { emoji: 'üè¨', size: 50 }, { emoji: 'üè≠', size: 50 },
            { emoji: 'üèØ', size: 50 }, { emoji: 'üè∞', size: 50 }, { emoji: 'üíí', size: 50 },
            { emoji: 'üóº', size: 50 }, { emoji: 'üóΩ', size: 50 }, { emoji: '‚õ™', size: 50 },
            { emoji: 'üïå', size: 50 }, { emoji: 'üõï', size: 50 }, { emoji: 'üïç', size: 50 },
            { emoji: '‚õ©Ô∏è', size: 50 }, { emoji: 'üïã', size: 50 }, { emoji: ' fountain', size: 50 },
            { emoji: '‚õ≤', size: 50 }, { emoji: '‚õ∫', size: 50 }, { emoji: 'üèïÔ∏è', size: 50 },
            { emoji: 'üèûÔ∏è', size: 50 }, { emoji: 'üõ£Ô∏è', size: 50 }, { emoji: 'üõ§Ô∏è', size: 50 },
            { emoji: 'üåÖ', size: 50 }, { emoji: 'üåÑ', size: 50 }, { emoji: 'üåá', size: 50 },
            { emoji: 'üåÜ', size: 50 }, { emoji: 'üåÉ', size: 50 }, { emoji: 'üåâ', size: 50 },
            { emoji: 'üåÅ', size: 50 }, { emoji: 'üó∫Ô∏è', size: 50 }, { emoji: 'üóæ', size: 50 },
            { emoji: 'üß≠', size: 50 }
        ];

        function showUserMessage(msg) {
            if (msgDisplay._timeoutId) {
                clearTimeout(msgDisplay._timeoutId);
            }
            msgDisplay.textContent = msg;
            msgDisplay.classList.remove('hidden', 'opacity-0');
            msgDisplay.classList.add('opacity-100');

            msgDisplay._timeoutId = setTimeout(() => {
                msgDisplay.classList.remove('opacity-100');
                msgDisplay._timeoutId = setTimeout(() => msgDisplay.classList.add('hidden'), 500);
            }, 2000);
        }

        // Function to open a modal
        function openModal(modalElement) {
            modalElement.classList.remove('hidden');
            setTimeout(() => {
                modalElement.classList.add('open');
            }, 10);
        }

        // Function to close a modal
        function closeModal(modalElement) {
            modalElement.classList.remove('open');
            modalElement.addEventListener('transitionend', function handler() {
                modalElement.classList.add('hidden');
                modalElement.removeEventListener('transitionend', handler);
            }, { once: true });
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function rgbaToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function loadImage(src) {
            if (imageCache.has(src)) {
                return Promise.resolve(imageCache.get(src));
            }
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache.set(src, img);
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        function saveStateToHistory() {
            if (historyPtr < historyStates.length - 1) {
                historyStates = historyStates.slice(0, historyPtr + 1);
            }
            historyStates.push(JSON.parse(JSON.stringify(framesData)));
            historyPtr++;

            if (historyStates.length > MAX_HISTORY_STATES) {
                historyStates.shift();
                historyPtr--;
            }
            updateUndoRedoButtons();
        }

        function performUndo() {
            if (historyPtr > 0) {
                historyPtr--;
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr]));
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateFrameNumberDisplay();
                updateUndoRedoButtons();
                showUserMessage('Undo successful!');
            }
        }

        function performRedo() {
            if (historyPtr < historyStates.length - 1) {
                historyPtr++;
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr]));
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateFrameNumberDisplay();
                updateUndoRedoButtons();
                showUserMessage('Redo successful!');
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = !(historyPtr > 0);
            redoBtn.disabled = !(historyPtr < historyStates.length - 1);
        }

        function updateFrameNumberDisplay() {
            currentFrameNumberDisplay.textContent = `F${currentFrameIdx + 1}/${framesData.length}`;
        }

        async function loadFrameIntoBuffer() {
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const currentFrameDrawingData = framesData[currentFrameIdx].imageData;

            if (currentFrameDrawingData && typeof currentFrameDrawingData === 'string' && currentFrameDrawingData.startsWith('data:image/png;base64,')) {
                try {
                    const img = imageCache.get(currentFrameDrawingData) || await loadImage(currentFrameDrawingData);
                    bufferCtx.drawImage(img, 0, 0, bufferCanvas.width, bufferCanvas.height);
                } catch (error) {
                    console.error("Oops, couldn't load frame drawing data into the buffer:", error);
                }
            }
        }

        async function renderCanvasDisplay() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            mainCtx.fillStyle = '#ffffff';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            const currentFrame = framesData[currentFrameIdx];

            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            const offsetX = (mainCanvas.width - displayContentWidth) / 2;
            const offsetY = (mainCanvas.height - displayContentHeight) / 2;

            if (currentFrame && currentFrame.background) {
                try {
                    const bgImg = imageCache.get(currentFrame.background) || await loadImage(currentFrame.background);
                    mainCtx.drawImage(bgImg, offsetX, offsetY, displayContentWidth, displayContentHeight);
                } catch (error) {
                    console.error("Error loading background image:", error);
                }
            }

            mainCtx.save();
            mainCtx.translate(panOffset.x, panOffset.y);
            mainCtx.globalAlpha = 1.0;
            mainCtx.globalCompositeOperation = 'source-over';
            mainCtx.drawImage(bufferCanvas, offsetX, offsetY, displayContentWidth, displayContentHeight);

            if (currentTool === 'lasso' && isLassoing && lassoPoints.length > 1) {
                mainCtx.save();
                mainCtx.strokeStyle = 'blue';
                mainCtx.lineWidth = 2;
                mainCtx.setLineDash([5, 5]);
                mainCtx.beginPath();
                const firstPoint = getDisplayCoords(lassoPoints[0].x, lassoPoints[0].y);
                mainCtx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    const point = getDisplayCoords(lassoPoints[i].x, lassoPoints[i].y);
                    mainCtx.lineTo(point.x, point.y);
                }
                mainCtx.stroke();
                mainCtx.restore();
            }

            if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection && selectedImageData) {
                mainCtx.save();
                mainCtx.globalAlpha = 0.8;
                const displaySelectionX = (selectionOffset.x * displayContentWidth / projWidth) + offsetX;
                const displaySelectionY = (selectionOffset.y * displayContentHeight / projHeight) + offsetY;
                
                const displaySelectionWidth = selectedImageData.width * displayContentWidth / projWidth;
                const displaySelectionHeight = selectedImageData.height * displayContentHeight / projHeight;

                mainCtx.drawImage(selectedImageData, displaySelectionX, displaySelectionY, displaySelectionWidth, displaySelectionHeight);
                mainCtx.restore();
            }

            mainCtx.strokeStyle = '#888888';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]);
            mainCtx.strokeRect(offsetX, offsetY, displayContentWidth, displayContentHeight);
            mainCtx.setLineDash([]);

            mainCtx.restore();
            mainCtx.globalAlpha = 1.0;
            mainCtx.globalCompositeOperation = 'source-over';
        }

        function saveCurrentFrameDrawingData() {
            if (!framesData[currentFrameIdx]) {
                console.error("No current frame to save drawing data to.");
                return;
            }
            framesData[currentFrameIdx].imageData = bufferCanvas.toDataURL('image/png');
        }

        function getTransformedDrawingCoords(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            const displayOffsetX = (mainCanvas.width - displayContentWidth) / 2;
            const displayOffsetY = (mainCanvas.height - displayContentHeight) / 2;

            const transformedX = (canvasX - panOffset.x - displayOffsetX);
            const transformedY = (canvasY - panOffset.y - displayOffsetY);

            const x = transformedX * (projWidth / displayContentWidth);
            const y = transformedY * (projHeight / displayContentHeight);

            return { x, y };
        }

        async function handleInteractionStart(e) {
            e.preventDefault();

            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    drawingActive = false;
                    return;
                }
            }

            if (currentTool === 'eyedropper') {
                const rect = mainCanvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                const imageData = mainCtx.getImageData(canvasX, canvasY, 1, 1).data;
                brushColor = rgbaToHex(imageData[0], imageData[1], imageData[2]);
                brushColorInput.value = brushColor;
                bufferCtx.strokeStyle = brushColor;
                
                currentTool = 'brush'; // Reset to brush after picking color
                updateToolButtonStates();
                showUserMessage('Color picked!');
                return;
            }

            if (currentTool === 'pan') {
                panningActive = true;
                lastPanPt = { x: clientX, y: clientY };
                return;
            }

            if (currentTool === 'fill') {
                await loadFrameIntoBuffer();
                const { x, y } = getTransformedDrawingCoords(clientX, clientY);
                floodFill(x, y, hexToRgba(brushColor), bufferCtx, bufferCanvas.width, bufferCanvas.height);
                saveCurrentFrameDrawingData();
                renderCanvasDisplay();
                saveStateToHistory();
                showUserMessage('Fill applied!');
                return;
            }

            if (currentTool === 'lasso') {
                await loadFrameIntoBuffer();
                lassoPoints = [];
                isLassoing = true;
                const { x, y } = getTransformedDrawingCoords(clientX, clientY);
                lassoPoints.push({ x, y });
                return;
            }

            if (currentTool === 'edit' || currentTool === 'resize') {
                if (selectedImageData) {
                    isMovingSelection = true;
                    selectionStartProjectPoint = getTransformedDrawingCoords(clientX, clientY);
                    initialSelectionOffsetAtDragStart = { x: selectionOffset.x, y: selectionOffset.y };
                    return;
                } else {
                    showUserMessage('No selection to move/resize. Use Lasso tool first.');
                    return;
                }
            }

            // Drawing tools setup
            bufferCtx.lineCap = 'round';
            bufferCtx.lineJoin = 'round';
            bufferCtx.strokeStyle = brushColor;
            bufferCtx.lineWidth = brushSize;
            bufferCtx.globalCompositeOperation = 'source-over'; // Default for drawing

            bufferCtx.shadowBlur = 0; // Reset shadow
            bufferCtx.shadowColor = 'transparent'; // Reset shadow color

            if (currentTool === 'pencil') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 0.4;
            } else if (currentTool === 'brush') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 0.7;
            } else if (currentTool === 'pen') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 1.0;
            } else if (currentTool === 'watercolor') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                bufferCtx.shadowColor = brushColor;
                bufferCtx.shadowBlur = brushSize * (watercolorFlow / 100) * 0.7;
            }
            
            const { x, y } = getTransformedDrawingCoords(clientX, clientY);
            bufferCtx.beginPath();
            bufferCtx.moveTo(x, y);
            drawingActive = true;
        }

        async function handleInteractionMove(e) {
            e.preventDefault();

            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    drawingActive = false;
                    return;
                }
            }

            if (currentTool === 'pan' && panningActive) {
                const dx = clientX - lastPanPt.x;
                const dy = clientY - lastPanPt.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPt = { x: clientX, y: clientY };
                renderCanvasDisplay();
                return;
            }

            if (currentTool === 'lasso' && isLassoing) {
                const { x, y } = getTransformedDrawingCoords(clientX, clientY);
                lassoPoints.push({ x, y });
                renderCanvasDisplay();
                return;
            }

            if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection) {
                const currentProjectPoint = getTransformedDrawingCoords(clientX, clientY);

                const dx = currentProjectPoint.x - selectionStartProjectPoint.x;
                const dy = currentProjectPoint.y - selectionStartProjectPoint.y;

                selectionOffset.x = initialSelectionOffsetAtDragStart.x + dx;
                selectionOffset.y = initialSelectionOffsetAtDragStart.y + dy;

                renderCanvasDisplay();
                return;
            }

            if (!drawingActive) return;

            const { x, y } = getTransformedDrawingCoords(clientX, clientY);
            
            if (currentTool === 'eraser') {
                bufferCtx.globalCompositeOperation = 'destination-out';
            } else {
                bufferCtx.globalCompositeOperation = 'source-over';
            }

            bufferCtx.lineTo(x, y);
            bufferCtx.stroke();
            renderCanvasDisplay();
        }

        async function handleInteractionEnd(e) {
            e.preventDefault();

            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            // Tap gesture detection for mobile only
            if (e.touches && e.touches.length > 0 && !drawingActive && !panningActive) {
                const currentTime = new Date().getTime();
                const tapInterval = currentTime - lastTapTime;

                if (tapInterval < TAP_TIMEOUT && tapInterval > 0) {
                    tapCount++;
                } else {
                    tapCount = 1;
                }
                lastTapTime = currentTime;

                if (tapCount === 2) {
                    setTimeout(() => {
                        if (tapCount === 2) {
                            performUndo();
                            tapCount = 0;
                        }
                    }, TAP_TIMEOUT);
                } else if (tapCount === 3) {
                    performRedo();
                    tapCount = 0;
                }
            }

            if (currentTool === 'lasso') {
                if (isLassoing) {
                    isLassoing = false;
                    if (lassoPoints.length > 2) {
                        await extractLassoSelection();
                        showUserMessage('Lasso selection made. Use the Edit tool to move/place, or Resize tool to change size.');
                    } else {
                        showUserMessage('Lasso selection too small. Try again.');
                    }
                    currentTool = 'brush'; // Reset to brush after lassoing
                    updateToolButtonStates();
                    renderCanvasDisplay();
                    return;
                }
            }

            // For drawing tools (pencil, brush, pen, watercolor, eraser)
            if (currentTool !== 'fill' && currentTool !== 'eyedropper' && currentTool !== 'pan' &&
                currentTool !== 'edit' && currentTool !== 'resize' && currentTool !== 'sticker') {
                if (drawingActive) {
                    bufferCtx.closePath();
                    // Reset drawing context properties to default for next stroke
                    bufferCtx.globalCompositeOperation = 'source-over';
                    bufferCtx.globalAlpha = 1.0;
                    bufferCtx.shadowBlur = 0;
                    bufferCtx.shadowColor = 'transparent';
                    saveCurrentFrameDrawingData();
                    saveStateToHistory();
                }
            }
            drawingActive = false;
            panningActive = false;

            if (!(currentTool === 'edit' || currentTool === 'resize')) {
                 renderCanvasDisplay();
            }
        }

        function floodFill(startX, startY, fillColor, ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            const getPixelColor = (x, y) => {
                if (x < 0 || x >= width || y < 0 || y >= height) return [-1, -1, -1, -1];
                const index = (Math.floor(y) * width + Math.floor(x)) * 4;
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            const setPixelColor = (x, y, color) => {
                const index = (Math.floor(y) * width + Math.floor(x)) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            const startColor = getPixelColor(startX, startY);

            if (startColor[0] === -1 || (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3])) {
                return;
            }

            const pixelStack = [[Math.floor(startX), Math.floor(startY)]];
            const visited = new Set();

            const colorsMatch = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x >= 0 && x < width && y >= 0 && y < height && colorsMatch(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor);

                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function updateTimelineDisplay() {
            timelineDiv.innerHTML = '';
            framesData.forEach((_, index) => {
                const frameButton = document.createElement('button');
                frameButton.textContent = `F${index + 1}`;
                frameButton.classList.add(
                    'frame-button', 'flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg',
                    'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold',
                    'transition-all', 'duration-200'
                );
                
                if (index === currentFrameIdx) {
                    frameButton.classList.add('active-frame', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                    frameButton.classList.remove('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                } else {
                    frameButton.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                    frameButton.classList.remove('active-frame', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                }
                
                frameButton.onclick = () => {
                    if (animPlaying) pauseAnimationPlayback();
                    currentFrameIdx = index;
                    loadFrameIntoBuffer().then(renderCanvasDisplay);
                    updateTimelineDisplay();
                    updateFrameNumberDisplay();
                };

                frameButton.draggable = true;
                frameButton.dataset.frameIndex = index;

                frameButton.addEventListener('dragstart', handleDragStart);
                frameButton.addEventListener('dragover', handleDragOver);
                frameButton.addEventListener('dragenter', handleDragEnter);
                frameButton.addEventListener('dragleave', handleDragLeave);
                frameButton.addEventListener('drop', handleDrop);
                frameButton.addEventListener('dragend', handleDragEnd);

                timelineDiv.appendChild(frameButton);
            });
            updateTimelineScrollShadows();
            updateFrameNumberDisplay();
        }

        function updateTimelineScrollShadows() {
            const container = timelineContainer;
            // Use scrollWidth and clientWidth of the inner content for accurate calculation
            const contentWidth = timelineDiv.scrollWidth;
            const viewportWidth = container.clientWidth;
            const scrollLeft = container.scrollLeft;

            // Only show left shadow if scrolled right more than a few pixels
            container.style.setProperty('--left-shadow-opacity', scrollLeft > 5 ? '1' : '0');

            // Only show right shadow if there's content to scroll to the right
            // Add a small tolerance (e.g., 5px) to prevent flicker at the end
            container.style.setProperty('--right-shadow-opacity', (scrollLeft + viewportWidth) < (contentWidth - 5) ? '1' : '0');

            // If content does not overflow the container, hide both shadows
            if (contentWidth <= viewportWidth) {
                container.style.setProperty('--left-shadow-opacity', '0');
                container.style.setProperty('--right-shadow-opacity', '0');
            }
        }


        function handleDragStart(e) {
            draggedFrameIndex = parseInt(e.target.dataset.frameIndex);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedFrameIndex);
            e.target.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (e.target.classList.contains('frame-button') && parseInt(e.target.dataset.frameIndex) !== draggedFrameIndex) {
                e.target.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const droppedOnIndex = parseInt(e.target.dataset.frameIndex);
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));

            if (draggedIndex === droppedOnIndex || isNaN(draggedIndex) || isNaN(droppedOnIndex)) {
                return;
            }

            // Save current frame data before reordering to ensure it's up-to-date
            saveCurrentFrameDrawingData();
            
            const currentFrameContent = framesData[currentFrameIdx]; // Get reference to content of current frame before splice

            const [draggedFrame] = framesData.splice(draggedIndex, 1);
            framesData.splice(droppedOnIndex, 0, draggedFrame);

            currentFrameIdx = framesData.indexOf(currentFrameContent); // Find new index of previously active frame

            updateTimelineDisplay();
            loadFrameIntoBuffer().then(renderCanvasDisplay);
            saveStateToHistory();
            showUserMessage('Frame reordered!');
        }

        function handleDragEnd(e) {
            const frameButtons = timelineDiv.querySelectorAll('.frame-button');
            frameButtons.forEach(btn => {
                btn.classList.remove('dragging', 'drag-over');
            });
            draggedFrameIndex = null;
        }

        function addFrame() {
            saveCurrentFrameDrawingData();

            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const blankFrameDrawingData = bufferCanvas.toDataURL('image/png');

            const newFrame = {
                imageData: blankFrameDrawingData,
                background: null
            };

            framesData.splice(currentFrameIdx + 1, 0, newFrame);
            currentFrameIdx++;

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateFrameNumberDisplay();
            saveStateToHistory();
            showUserMessage('New frame added!');
        }

        function deleteFrame() {
            if (framesData.length <= 1) {
                showUserMessage('Cannot delete the last frame! You need at least one.');
                return;
            }
            framesData.splice(currentFrameIdx, 1);
            if (currentFrameIdx >= framesData.length) {
                currentFrameIdx = framesData.length - 1;
            }

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateFrameNumberDisplay();
            saveStateToHistory();
            showUserMessage('Frame deleted!');
        }

        function duplicateFrame() {
            saveCurrentFrameDrawingData();

            const currentFrame = framesData[currentFrameIdx];
            const duplicatedFrame = JSON.parse(JSON.stringify(currentFrame));

            framesData.splice(currentFrameIdx + 1, 0, duplicatedFrame);
            currentFrameIdx++;

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateFrameNumberDisplay();
            saveStateToHistory();
            showUserMessage('Frame duplicated!');
        }

        function clearCurrentFrame() {
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const blankFrameDrawingData = bufferCanvas.toDataURL('image/png');

            framesData[currentFrameIdx] = {
                imageData: blankFrameDrawingData,
                background: null
            };

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            saveStateToHistory();
            showUserMessage('Current frame cleared!');
        }

        function saveProject() {
            saveCurrentFrameDrawingData();
            localStorage.setItem('animationProject', JSON.stringify(framesData));
            localStorage.setItem('currentFrameIndex', currentFrameIdx.toString());
            localStorage.setItem('projectWidth', projWidth.toString());
            localStorage.setItem('projectHeight', projHeight.toString());
            localStorage.setItem('currentOpacity', currentOpacity.toString());
            localStorage.setItem('watercolorFlow', watercolorFlow.toString());
            localStorage.setItem('mobileRefinedMode', mobileRefinedMode.toString()); // Save refined mode state
            showUserMessage('Animation project saved!');
        }

        function loadProject() {
            const savedProjectData = localStorage.getItem('animationProject');
            const savedActiveFrameIndex = localStorage.getItem('currentFrameIndex');
            const savedProjectWidth = localStorage.getItem('projectWidth');
            const savedProjectHeight = localStorage.getItem('projectHeight');
            const savedOpacity = localStorage.getItem('currentOpacity');
            const savedFlow = localStorage.getItem('watercolorFlow');
            const savedMobileRefinedMode = localStorage.getItem('mobileRefinedMode');


            if (!savedProjectData) {
                showUserMessage('No saved animation project found! Start drawing something new.');
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProjectData);
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    framesData = loadedFrames.map(frame => {
                        if (typeof frame === 'string') {
                            return { imageData: frame, background: null };
                        }
                        if (!frame.background) {
                            frame.background = null;
                        }
                        return frame;
                    });

                    currentFrameIdx = Math.min(parseInt(savedActiveFrameIndex, 10) || 0, framesData.length - 1);
                    
                    const newWidth = parseInt(savedProjectWidth, 10) || 800;
                    const newHeight = parseInt(savedProjectHeight, 10) || 600;
                    
                    if (newWidth !== projWidth || newHeight !== projHeight) {
                        projWidth = newWidth;
                        projHeight = newHeight;
                        projectWidthInput.value = projWidth;
                        projectHeightInput.value = projHeight;
                    }

                    currentOpacity = parseInt(savedOpacity, 10) || 100;
                    watercolorFlow = parseInt(savedFlow, 10) || 50;
                    opacitySlider.value = currentOpacity;
                    opacityValueSpan.textContent = `${currentOpacity}%`;
                    flowSlider.value = watercolorFlow;
                    flowValueSpan.textContent = `${watercolorFlow}%`;

                    // Load refined mobile mode state
                    mobileRefinedMode = savedMobileRefinedMode === 'true';
                    enableRefinedMobileLayoutToggle.checked = mobileRefinedMode;
                    updateRefinedMobileLayout();
                    
                    historyStates = [];
                    historyPtr = -1;
                    saveStateToHistory();
                    loadFrameIntoBuffer().then(renderCanvasDisplay);
                    updateTimelineDisplay();
                    updateFrameNumberDisplay();
                    showUserMessage('Animation project loaded successfully!');
                } else {
                    showUserMessage('Hmm, saved project data seems a bit off or empty.');
                }
            } catch (error) {
                console.error("Error trying to parse loaded project data:", error);
                showUserMessage('Something went wrong loading the project data.');
            }
        }

        function startAnimationPlayback() {
            if (framesData.length === 0) {
                showUserMessage('Can\'t play an animation with no frames!');
                return;
            }
            if (animPlaying) return;

            animPlaying = true;
            
            renderCanvasDisplay();

            const frameDelay = 1000 / fps;
            animInterval = setInterval(() => {
                currentFrameIdx = (currentFrameIdx + 1) % framesData.length;
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateFrameNumberDisplay();
            }, frameDelay);
            
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            playBtnToolbox.disabled = true;
            pauseBtnToolbox.disabled = false;
            stopBtnToolbox.disabled = false;
            showUserMessage('Playing animation...');
        }

        function pauseAnimationPlayback() {
            if (animInterval) {
                clearInterval(animInterval);
                animInterval = null;
            }
            animPlaying = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            playBtnToolbox.disabled = false;
            pauseBtnToolbox.disabled = true;
            showUserMessage('Animation paused.');
        }

        function stopAnimationPlayback() {
            pauseAnimationPlayback();
            currentFrameIdx = 0;
            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateFrameNumberDisplay();
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            playBtnToolbox.disabled = false;
            pauseBtnToolbox.disabled = true;
            stopBtnToolbox.disabled = true;
            showUserMessage('Animation stopped.');
        }

        async function exportGifAnimation() {
            if (typeof GIF === 'undefined') {
                showUserMessage('GIF.js library not loaded. Cannot export GIF.');
                console.error('GIF.js is missing! Make sure the script is loaded.');
                return;
            }
            if (framesData.length === 0) {
                showUserMessage('Nothing to export! Add some frames first.');
                return;
            }

            exporting = true;
            exportProg = 0;
            exportGifBtn.disabled = true;
            exportGifLoading.style.display = 'flex'; // Show loading indicator
            exportProgressText.textContent = '0%';
            showUserMessage('Generating GIF, this might take a moment...');

            const gifEncoder = new GIF({
                workers: 2,
                quality: 10,
                delay: 1000 / fps,
                width: projWidth,
                height: projHeight,
                background: '#ffffff'
            });

            const compositeCanvas = document.createElement('canvas');
            const compositeCtx = compositeCanvas.getContext('2d');
            compositeCanvas.width = projWidth;
            compositeCanvas.height = projHeight;
            compositeCtx.imageSmoothingEnabled = true;

            for (let i = 0; i < framesData.length; i++) {
                compositeCtx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
                compositeCtx.fillStyle = '#ffffff';
                compositeCtx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);

                const frameToExport = framesData[i];
                if (frameToExport.background) {
                    try {
                        const bgImg = await loadImage(frameToExport.background);
                        compositeCtx.drawImage(bgImg, 0, 0, projWidth, projHeight);
                    } catch (error) {
                        console.error(`Problem loading background for frame ${i} for GIF export:`, error);
                    }
                }

                if (frameToExport.imageData && frameToExport.imageData.startsWith('data:image/png;base64,')) {
                    try {
                        const img = await loadImage(frameToExport.imageData);
                        compositeCtx.drawImage(img, 0, 0, projWidth, projHeight);
                    } catch (error) {
                        console.error(`Problem loading drawing data for frame ${i} for GIF export:`, error);
                    }
                }
                gifEncoder.addFrame(compositeCtx, { copy: true, delay: 1000 / fps });
            }

            gifEncoder.on('progress', function(p) {
                exportProg = Math.floor(p * 100);
                exportProgressText.textContent = `${exportProg}%`;
            });

            gifEncoder.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const dlLink = document.createElement('a');
                dlLink.href = url;
                dlLink.download = 'animation.gif';
                document.body.appendChild(dlLink);
                dlLink.click();
                document.body.removeChild(dlLink);
                URL.revokeObjectURL(url);

                exporting = false;
                exportProg = 0;
                exportGifBtn.disabled = false;
                exportGifLoading.style.display = 'none'; // Hide loading indicator
                showUserMessage('GIF exported successfully!');
            });

            gifEncoder.on('error', function(error) {
                console.error('GIF generation failed:', error);
                exporting = false;
                exportProg = 0;
                exportGifBtn.disabled = false;
                exportGifLoading.style.display = 'none'; // Hide loading indicator
                showUserMessage('Error exporting GIF.');
            });

            gifEncoder.render();
        }

        async function generateFrameIdea() {
            const ideaPromptText = ideaPromptInput.value.trim();
            if (!ideaPromptText) {
                showUserMessage('Please type in a little prompt for the idea generator first!');
                return;
            }

            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden');
            ideaText.textContent = '';

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${ideaPromptText}". Keep it concise and focused on visual elements."` }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const aiIdeaText = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = aiIdeaText;
                    generatedIdeaOutput.classList.remove('hidden');
                    showUserMessage('Idea generated successfully!');
                } else {
                    ideaText.textContent = 'Couldn\'t quite generate an idea this time. Please try a different prompt!';
                    generatedIdeaOutput.classList.remove('hidden');
                    showUserMessage('Error generating idea.');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to a network or API error.';
                generatedIdeaOutput.classList.remove('hidden');
                showUserMessage('Error generating idea.');
            } finally {
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }

        function updateToolButtonStates() {
            const allToolButtons = [
                pencilToolBtn, eraserToolBtn, fillToolBtn, eyedropperToolBtn,
                panToolBtn, textToolBtn, lassoToolBtn, editToolBtn, resizeToolBtn,
                stickerToolBtn
            ];
            
            allToolButtons.forEach(btn => {
                btn.classList.remove('active-tool');
                btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md'); 
                btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            if (['brush', 'pen', 'pencil', 'watercolor'].includes(currentTool)) {
                pencilToolBtn.classList.add('active-tool');
            } else {
                const currentToolButton = document.getElementById(`${currentTool}Tool`);
                if (currentToolButton) {
                    currentToolButton.classList.add('active-tool');
                }
            }

            const brushModalButtons = [selectBrushToolBtn, selectPenToolBtn, selectPencilToolBtn, selectWatercolorToolBtn];
            brushModalButtons.forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-700');
            });

            if (currentTool === 'brush') {
                selectBrushToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectBrushToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pen') {
                selectPenToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPenToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pencil') {
                selectPencilToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPencilToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'watercolor') {
                selectWatercolorToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectWatercolorToolBtn.classList.add('bg-blue-500', 'text-white');
            }

            if (currentTool === 'watercolor') {
                watercolorFlowSection.classList.remove('hidden');
            } else {
                watercolorFlowSection.classList.add('hidden');
            }
        }

        async function resizeDrawingBufferAndFrames(newWidth, newHeight) {
            const oldFramesData = JSON.parse(JSON.stringify(framesData));
            const newFramesData = [];

            const oldProjWidth = projWidth;
            const oldProjHeight = projHeight;

            projWidth = newWidth;
            projHeight = newHeight;

            bufferCanvas.width = newWidth;
            bufferCanvas.height = newHeight;
            bufferCtx.imageSmoothingEnabled = true;

            for (let i = 0; i < oldFramesData.length; i++) {
                const oldFrame = oldFramesData[i];
                const newFrameData = {
                    imageData: null,
                    background: null
                };

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
                tempCtx.imageSmoothingEnabled = true;

                tempCtx.clearRect(0, 0, newWidth, newHeight);

                if (oldFrame.imageData && oldFrame.imageData.startsWith('data:image/png;base64,')) {
                    try {
                        const img = await loadImage(oldFrame.imageData);
                        const offsetX = (newWidth - oldProjWidth) / 2;
                        const offsetY = (newHeight - oldProjHeight) / 2;
                        tempCtx.drawImage(img, offsetX, offsetY, oldProjWidth, oldProjHeight);
                    } catch (error) {
                        console.error("Trouble scaling drawing data during resize:", error);
                    }
                }
                newFrameData.imageData = tempCanvas.toDataURL('image/png');

                if (oldFrame.background && oldFrame.background.startsWith('data:image/png;base64,')) {
                    newFrameData.background = oldFrame.background;
                }
                newFramesData.push(newFrameData);
            }
            
            framesData = newFramesData;

            await loadFrameIntoBuffer();
            renderCanvasDisplay();
            updateTimelineDisplay();
            updateFrameNumberDisplay();
            saveStateToHistory();
            showUserMessage(`Canvas successfully resized to ${newWidth}x${newHeight}!`);
        }

        function updateTextPreview() {
            textPreviewCtx.clearRect(0, 0, textPreviewCanvas.width, textPreviewCanvas.height);
            textPreviewCtx.fillStyle = '#f9fafb';
            textPreviewCtx.fillRect(0, 0, textPreviewCanvas.width, textPreviewCanvas.height);

            const text = textInput.value;
            const fontSize = fontSizeInput.value;
            const fontFamily = fontFamilySelect.value;
            const fontWeight = fontBoldToggle.checked ? 'bold' : 'normal';
            const fontStyle = fontItalicToggle.checked ? 'italic' : 'normal';

            textFont = `${fontWeight} ${fontStyle} ${fontSize}px ${fontFamily}`;
            textPreviewCtx.font = textFont;
            textPreviewCtx.fillStyle = brushColorInput.value;
            textPreviewCtx.textAlign = 'left';
            textPreviewCtx.textBaseline = 'top';

            const lines = text.split('\n');
            let yOffset = 10;
            for (const line of lines) {
                textPreviewCtx.fillText(line, 10, yOffset);
                yOffset += parseInt(fontSize) * 1.2;
            }
        }

        function drawContentOnBuffer(content, x, y, font, color, opacity) {
            bufferCtx.save();

            if (typeof content === 'string') {
                bufferCtx.font = font;
                bufferCtx.fillStyle = color;
                bufferCtx.globalAlpha = opacity / 100;
                bufferCtx.textAlign = 'left';
                bufferCtx.textBaseline = 'top';

                const lines = content.split('\n');
                let yOffset = y;
                for (const line of lines) {
                    bufferCtx.fillText(line, x, yOffset);
                    yOffset += parseInt(font.match(/(\d+)px/)[1]) * 1.2;
                }
            } else if (content instanceof HTMLCanvasElement) {
                bufferCtx.globalAlpha = opacity / 100;
                bufferCtx.drawImage(content, x, y);
            }
            bufferCtx.restore();
        }

        async function extractLassoSelection() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = projWidth;
            tempCanvas.height = projHeight;
            tempCtx.imageSmoothingEnabled = true;

            tempCtx.drawImage(bufferCanvas, 0, 0);

            tempCtx.globalCompositeOperation = 'destination-in';
            tempCtx.beginPath();
            tempCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                tempCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            tempCtx.closePath();
            tempCtx.fillStyle = '#000';
            tempCtx.fill();
            tempCtx.globalCompositeOperation = 'source-over';

            selectedImageData = tempCanvas;

            bufferCtx.save();
            bufferCtx.globalCompositeOperation = 'destination-out';
            bufferCtx.beginPath();
            bufferCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                bufferCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            bufferCtx.closePath();
            bufferCtx.fillStyle = '#fff';
            bufferCtx.fill();
            bufferCtx.restore();

            selectionOffset = { x: lassoPoints[0].x, y: lassoPoints[0].y };
        }

        async function placeLassoSelection() {
            if (selectedImageData) {
                await loadFrameIntoBuffer();
                bufferCtx.drawImage(selectedImageData, selectionOffset.x, selectionOffset.y, selectedImageData.width, selectedImageData.height);
                saveCurrentFrameDrawingData();
                saveStateToHistory();
                showUserMessage('Selection placed!');
            }
            selectedImageData = null;
            selectionOffset = { x: 0, y: 0 };
            isMovingSelection = false;
            currentTool = 'brush';
            updateToolButtonStates();
            renderCanvasDisplay();
        }

        function populateStickerSelection() {
            stickerContainer.innerHTML = '';
            availableStickers.forEach(sticker => {
                const stickerButton = document.createElement('button');
                stickerButton.classList.add('sticker-button');
                stickerButton.textContent = sticker.emoji;
                stickerButton.style.fontSize = `${sticker.size}px`;

                stickerButton.addEventListener('click', () => {
                    stickerToPlace = sticker;
                    awaitingStickerPlacement = true;
                    closeModal(stickerSelectionModal);
                    showUserMessage(`Click on the canvas to place ${sticker.emoji} sticker.`);
                    currentTool = 'sticker';
                    updateToolButtonStates();
                });
                stickerContainer.appendChild(stickerButton);
            });
        }

        async function setBackground(imageSrc) {
            saveCurrentFrameDrawingData();
            if (imageSrc) {
                framesData[currentFrameIdx].background = imageSrc;
            } else {
                framesData[currentFrameIdx].background = null;
            }
            renderCanvasDisplay();
            saveStateToHistory();
            showUserMessage(imageSrc ? 'Background set!' : 'Background cleared!');
        }

        /**
         * Checks if the app is running inside a Median.co webview (Android/iOS app).
         * Median typically adds "x-median" to the user agent string.
         * @returns {boolean} True if running in Median app, false otherwise.
         */
        function isMedianApp() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return /x-median|Median/.test(userAgent);
        }

        /**
         * Checks if the device is an Android device based on user agent.
         * @returns {boolean} True if Android, false otherwise.
         */
        function isAndroidDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return /android/i.test(userAgent);
        }

        /**
         * Determines if the mobile app prompt should be shown.
         * It considers screen size, user agent, if it's an Android device, and if it's already in the Median app.
         * @returns {boolean} True if the mobile app prompt should be shown, false otherwise.
         */
        function shouldShowMobileWarningModal() {
            const screenWidth = window.innerWidth;
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;

            const isSmallScreen = screenWidth < 768; // Common breakpoint for mobile devices

            // Check for common mobile OS/browsers, but exclude tablet patterns
            const isMobileUA = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|rim)|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thc|501i|503i|504i|505i|506i|6270|7060|7290|7370|7420|7430|8300|8101|8102|8150|8170|8180|8190|9003|9025|9590|sync|alcatel|amoi|android|aptu|aurora|a≈°enas|avaya|blackberry|benq|brvm|cdm-|cellpad|cingular|cmc-|cldc-|cmd-|coool|cybo|daco|dhp|dmob|do(c|t)|ebmco|ercu|eudoraweb|fly|fennec|htc|iemobile|ibook|kddi|kgt|kinhin|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g5|b0|ke|pn|si)|lenovo|maemo|midp|mobi|mozilla|netfront|nestscape|nitro|nokia|palm|pana|pantone|philips|phone|pg(0|x)|pda|plucker|pocket|psp|qtek|qwap|sagem|sams(atc|us)|sgh-|shar|sie-|siemens|softbank|sony|spa|tcl-|tdg-|tel(i|m)|tim-|t-mobile|toplc|ts(v|w)|user|vodafone|wap|wonu|xda|xyzzy|zte/i.test(userAgent.substr(0, 4));
            
            // iPad and most Android tablets don't typically include "mobile" in UA but have "iPad" or "Android"
            const isTabletUA = /iPad|Android(?!.*Mobile)/i.test(userAgent);

            // Show warning if it's a small screen OR a mobile UA (excluding tablet patterns explicitly), AND NOT a Median app.
            // Only show if the user hasn't explicitly chosen to continue on web previously.
            return (isSmallScreen || isMobileUA) && !isTabletUA && !isMedianApp() && !sessionStorage.getItem('choseToContinueOnWeb');
        }

        // Applies or removes the 'mobile-refined-layout' class to the body
        function updateRefinedMobileLayout() {
            if (mobileRefinedMode) {
                document.body.classList.add('mobile-refined-layout');
                document.getElementById('playbackControlsInToolbox').style.display = 'block';
                document.getElementById('frameNavigationInToolbox').style.display = 'block';
                document.getElementById('playbackControlsMain').style.display = 'none'; // Hide desktop playback controls
                if (isAndroidDevice() && sessionStorage.getItem('choseToContinueOnWeb') === 'true') {
                    downloadAppContainer.classList.remove('hidden');
                }
            } else {
                document.body.classList.remove('mobile-refined-layout');
                document.getElementById('playbackControlsInToolbox').style.display = 'none';
                document.getElementById('frameNavigationInToolbox').style.display = 'none';
                document.getElementById('playbackControlsMain').style.display = 'flex'; // Show desktop playback controls
                downloadAppContainer.classList.add('hidden');
            }
            // Ensure FPS values are in sync regardless of which input is visible
            animSpeedInput.value = fps;
            animSpeedValueSpan.textContent = fps;
            animSpeedInputToolbox.value = fps;
            animSpeedValueToolboxSpan.textContent = fps;
        }

        window.onload = async function() {
            // Check if mobile warning should be shown on initial load
            if (shouldShowMobileWarningModal()) {
                openModal(mobileWarningModal);
            } else {
                // If not showing warning, apply saved or default layout
                mobileRefinedMode = localStorage.getItem('mobileRefinedMode') === 'true';
                enableRefinedMobileLayoutToggle.checked = mobileRefinedMode;
                updateRefinedMobileLayout();
            }

            // Show "Install App" button if running inside Median app AND it's an Android device
            if (isMedianApp() && isAndroidDevice()) {
                installAppInAppBtn.classList.remove('hidden');
            } else {
                installAppInAppBtn.classList.add('hidden');
            }

            // Event Listeners for the mobile warning modal
            continueMobileBtn.addEventListener('click', () => {
                sessionStorage.setItem('choseToContinueOnWeb', 'true'); // User chose to continue on web
                closeModal(mobileWarningModal);
                mobileRefinedMode = false; // Ensure not in refined mode by default
                enableRefinedMobileLayoutToggle.checked = mobileRefinedMode;
                updateRefinedMobileLayout();
            });

            refineForMobileBtn.addEventListener('click', () => {
                closeModal(mobileWarningModal);
                mobileRefinedMode = true; // Enable refined mode
                enableRefinedMobileLayoutToggle.checked = mobileRefinedMode;
                updateRefinedMobileLayout();
            });

            quitAppBtn.addEventListener('click', () => {
                // For a web app, this might just close the tab or redirect.
                // For a Median app, it could be a call to exit.
                // alert('Exiting application. Goodbye!'); // Replaced with custom message box if needed
                showUserMessage('Exiting application. Goodbye!');
                window.close(); // Tries to close the window/tab
            });

            refineHelpIcon.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent parent button's click event
                openModal(refineHelpModal);
            });
            closeRefineHelpModalBtn.addEventListener('click', () => {
                closeModal(refineHelpModal);
            });
            closeRefineHelpModalBtnTop.addEventListener('click', () => {
                closeModal(refineHelpModal);
            });


            // Event Listener for the new in-app install button
            installAppInAppBtn.addEventListener('click', () => {
                window.location.href = 'https://median.co/share/pkbqrw#apk';
            });


            projWidth = parseInt(localStorage.getItem('projectWidth')) || 800;
            projHeight = parseInt(localStorage.getItem('projectHeight')) || 600;
            projectWidthInput.value = projWidth;
            projectHeightInput.value = projHeight;

            currentOpacity = parseInt(localStorage.getItem('currentOpacity')) || 100;
            watercolorFlow = parseInt(localStorage.getItem('watercolorFlow')) || 50;
            opacitySlider.value = currentOpacity;
            opacityValueSpan.textContent = `${currentOpacity}%`;
            flowSlider.value = watercolorFlow;
            flowValueSpan.textContent = `${watercolorFlow}%`;

            bufferCanvas.width = projWidth;
            bufferCanvas.height = projHeight;

            mainCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingEnabled = true;

            bufferCtx.lineCap = 'round';
            bufferCtx.lineJoin = 'round';
            bufferCtx.strokeStyle = brushColor;
            bufferCtx.lineWidth = brushSize;
            
            // Set mainCanvas size after it's been mounted and has offset dimensions
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;

            if (framesData.length === 0) {
                bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
                const initialDrawingData = bufferCanvas.toDataURL('image/png'); // Changed from bufferCtx to bufferCanvas
                framesData.push({
                    imageData: initialDrawingData,
                    background: null
                });
                saveStateToHistory(); // Save initial state to history
            } else {
                loadProject(); // Try to load saved project if available
            }
            
            await loadFrameIntoBuffer();
            renderCanvasDisplay();
            
            updateTimelineDisplay();
            updateToolButtonStates();
            updateUndoRedoButtons();
            updateFrameNumberDisplay();

            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            playBtnToolbox.disabled = false;
            pauseBtnToolbox.disabled = true;
            stopBtnToolbox.disabled = true;
            exportGifBtn.disabled = false;

            populateStickerSelection();

            // Tool button event listeners
            pencilToolBtn.addEventListener('dblclick', () => {
                openModal(brushSelectionModal);
                updateToolButtonStates();
            });
            eraserToolBtn.addEventListener('click', () => { currentTool = 'eraser'; updateToolButtonStates(); });
            fillToolBtn.addEventListener('click', () => { currentTool = 'fill'; updateToolButtonStates(); });
            eyedropperToolBtn.addEventListener('click', () => { currentTool = 'eyedropper'; updateToolButtonStates(); });
            panToolBtn.addEventListener('click', () => { currentTool = 'pan'; updateToolButtonStates(); });
            textToolBtn.addEventListener('click', () => {
                currentTool = 'text';
                updateToolButtonStates();
                openModal(textToolModal);
                updateTextPreview();
            });
            lassoToolBtn.addEventListener('click', () => {
                currentTool = 'lasso';
                updateToolButtonStates();
                showUserMessage('Lasso tool selected. Draw a selection.');
            });
            editToolBtn.addEventListener('click', () => {
                currentTool = 'edit';
                updateToolButtonStates();
                if (selectedImageData) {
                    isMovingSelection = true;
                    showUserMessage('Edit tool selected. Drag to move, click to place.');
                } else {
                    showUserMessage('No selection to edit. Use Lasso tool first.');
                }
                renderCanvasDisplay();
            });
            resizeToolBtn.addEventListener('click', () => {
                currentTool = 'resize';
                updateToolButtonStates();
                if (selectedImageData) {
                    openModal(resizeSelectionModal);
                    resizeWidthInput.value = selectedImageData.width;
                    resizeHeightInput.value = selectedImageData.height;
                } else {
                    showUserMessage('No selection to resize. Use Lasso tool first.');
                }
            });
            stickerToolBtn.addEventListener('click', () => {
                currentTool = 'sticker';
                updateToolButtonStates();
                openModal(stickerSelectionModal);
            });

            stylusOnlyModeToggle.addEventListener('change', (e) => {
                isStylusOnlyModeEnabled = e.target.checked;
            });

            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                bufferCtx.strokeStyle = brushColor;
                updateTextPreview();
            });

            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`;
                bufferCtx.lineWidth = brushSize;
            });

            opacitySlider.addEventListener('input', (e) => {
                currentOpacity = parseInt(e.target.value);
                opacityValueSpan.textContent = `${currentOpacity}%`;
                // If drawing is active, update alpha immediately, otherwise it will be set on next stroke start
                if (drawingActive) {
                    if (currentTool === 'pencil') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 0.4;
                    } else if (currentTool === 'brush') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 0.7;
                    } else if (currentTool === 'pen') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 1.0;
                    } else if (currentTool === 'watercolor') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                    }
                }
            });

            flowSlider.addEventListener('input', (e) => {
                watercolorFlow = parseInt(e.target.value);
                flowValueSpan.textContent = `${watercolorFlow}%`;
                if (drawingActive && currentTool === 'watercolor') {
                    bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                    bufferCtx.shadowBlur = brushSize * (watercolorFlow / 100) * 0.7;
                }
            });

            uploadBackgroundBtn.addEventListener('click', () => uploadBackgroundInput.click());
            uploadBackgroundInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setBackground(e.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });
            clearBackgroundBtn.addEventListener('click', () => setBackground(null));

            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
duplicateFrameBtn.addEventListener('click', duplicateFrame);
clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGifAnimation);

            // Playback controls (main area)
            playBtn.addEventListener('click', startAnimationPlayback);
            pauseBtn.addEventListener('click', pauseAnimationPlayback);
            stopBtn.addEventListener('click', stopAnimationPlayback);
            animSpeedInput.addEventListener('input', (e) => {
                fps = parseInt(e.target.value);
                animSpeedValueSpan.textContent = fps;
                animSpeedInputToolbox.value = fps; // Sync with toolbox input
                animSpeedValueToolboxSpan.textContent = fps;
                if (animPlaying) {
                    pauseAnimationPlayback();
                    startAnimationPlayback();
                }
            });

            // Playback controls (toolbox)
            playBtnToolbox.addEventListener('click', startAnimationPlayback);
            pauseBtnToolbox.addEventListener('click', pauseAnimationPlayback);
            stopBtnToolbox.addEventListener('click', stopAnimationPlayback);
            animSpeedInputToolbox.addEventListener('input', (e) => {
                fps = parseInt(e.target.value);
                animSpeedValueToolboxSpan.textContent = fps;
                animSpeedInput.value = fps; // Sync with main area input
                animSpeedValueSpan.textContent = fps;
                if (animPlaying) {
                    pauseAnimationPlayback();
                    startAnimationPlayback();
                }
            });

            // Frame Navigation Buttons
            goToFirstFrameBtn.addEventListener('click', () => {
                if (animPlaying) pauseAnimationPlayback();
                currentFrameIdx = 0;
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateFrameNumberDisplay();
                showUserMessage('Go to first frame.');
            });
            goToLastFrameBtn.addEventListener('click', () => {
                if (animPlaying) pauseAnimationPlayback();
                currentFrameIdx = framesData.length - 1;
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateFrameNumberDisplay();
                showUserMessage('Go to last frame.');
            });
            goToPreviousFrameBtn.addEventListener('click', () => {
                if (animPlaying) pauseAnimationPlayback();
                if (currentFrameIdx > 0) {
                    currentFrameIdx--;
                } else {
                    currentFrameIdx = framesData.length - 1; // Loop to end
                }
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateFrameNumberDisplay();
                showUserMessage('Go to previous frame.');
            });
            goToNextFrameBtn.addEventListener('click', () => {
                if (animPlaying) pauseAnimationPlayback();
                if (currentFrameIdx < framesData.length - 1) {
                    currentFrameIdx++;
                } else {
                    currentFrameIdx = 0; // Loop to start
                }
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateFrameNumberDisplay();
                showUserMessage('Go to next frame.');
            });


            // Canvas interaction event listeners
            mainCanvas.addEventListener('mousedown', handleInteractionStart);
            mainCanvas.addEventListener('mousemove', handleInteractionMove);
            mainCanvas.addEventListener('mouseup', handleInteractionEnd);
            mainCanvas.addEventListener('mouseleave', handleInteractionEnd);

            mainCanvas.addEventListener('touchstart', handleInteractionStart);
            mainCanvas.addEventListener('touchmove', handleInteractionMove);
            mainCanvas.addEventListener('touchend', handleInteractionEnd);
            mainCanvas.addEventListener('touchcancel', handleInteractionEnd);

            mainCanvas.addEventListener('click', (e) => {
                if (awaitingTextPlacement) {
                    const { x, y } = getTransformedDrawingCoords(e.clientX, e.clientY);
                    loadFrameIntoBuffer().then(() => {
                        drawContentOnBuffer(textToPlace, x, y, textFont, brushColor, currentOpacity);
                        saveCurrentFrameDrawingData();
                        renderCanvasDisplay();
                        saveStateToHistory();
                        showUserMessage('Text placed!');
                        awaitingTextPlacement = false;
                        currentTool = 'brush';
                        updateToolButtonStates();
                    });
                } else if (awaitingStickerPlacement) {
                    const { x, y } = getTransformedDrawingCoords(e.clientX, e.clientY);
                    loadFrameIntoBuffer().then(() => {
                        drawContentOnBuffer(stickerToPlace.emoji, x, y, `${stickerToPlace.size}px sans-serif`, brushColor, currentOpacity);
                        saveCurrentFrameDrawingData();
                        renderCanvasDisplay();
                        saveStateToHistory();
                        showUserMessage('Sticker placed!');
                        awaitingStickerPlacement = false;
                        stickerToPlace = null;
                        currentTool = 'brush';
                        updateToolButtonStates();
                    });
                } else if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection) {
                    placeLassoSelection();
                }
            });

            generateIdeaBtn.addEventListener('click', () => {
                openModal(ideaModal);
                generatedIdeaOutput.classList.add('hidden');
                ideaText.textContent = '';
                ideaPromptInput.value = '';
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                closeModal(ideaModal);
            });
            closeIdeaModalBtnTop.addEventListener('click', () => {
                closeModal(ideaModal);
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea);

            helpBtn.addEventListener('click', () => {
                openModal(helpModal);
            });
            closeHelpModalBtn.addEventListener('click', () => {
                closeModal(helpModal);
            });
            closeHelpModalBtnTop.addEventListener('click', () => {
                closeModal(helpModal);
            });

            faqBtn.addEventListener('click', () => {
                window.open('https://sathvik-harish.github.io/ToonStart-Help/', '_blank');
            });

            palmRejectionHelpIcon.addEventListener('click', () => {
                openModal(palmRejectionHelpModal);
            });
            closePalmRejectionHelpModalBtn.addEventListener('click', () => {
                closeModal(palmRejectionHelpModal);
            });
            closePalmRejectionHelpModalBtnTop.addEventListener('click', () => {
                closeModal(palmRejectionHelpModal);
            });

            updatesBtn.addEventListener('click', () => {
                openModal(updatesModal);
            });
            closeUpdatesModalBtn.addEventListener('click', () => {
                closeModal(updatesModal);
            });
            closeUpdatesModalBtnTop.addEventListener('click', () => {
                closeModal(updatesModal);
            });

            customizeBtn.addEventListener('click', () => {
                openModal(customizeModal);
            });
            closeCustomizeModalBtn.addEventListener('click', () => {
                closeModal(customizeModal);
            });
            closeCustomizeModalBtnTop.addEventListener('click', () => {
                closeModal(customizeModal);
            });

            applyCanvasSizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(projectWidthInput.value, 10);
                const newHeight = parseInt(projectHeightInput.value, 10);
                if (isNaN(newWidth) || newWidth < 100 || newWidth > 2000 || isNaN(newHeight) || newHeight < 100 || newHeight > 1500) {
                    showUserMessage('Please enter valid dimensions (Width: 100-2000px, Height: 100-1500px).');
                    return;
                }
                resizeDrawingBufferAndFrames(newWidth, newHeight);
                showUserMessage(`Canvas size set to ${newWidth}x${newHeight}.`);
            });

            resetCanvasSizeBtn.addEventListener('click', () => {
                projectWidthInput.value = 800;
                projectHeightInput.value = 600;
                resizeDrawingBufferAndFrames(800, 600);
                showUserMessage('Canvas size reset to default (800x600).');
            });

            enableRefinedMobileLayoutToggle.addEventListener('change', (e) => {
                mobileRefinedMode = e.target.checked;
                updateRefinedMobileLayout();
            });

            undoBtn.addEventListener('click', performUndo);
            redoBtn.addEventListener('click', performRedo);

            selectBrushToolBtn.addEventListener('click', () => {
                currentTool = 'brush';
                updateToolButtonStates();
                closeModal(brushSelectionModal);
            });
            selectPenToolBtn.addEventListener('click', () => {
                currentTool = 'pen';
                updateToolButtonStates();
                closeModal(brushSelectionModal);
            });
            selectPencilToolBtn.addEventListener('click', () => {
                currentTool = 'pencil';
                updateToolButtonStates();
                closeModal(brushSelectionModal);
            });
            selectWatercolorToolBtn.addEventListener('click', () => {
                currentTool = 'watercolor';
                updateToolButtonStates();
                closeModal(brushSelectionModal);
            });
            closeBrushSelectionModalBtn.addEventListener('click', () => {
                closeModal(brushSelectionModal);
            });
            closeBrushSelectionModalBtnTop.addEventListener('click', () => {
                closeModal(brushSelectionModal);
            });

            textInput.addEventListener('input', updateTextPreview);
            fontFamilySelect.addEventListener('change', updateTextPreview);
            fontSizeInput.addEventListener('input', updateTextPreview);
            fontBoldToggle.addEventListener('change', updateTextPreview);
            fontItalicToggle.addEventListener('change', updateTextPreview);

            placeTextBtn.addEventListener('click', () => {
                textToPlace = textInput.value;
                const fontSize = fontSizeInput.value;
                const fontFamily = fontFamilySelect.value;
                const fontWeight = fontBoldToggle.checked ? 'bold' : 'normal';
                const fontStyle = fontItalicToggle.checked ? 'italic' : 'normal';
                textFont = `${fontWeight} ${fontStyle} ${fontSize}px ${fontFamily}`;

                closeModal(textToolModal);
                awaitingTextPlacement = true;
                showUserMessage('Click on the canvas to place text.');
            });

            cancelTextBtn.addEventListener('click', () => {
                closeModal(textToolModal);
                awaitingTextPlacement = false;
                currentTool = 'brush';
                updateToolButtonStates();
            });
            cancelTextBtnTop.addEventListener('click', () => {
                closeModal(textToolModal);
                awaitingTextPlacement = false;
                currentTool = 'brush';
                updateToolButtonStates();
            });

            closeStickerSelectionModalBtn.addEventListener('click', () => {
                closeModal(stickerSelectionModal);
                currentTool = 'brush';
                updateToolButtonStates();
            });
            closeStickerSelectionModalBtnTop.addEventListener('click', () => {
                closeModal(stickerSelectionModal);
                currentTool = 'brush';
                updateToolButtonStates();
            });

            applyResizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(resizeWidthInput.value, 10);
                const newHeight = parseInt(resizeHeightInput.value, 10);

                if (isNaN(newWidth) || newWidth <= 0 || isNaN(newHeight) || newHeight <= 0) {
                    showUserMessage('Please enter valid positive numbers for width and height.');
                    return;
                }

                if (selectedImageData) {
                    const resizedCanvas = document.createElement('canvas');
                    const resizedCtx = resizedCanvas.getContext('2d');
                    resizedCanvas.width = newWidth;
                    resizedCanvas.height = newHeight;
                    resizedCtx.imageSmoothingEnabled = true;
                    resizedCtx.drawImage(selectedImageData, 0, 0, newWidth, newHeight);
                    selectedImageData = resizedCanvas;
                    isMovingSelection = true;
                    showUserMessage('Selection resized. Click to place or drag to move.');
                }
                closeModal(resizeSelectionModal);
                renderCanvasDisplay();
            });

            cancelResizeBtn.addEventListener('click', () => {
                closeModal(resizeSelectionModal);
                if (selectedImageData) {
                    currentTool = 'edit';
                    isMovingSelection = true;
                    showUserMessage('Resize cancelled. Selection remains in edit mode.');
                } else {
                    currentTool = 'brush';
                }
                updateToolButtonStates();
                renderCanvasDisplay();
            });
            cancelResizeBtnTop.addEventListener('click', () => {
                closeModal(resizeSelectionModal);
                if (selectedImageData) {
                    currentTool = 'edit';
                    isMovingSelection = true;
                    showUserMessage('Resize cancelled. Selection remains in edit mode.');
                } else {
                    currentTool = 'brush';
                }
                updateToolButtonStates();
                renderCanvasDisplay();
            });


            window.addEventListener('resize', () => {
                saveCurrentFrameDrawingData();
                
                mainCanvas.width = mainCanvas.offsetWidth;
                mainCanvas.height = mainCanvas.offsetHeight;

                mainCtx.imageSmoothingEnabled = true;

                loadFrameIntoBuffer().then(() => {
                    bufferCtx.lineCap = 'round';
                    bufferCtx.lineJoin = 'round';
                    bufferCtx.strokeStyle = brushColor;
                    bufferCtx.lineWidth = brushSize;
                    
                    renderCanvasDisplay();
                });
                updateTimelineScrollShadows();
            });

            timelineContainer.addEventListener('scroll', updateTimelineScrollShadows);
        };
    </script>
</body>
</html>
