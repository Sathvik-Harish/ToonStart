<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .flex-grow-container {
            flex-grow: 1;
            min-height: 0;
        }
        .overflow-y-auto-custom {
            overflow-y: auto;
        }
        #staticToolbox {
            flex-shrink: 0;
            width: 256px;
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .toolbox-section {
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }
        .toolbox-section:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        .toolbox-section h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.75rem;
        }
        .toolbox-section label {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            display: block;
        }
        .toolbox-section input[type="range"] {
            width: 100%;
            height: 0.5rem;
        }
        .toolbox-section input[type="color"] {
            width: 100%;
            height: 2.5rem;
        }
        .tool-button {
            padding: 0.625rem 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            min-width: 50px;
        }
        .zoom-info {
            font-size: 0.875rem;
            color: #4b5563;
            line-height: 1.5;
        }
        .zoom-info ul {
            padding-left: 1.25rem;
        }
        .zoom-info kbd {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            font-size: 0.875em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            line-height: 1;
            color: #4a5568;
            background-color: #edf2f7;
            border: 1px solid #cbd5e0;
            border-bottom-color: #a0aec0;
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 #a0aec0;
        }
        .help-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            background-color: #9ca3af;
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s;
        }
        .help-icon:hover {
            background-color: #6b7280;
        }
        .frame-button.dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa;
            background-color: #bfdbfe;
        }
        .frame-button.drag-over {
            border: 2px dashed #3b82f6;
            background-color: #dbeafe;
        }
        .sticker-button {
            font-size: 2.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #e2e8f0;
            transition: background-color 0.2s;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .sticker-button:hover {
            background-color: #cbd5e0;
        }
        .bg-image-button {
            width: 100%;
            height: 60px;
            background-size: cover;
            background-position: center;
            border-radius: 0.5rem;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: border-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .bg-image-button:hover {
            border-color: #3b82f6;
        }
        .bg-image-button.active {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .bg-upload-button {
            background-color: #60a5fa;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
        }
        .bg-upload-button:hover {
            background-color: #3b82f6;
        }
        /* New button for in-app install */
        #installAppInAppBtn {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background-color: #10B981; /* Green-600 */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* Fully rounded */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            z-index: 100;
            display: none; /* Hidden by default */
        }
        #installAppInAppBtn:hover {
            background-color: #059669; /* Green-700 */
            transform: translateY(-2px);
        }
        #installAppInAppBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        /* Styles for small square Undo/Redo buttons */
        .history-button-small {
            width: 2rem; /* 32px */
            height: 2rem; /* 32px */
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.375rem; /* rounded-md */
            font-size: 1rem; /* Adjust emoji size */
            line-height: 1;
            background-color: #e2e8f0; /* gray-200 */
            color: #4b5563; /* gray-700 */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }
        .history-button-small:hover {
            background-color: #cbd5e0; /* gray-300 */
        }
        .history-button-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="h-screen bg-gray-100 flex flex-col items-center p-4 sm:p-6 md:p-8">

    <div id="messageDisplay" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md transition-opacity duration-500 opacity-0 z-1000 hidden"></div>

    <!-- Undo/Redo buttons moved to top-right -->
    <div class="fixed top-4 right-4 z-50 flex space-x-2">
        <button id="undoBtn" class="history-button-small">‚Ü©Ô∏è</button>
        <button id="redoBtn" class="history-button-small">‚Ü™Ô∏è</button>
    </div>

    <div class="flex w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow flex-grow-container">
        <div id="staticToolbox">
            <div class="flex flex-col space-y-4">
                <div class="toolbox-section">
                    <h2>Tools</h2>
                    <div class="flex flex-wrap gap-1">
                        <button id="pencilTool" class="tool-button bg-blue-600 text-white shadow-md">‚úèÔ∏è</button>
                        <button id="eraserTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü©π</button>
                        <button id="fillTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™£</button>
                        <button id="eyedropperTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üíâ</button>
                        <button id="panTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚úã</button>
                        <button id="textTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üÖ∞Ô∏è</button>
                        <button id="lassoTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™¢</button>
                        <button id="editTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚úÇÔ∏è</button>
                        <button id="resizeTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üìè</button>
                        <button id="stickerTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚ú®</button>
                    </div>
                    <div class="mt-4 flex items-center">
                        <input type="checkbox" id="stylusOnlyModeToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="stylusOnlyModeToggle" class="text-sm font-medium text-gray-700">Palm Rejection</label>
                        <span id="palmRejectionHelpIcon" class="help-icon">?</span>
                    </div>
                </div>

                <div class="toolbox-section">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#000000" class="rounded-lg border-2 border-gray-300 cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="brushSize">Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="opacitySlider">Opacity: <span id="opacityValue" class="font-bold">100%</span></label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div id="watercolorFlowSection" class="toolbox-section hidden">
                    <label for="flowSlider">Flow: <span id="flowValue" class="font-bold">50%</span></label>
                    <input type="range" id="flowSlider" min="0" max="100" value="50" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <h2>Background</h2>
                    <input type="file" id="uploadBackground" accept="image/*" class="hidden">
                    <button id="uploadBackgroundBtn" class="bg-upload-button w-full mb-2">
                        Upload Image
                    </button>
                    <button id="clearBackgroundBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm w-full">
                        Clear Background
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Frames</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="addFrame" class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-blue-600 text-sm">Add New</button>
                        <button id="deleteFrame" class="bg-red-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-red-600 text-sm">Delete</button>
                        <button id="duplicateFrame" class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-green-600 text-sm">Duplicate</button>
                        <button id="clearCurrentFrame" class="bg-orange-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-orange-600 text-sm">Clear Frame</button>
                    </div>
                </div>

                <!-- History section removed as buttons are moved -->
                <!--
                <div class="toolbox-section">
                    <h2>History</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="undoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü©Ô∏è Undo</button>
                        <button id="redoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü™Ô∏è Redo</button>
                    </div>
                </div>
                -->

                <div class="toolbox-section">
                    <h2>Project</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="saveProject" class="bg-indigo-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-indigo-600 text-sm">Save</button>
                        <button id="loadProject" class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-purple-600 text-sm">Load</button>
                        <button id="exportGif" class="bg-teal-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-teal-600 text-sm">
                            üñºÔ∏è Export GIF
                        </button>
                        <button id="customizeBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚öôÔ∏è Customize
                        </button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Ideas</h2>
                    <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-yellow-600 text-sm w-full">
                        ‚ú® Generate Idea
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Info</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="helpBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì Help
                        </button>
                        <button id="faqBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì FAQ
                        </button>
                        <button id="updatesBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ú® Updates
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="flex flex-col relative flex-grow p-4 sm:p-6">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                        üé¨
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200">
                        ‚è∏Ô∏è
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200">
                        üõë
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner max-h-24">
                <div id="timelineContainer" class="overflow-x-auto pb-2">
                    <div id="timeline" class="flex flex-nowrap space-x-2 items-center">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4 flex-shrink-0">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 flex-shrink-0">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 flex-shrink-0">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden flex-grow overflow-y-auto">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ùì Help & View Tips</h3>
            <div class="flex-grow overflow-y-auto pr-2">
                <p class="zoom-info mb-4">
                    If parts of the editor content appear cut off or you want to see more, you can adjust your browser's zoom level.
                </p>
                <ul class="zoom-info list-disc list-inside space-y-2">
                    <li>
                        <span class="font-semibold">Browser Zoom Out:</span>
                        <br>
                        <kbd>Cmd</kbd> + <kbd>-</kbd> (Mac)
                        <br>
                        <kbd>Ctrl</kbd> + <kbd>-</kbd> (Windows)
                    </li>
                    <li>
                        <span class="font-semibold">Browser Reset Zoom to 100%:</span>
                        <br>
                        <kbd>Cmd</kbd> + <kbd>0</kbd> (Mac)
                        <br>
                        <kbd>Ctrl</kbd> + <kbd>0</kbd> (Windows)
                    </li>
                    <li>
                        <span class="font-semibold">If browser zooming in and out doesn't work as expected, try setting your browser zoom to 150% and then refresh the page. This can sometimes resolve layout issues and bring the timeline back into view.</span>
                    </li>
                    <li>
                        <span class="font-semibold">Canvas Pan:</span> Click and drag with the "‚úã Hand" tool to pan.
                    </li>
                    <li>
                        <span class="font-semibold">Line Smoothness:</span> If lines appear jagged or pixelated (especially at smaller brush sizes or high canvas resolutions), ensure your browser's "image smoothing" is enabled. This feature is enabled by default in ToonStart to improve line quality.
                    </li>
                    <li>
                        <span class="font-semibold">Brush Selection:</span> Double-click the 'Pencil' tool to open a menu and choose between 'Brush', 'Pen', 'Pencil', and 'Watercolor' drawing styles. Each style offers a distinct drawing feel.
                    </li>
                    <li>
                        <span class="font-semibold">Opacity Control:</span> Use the 'Opacity' slider in the toolbox to adjust the transparency of your brush strokes.
                    </li>
                    <li>
                        <span class="font-semibold">Watercolor Flow:</span> When the 'Watercolor' tool is selected, a 'Flow' slider will appear. This controls how much the color spreads out and and accumulates with each stroke, mimicking real watercolor effects.
                    </li>
                    <li>
                        <span class="font-semibold">Text Tool:</span> Select the 'Text' tool (üÖ∞Ô∏è) to add text to your canvas. A modal will appear where you can type your text, choose font family, size, and style (bold/italic). Click 'Place Text' and then click on the canvas to position your text.
                    </li>
                    <li>
                        <span class="font-semibold">Lasso Tool (ü™¢):</span> Draw a freehand selection. Once the selection is made, it will be cut from the canvas. You must then use the 'Edit' or 'Resize' tools to manipulate it.
                    </li>
                    <li>
                        <span class="font-semibold">Edit Tool (‚úÇÔ∏è):</span> After using the Lasso tool, select the 'Edit' tool. Click and drag on the canvas to move your lassoed selection. Click again to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Resize Tool (üìè):</span> After using the Lasso tool, select the 'Resize' tool. A modal will appear allowing you to input new dimensions for your lassoed selection. After applying, click on the canvas to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Sticker Tool (‚ú®):</span> Select the 'Sticker' tool to open a menu of emojis. Choose an emoji and then click on the canvas to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Backgrounds:</span> Add static background images to your frames. These backgrounds will not move with the pan or lasso tools.
                        <ul>
                            <li><strong>Upload Image:</strong> Use your own image file.</li>
                            <li><strong>Clear Background:</strong> Remove the current background image.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="font-semibold">Edit (For text only):</span> This option is currently a placeholder for a future enhancement, as text is rasterized upon placement. This means once text is placed, it becomes part of the image and cannot be directly edited as text again.
                    </li>
                </ul>
            </div>
            <button id="closeHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close

            </button>
        </div>
    </div>

    <div id="palmRejectionHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">üñêÔ∏è What is Palm Rejection?</h3>
            <p class="text-gray-700 mb-4">
                When "Palm Rejection" is enabled, the drawing canvas will <strong>only respond to input from a digital pen or stylus</strong>.
            </p>
            <p class="text-gray-700 mb-4">
                Touches from your fingers or palm will be ignored, allowing you to rest your hand on the screen while drawing without making accidental marks.
            </p>
            <p class="text-gray-700 text-sm italic">
                Note: This feature relies on your device and browser accurately reporting stylus input. Passive styluses (rubber-tip) may still be detected as finger touches.
            </p>
            <button id="closePalmRejectionHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="updatesModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® ToonStart Updates</h3>
            <div id="updatesContent" class="text-gray-700 space-y-4 flex-grow overflow-y-auto">
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 31, 2025 - Backgrounds & No Layers</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Backgrounds:</strong> Added a new "Background" section in the toolbox.
                            <ul>
                                <li>Upload custom background images.</li>
                                <li>Clear the current background.</li>
                                <li>Backgrounds are fixed and do not move with the pan or lasso tools.</li>
                                <li>Background images automatically fit to the canvas size.</li>
                            </ul>
                        </li>
                        <li><strong>Layers Removed:</strong> The layer system has been removed for a simpler drawing experience.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 31, 2025 - Layers & Refined Stickers</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Layers:</strong> Added a full layer system! Each frame can now have multiple layers.
                            <ul>
                                <li>New "Layers" section in the toolbox with controls for adding, deleting, duplicating, clearing, and reordering layers.</li>
                                <li>Layer opacity slider for individual layers.</li>
                                <li>Drawing tools, text, and stickers now operate on the active layer.</li>
                            </ul>
                        </li>
                        <li><strong>Sticker Refinement:</strong> Curated the sticker collection to feature approximately 100 of the most commonly used and diverse emojis, ensuring no repeats.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Code Readability & Stickers</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Code Comments:</strong> Added extensive comments throughout the JavaScript code to explain logic, variables, and functions, improving readability and maintainability.</li>
                        <li><strong>HTML Comments:</strong> Added basic comments to HTML sections for better structure understanding.</li>
                        <li><strong>Sticker Tool (‚ú®):</strong> A new tool to add fun emoji stickers to your animation frames.</li>
                        <li><strong>Lasso/Edit/Resize Fixes:</strong> Resolved issues with object duplication, improved mouse alignment during moves, and ensured accurate display of pixel dimensions in the resize modal.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Separate Edit/Resize Tools for Lasso</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool (ü™¢):</strong> Now solely for drawing selections. Moving and resizing are handled by new dedicated tools.</li>
                        <li><strong>New Edit Tool (‚úÇÔ∏è):</strong> Move lassoed selections.</li>
                        <li><strong>New Resize Tool (üìè):</strong> Resize lassoed selections with precise dimensions.</li>
                        <li><strong>Help & Updates:</strong> Updated to reflect the new tool functionalities.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Enhanced Lasso Tool</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool Placement:</strong> Lassoed selections now require an explicit click to be placed on the canvas, giving you more control.</li>
                        <li><strong>Lasso Double-Click Options:</strong> Double-clicking the lasso tool now opens a menu with 'Move', 'Resize', and 'Edit (For text only)' options.</li>
                        <li><strong>Lasso Resize:</strong> You can now resize your lassoed selection by inputting new dimensions.</li>
                        <li><strong>Lasso Text Edit (Future):</strong> The 'Edit (For text only)' option is currently a placeholder for a future enhancement, as text is rasterized upon placement.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Movement Fix</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool:</strong> Corrected the behavior of the lasso tool so that selected areas now move precisely with the mouse/stylus and are placed accurately.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Fix & Fixed Help Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool Fix:</strong> Resolved issues where the lasso tool would clear the entire canvas. Now, only the selected area is cut and moved.</li>
                        <li><strong>Fixed Help Button:</strong> The "Close" button in the Help modal now remains fixed at the bottom, even when the content scrolls.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Tool Added</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool:</strong> A new tool (ü™¢) has been added, allowing you to draw freehand selections, cut them from the canvas, and then move and place them elsewhere.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Text Tool, Refined Watercolor, No Comments</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Text Tool:</strong> Added a new tool to place customizable text on the canvas, with options for font family, size, bold, and italic.</li>
                        <li><strong>Watercolor Flow Refinement:</strong> The 'Watercolor' tool now features an improved slow-spreading effect for more natural color accumulation.</li>
                        <li><strong>No Comments:</strong> All comments have been removed from the code for a cleaner, more human-written aesthetic.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - No Comments & Draggable Frames</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Comments Removed:</strong> All code comments (`/* */` and `//`) have been removed for a cleaner, more human-written aesthetic.</li>
                        <li><strong>Draggable Frames:</strong> You can now drag and drop frames in the timeline to easily reorder them.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Refined Watercolor Flow & Comment Style</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Watercolor Flow:</strong> Enhanced the 'Watercolor' tool to provide a more natural, spreading effect with gradual color accumulation.</li>
                        <li><strong>Comment Style:</strong> Replaced all block comments (`/* ... */`) with single-line comments (`// ...`) for a more human-written code aesthetic.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Opacity & Watercolor Flow</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Opacity Slider:</strong> Added a new slider to control the general transparency of all drawing tools.</li>
                        <li><strong>Watercolor Tool:</strong> Introduced a new 'Watercolor' brush type in the double-click menu.</li>
                        <li><strong>Flow Slider:</strong> A 'Flow' slider now appears when the 'Watercolor' tool is active, allowing for natural color accumulation in strokes.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Fixed Modal Scrolling</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Modal Scrolling:</strong> The "Generate Idea" and "Updates" modals now correctly handle long content by allowing the content to scroll while keeping the "Close" button fixed at the bottom.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Brush Selection Persistence Fix</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Selection:</strong> Fixed an issue where the selected brush type (Brush, Pen, or Pencil) wasn't consistently active after choosing it from the double-click menu. Your brush choice will now stick!</li>
                        <li><strong>Pencil Tool Behavior:</strong> The main 'Pencil' tool button in the sidebar will now *only* open the brush selection menu on double-click, preventing accidental changes to your brush type.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Improved Brush Selection Highlight</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Clearer Selection:</strong> When you open the brush selection menu, the currently active brush style (Brush, Pen, or Pencil) will now be clearly highlighted, making it easier to see your current choice.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Enhanced Brush Styles & Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Behavior:</strong> The 'Brush', 'Pen', and 'Pencil' tools now have distinct drawing feels:
                            <ul>
                                <li>'Pencil' offers a light, sketchy line.</li>
                                <li>'Pen' draws a solid, straightforward line.</li>
                                <li>'Brush' provides a slightly softer, more "painterly" stroke.</li>
                            </ul>
                        </li>
                        <li><strong>Tool Selection Reliability:</strong> Fixed an issue where selecting a brush type from the double-click menu wasn't consistently applying the chosen tool.</li>
                        <li><strong>Pencil Tool Feedback:</strong> The main 'Pencil' tool button will now stay highlighted whenever 'Brush', 'Pen', or 'Pencil' is the active drawing style.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Refined Brush Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Streamlined Tools:</strong> The main toolbox now features only the 'Pencil' tool for drawing.</li>
                        <li><strong>Intuitive Brush Menu:</strong> Double-clicking the 'Pencil' tool will bring up a menu, allowing you to select between 'Brush', 'Pen', and 'Pencil' drawing styles.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - New Brush Tools</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>New Brushes:</strong> Added 'Pen' and 'Pencil' tools for more drawing variety.</li>
                        <li><strong>Brush Selection Menu:</strong> Double-clicking the 'Pencil' tool now brings up a menu to easily switch between 'Brush', 'Pen', and 'Pencil' modes.</li>
                        <li><strong>Pencil Feel:</strong> The 'Pencil' tool now draws with a lighter, sketchier appearance.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Updated GIF Export Logic</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>GIF Export:</strong> Updated the GIF export logic to explicitly draw each frame onto a temporary canvas before adding it to the GIF, ensuring consistent output.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Improved Drawing Smoothness</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Shape & Diagonal Lines:</strong> Fixed issues where circular brush strokes would appear square or jagged, especially on diagonals or after canvas resizing. Image smoothing is now explicitly enabled for both drawing and display contexts to ensure smoother line rendering.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Added FAQ Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>FAQ Button:</strong> Added a new "FAQ" button in the "Info" section linking to the help page.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Fixed Canvas Resizing</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Canvas Resizing:</strong> Lines and existing drawings now maintain their original thickness when resizing the project canvas.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Zoom Feature Removed</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature Removed:</strong> Zoom functionality has been removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 29, 2025 - Zoom Feature & UI Polish</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature:</strong> Added zoom functionality via scroll wheel and a dedicated slider in the new "Zoom & Pan" section.</li>
                        <li><strong>"Zoom & Pan" Section:</strong> New toolbox section for zoom and pan controls.</li>
                        <li><strong>Timeline Text Removed:</strong> "Timeline" heading removed as requested.</li>
                        <li><strong>Help Text Updated:</strong> Included instructions for the new zoom feature.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 28, 2025 - Canvas Resizing & UI Refinements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Canvas Resizing:</strong> Added ability to change project width and height in Customize modal. Existing frames scale proportionally.</li>
                        <li><strong>Customize Button Relocated:</b> Moved to the "Project" section for better organization.</li>
                        <li><strong>Onion Skinning Removed:</strong> Feature removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Layout & Drawing Stability</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Brush Offset:</strong> Drawing now consistently aligns with cursor regardless of timeline changes.</li>
                        <li><strong>Timeline Horizontal Scroll:</strong> Timeline now scrolls horizontally when many frames are added, preventing vertical layout shifts.</li>
                        <li><strong>Improved GIF Export:</strong> More reliable GIF generation due to consistent internal canvas dimensions.</li>
                        <li>**Help Text Updated:** Added a new tip regarding browser zoom and refreshing.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 25, 2025 - Critical Bug Fixes & Improvements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Drawing:</strong> Drawing tools now work correctly and responsively.</li>
                        <li><strong>Fixed Undo/Redo:</strong> History system is fully functional.</li>
                        <li><strong>Fixed Generate Idea:</strong> AI idea generator now works as expected.</li>
                        <li><strong>Fixed Updates Button:</strong> The updates modal now opens correctly.</li>
                        <li><strong>Restored Message Display:</strong> Temporary on-screen messages are back for user feedback.</li>
                        <li><strong>Fixed Fill Tool:</strong> Now accurately fills areas regardless of pan.</li>
                        <li><strong>Fixed Eyedropper Tool:</strong> Accurately picks colors from the canvas.</li>
                        <li>**Enhanced Responsiveness:** Significant performance improvements for drawing and canvas interactions.</li>
                        <li>**Removed Zoom Feature:** Canvas no longer supports zoom, focusing on direct drawing.</li>
                        <li>**Pipette Icon Update:** Changed to üíâ emoji.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 23, 2025 - Initial Feature Enhancements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Undo/Redo History:</strong> Easily correct mistakes with multiple steps.</li>
                        <li><strong>Pan Tool:</strong> Navigate the canvas for detailed work or overview.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 22, 2025 - Basic Drawing & Animation</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Basic Drawing Tools:</strong> Brush, Eraser, Fill.</li>
                        <li><strong>Frame Management:</strong> Add, delete, duplicate, clear frames.</li>
                        <li><strong>Animation Playback:</strong> Play, pause, stop animation with adjustable speed.</li>
                        <li><strong>Project Save/Load:</strong> Save and load your animation projects locally.</li>
                        <li><strong>GIF Export:</strong> Export your animation as a GIF.</li>
                        <li><strong>AI Idea Generator:</strong> Get creative ideas for your frames.</li>
                        <li><strong>Touch Support:</strong> Basic drawing on touch devices like iPad.</li>
                        <li><strong>Palm Rejection:</strong> Option to enable stylus-only drawing.</li>
                    </ul>
                </div>
            </div>
            <button id="closeUpdatesModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="customizeModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚öôÔ∏è Customize Editor</h3>
            <div class="space-y-4">
                <div>
                    <label for="projectWidth" class="block text-sm font-medium text-gray-700">Project Width (px):</label>
                    <input type="number" id="projectWidth" min="100" max="2000" value="800"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="projectHeight" class="block text-sm font-medium text-gray-700">Project Height (px):</label>
                    <input type="number" id="projectHeight" min="100" max="1500" value="600"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyCanvasSizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Canvas Size
                </button>
                <button id="resetCanvasSizeBtn" class="w-full bg-gray-300 text-gray-800 px-4 py-2 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Reset to Default (800x600)
                </button>
            </div>
            <button id="closeCustomizeModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="brushSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-xs">
            <h3 class="text-xl font-bold text-gray-800 mb-4 text-center">Choose Brush</h3>
            <div class="flex flex-col space-y-3">
                <button id="selectBrushTool" class="bg-blue-500 text-white px-4 py-2 rounded-lg shadow-sm hover:bg-blue-600">Brush</button>
                <button id="selectPenTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pen</button>
                <button id="selectPencilTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pencil</button>
                <button id="selectWatercolorTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Watercolor</button>
            </div>
            <button id="closeBrushSelectionModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="textToolModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">üÖ∞Ô∏è Add Text</h3>
            <textarea id="textInput" class="w-full p-3 border border-gray-300 rounded-lg mb-4 h-24 resize-y focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Type your text here..."></textarea>
            
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <div class="flex-1">
                    <label for="fontFamilySelect" class="block text-sm font-medium text-gray-700">Font Family:</label>
                    <select id="fontFamilySelect" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="Inter, sans-serif">Inter</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Courier New, monospace">Courier New</option>
                        <option value="Comic Sans MS, cursive">Comic Sans MS</option>
                    </select>
                </div>
                <div class="flex-1">
                    <label for="fontSizeInput" class="block text-sm font-medium text-gray-700">Font Size (px):</label>
                    <input type="number" id="fontSizeInput" min="10" max="200" value="30" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>

            <div class="flex gap-4 mb-4">
                <div class="flex items-center">
                    <input type="checkbox" id="fontBoldToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                    <label for="fontBoldToggle" class="text-sm font-medium text-gray-700">Bold</label>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="fontItalicToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                    <label for="fontItalicToggle" class="text-sm font-medium text-gray-700">Italic</label>
                </div>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Text Preview:</label>
                <canvas id="textPreviewCanvas" class="w-full border border-gray-300 rounded-lg bg-gray-50" width="400" height="100"></canvas>
            </div>

            <div class="flex gap-4 mt-auto">
                <button id="placeTextBtn" class="flex-1 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Place Text
                </button>
                <button id="cancelTextBtn" class="flex-1 bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <div id="resizeSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Resize Selection</h3>
            <div class="space-y-4">
                <div>
                    <label for="resizeWidth" class="block text-sm font-medium text-gray-700">New Width (px):</label>
                    <input type="number" id="resizeWidth" min="1" value="100"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="resizeHeight" class="block text-sm font-medium text-gray-700">New Height (px):</label>
                    <input type="number" id="resizeHeight" min="1" value="100"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyResizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Resize
                </button>
            </div>
            <button id="cancelResizeBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Cancel
            </button>
        </div>
    </div>

    <div id="stickerSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-lg flex flex-col">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Choose a Sticker</h3>
            <div id="stickerContainer" class="grid grid-cols-5 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2 overflow-y-auto max-h-96 pb-4">
            </div>
            <button id="closeStickerSelectionModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <!-- Mobile App Prompt Modal -->
    <div id="mobileAppPromptModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm text-center">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">üëã You're on mobile!</h3>
            <p class="text-gray-700 mb-6">
                Do you want to download the ToonStart app for a better experience?
            </p>
            <div class="flex flex-col space-y-4">
                <button id="continueWebBtn" class="bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Continue on Web
                </button>
                <button id="downloadAppBtn" class="bg-green-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-green-700 transition-colors duration-200">
                    Download App
                </button>
            </div>
        </div>
    </div>

    <!-- New floating button for in-app install -->
    <button id="installAppInAppBtn" class="hidden">
        Install ToonStart App
    </button>

    <script>
        const mainCanvas = document.getElementById('drawingCanvas');
        const mainCtx = mainCanvas.getContext('2d');

        const bufferCanvas = document.createElement('canvas');
        const bufferCtx = bufferCanvas.getContext('2d');

        let projWidth = 800;
        let projHeight = 600;

        const msgDisplay = document.getElementById('messageDisplay');

        const pencilToolBtn = document.getElementById('pencilTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const eyedropperToolBtn = document.getElementById('eyedropperTool');
        const panToolBtn = document.getElementById('panTool');
        const textToolBtn = document.getElementById('textTool');
        const lassoToolBtn = document.getElementById('lassoTool');
        const editToolBtn = document.getElementById('editTool');
        const resizeToolBtn = document.getElementById('resizeTool');
        const stickerToolBtn = document.getElementById('stickerTool');

        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValueSpan = document.getElementById('opacityValue');
        const watercolorFlowSection = document.getElementById('watercolorFlowSection');
        const flowSlider = document.getElementById('flowSlider');
        const flowValueSpan = document.getElementById('flowValue');

        const stylusOnlyModeToggle = document.getElementById('stylusOnlyModeToggle');
        let isStylusOnlyModeEnabled = false;

        const uploadBackgroundInput = document.getElementById('uploadBackground');
        const uploadBackgroundBtn = document.getElementById('uploadBackgroundBtn');
        const clearBackgroundBtn = document.getElementById('clearBackgroundBtn');

        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');

        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animSpeedInput = document.getElementById('animationSpeed');
        const animSpeedValueSpan = document.getElementById('animationSpeedValue');

        const timelineDiv = document.getElementById('timeline');
        const timelineContainer = document.getElementById('timelineContainer');

        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');

        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
        const faqBtn = document.getElementById('faqBtn');
        const updatesBtn = document.getElementById('updatesBtn');
        const updatesModal = document.getElementById('updatesModal');
        const closeUpdatesModalBtn = document.getElementById('closeUpdatesModalBtn');

        const palmRejectionHelpIcon = document.getElementById('palmRejectionHelpIcon');
        const palmRejectionHelpModal = document.getElementById('palmRejectionHelpModal');
        const closePalmRejectionHelpModalBtn = document.getElementById('closePalmRejectionHelpModalBtn');

        const customizeBtn = document.getElementById('customizeBtn');
        const customizeModal = document.getElementById('customizeModal');
        const closeCustomizeModalBtn = document.getElementById('closeCustomizeModalBtn');
        const projectWidthInput = document.getElementById('projectWidth');
        const projectHeightInput = document.getElementById('projectHeight');
        const applyCanvasSizeBtn = document.getElementById('applyCanvasSizeBtn');
        const resetCanvasSizeBtn = document.getElementById('resetCanvasSizeBtn');

        const brushSelectionModal = document.getElementById('brushSelectionModal');
        const selectBrushToolBtn = document.getElementById('selectBrushTool');
        const selectPenToolBtn = document.getElementById('selectPenTool');
        const selectPencilToolBtn = document.getElementById('selectPencilTool');
        const selectWatercolorToolBtn = document.getElementById('selectWatercolorTool');
        const closeBrushSelectionModalBtn = document.getElementById('closeBrushSelectionModalBtn');

        const textToolModal = document.getElementById('textToolModal');
        const textInput = document.getElementById('textInput');
        const fontFamilySelect = document.getElementById('fontFamilySelect');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const fontBoldToggle = document.getElementById('fontBoldToggle');
        const fontItalicToggle = document.getElementById('fontItalicToggle');
        const textPreviewCanvas = document.getElementById('textPreviewCanvas');
        const textPreviewCtx = textPreviewCanvas.getContext('2d');
        const placeTextBtn = document.getElementById('placeTextBtn');
        const cancelTextBtn = document.getElementById('cancelTextBtn');

        const resizeSelectionModal = document.getElementById('resizeSelectionModal');
        const resizeWidthInput = document.getElementById('resizeWidth');
        const resizeHeightInput = document.getElementById('resizeHeight');
        const applyResizeBtn = document.getElementById('applyResizeBtn');
        const cancelResizeBtn = document.getElementById('cancelResizeBtn');

        const stickerSelectionModal = document.getElementById('stickerSelectionModal');
        const stickerContainer = document.getElementById('stickerContainer');
        const closeStickerSelectionModalBtn = document.getElementById('closeStickerSelectionModalBtn');

        // Mobile App Prompt elements
        const mobileAppPromptModal = document.getElementById('mobileAppPromptModal');
        const continueWebBtn = document.getElementById('continueWebBtn');
        const downloadAppBtn = document.getElementById('downloadAppBtn');

        // New in-app install button
        const installAppInAppBtn = document.getElementById('installAppInAppBtn');

        // Undo/Redo buttons (now global, not in toolbox)
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');


        let drawingActive = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let currentOpacity = 100;
        let watercolorFlow = 50;
        let currentTool = 'brush';

        let framesData = [];
        let currentFrameIdx = 0;

        let animPlaying = false;
        let fps = 10;
        let animInterval = null;

        let exporting = false;
        let exportProg = 0;

        let historyStates = [];
        let historyPtr = -1;
        const MAX_HISTORY_STATES = 50;

        let panOffset = { x: 0, y: 0 };
        let panningActive = false;
        let lastPanPt = { x: 0, y: 0 };

        const imageCache = new Map();

        let draggedFrameIndex = null;

        let awaitingTextPlacement = false;
        let textToPlace = '';
        let textFont = '';

        let lassoPoints = [];
        let isLassoing = false;
        let selectedImageData = null;
        let isMovingSelection = false;
        let selectionOffset = { x: 0, y: 0 };
        let selectionStartProjectPoint = { x: 0, y: 0 };
        let initialSelectionOffsetAtDragStart = { x: 0, y: 0 };

        let awaitingStickerPlacement = false;
        let stickerToPlace = null;

        // For mobile tap gestures
        let lastTapTime = 0;
        let tapCount = 0;
        const TAP_TIMEOUT = 300; // ms to detect multiple taps

        const availableStickers = [
            { emoji: 'üòÄ', size: 50 }, { emoji: 'üòÇ', size: 50 }, { emoji: 'üòç', size: 50 },
            { emoji: 'ü§©', size: 50 }, { emoji: 'ü•≥', size: 50 }, { emoji: 'üòá', size: 50 },
            { emoji: 'üòé', size: 50 }, { emoji: 'ü§ì', size: 50 }, { emoji: 'ü§î', size: 50 },
            { emoji: 'üòè', size: 50 }, { emoji: 'ü•∫', size: 50 }, { emoji: 'ü§Ø', size: 50 },
            { emoji: 'üëç', size: 50 }, { emoji: '‚ù§Ô∏è', size: 50 }, { emoji: 'üåü', size: 50 },
            { emoji: 'üåà', size: 50 }, { emoji: 'üöÄ', size: 50 }, { emoji: 'üí°', size: 50 },
            { emoji: 'üéâ', size: 50 }, { emoji: 'üî•', size: 50 }, { emoji: 'üíØ', size: 50 },
            { emoji: '‚úÖ', size: 50 }, { emoji: 'üé∂', size: 50 }, { emoji: 'üê±', size: 50 },
            { emoji: 'üê∂', size: 50 }, { emoji: 'üêº', size: 50 }, { emoji: 'üçé', size: 50 },
            { emoji: 'üçï', size: 50 }, { emoji: '‚òï', size: 50 }, { emoji: 'üéà', size: 50 },
            { emoji: 'üå∏', size: 50 }, { emoji: 'üåº', size: 50 }, { emoji: 'üåª', size: 50 },
            { emoji: 'üçÄ', size: 50 }, { emoji: 'üçÑ', size: 50 }, { emoji: 'üçÇ', size: 50 },
            { emoji: 'üçÅ', size: 50 }, { emoji: '‚ùÑÔ∏è', size: 50 }, { emoji: '‚òÄÔ∏è', size: 50 },
            { emoji: '‚ö°', size: 50 }, { emoji: '‚òÅÔ∏è', size: 50 }, { emoji: '‚òî', size: 50 },
            { emoji: 'üåô', size: 50 }, { emoji: 'üåç', size: 50 }, { emoji: 'üåä', size: 50 },
            { emoji: 'üå≤', size: 50 }, { emoji: 'üå≥', size: 50 }, { emoji: 'üåµ', size: 50 },
            { emoji: 'üå∑', size: 50 }, { emoji: 'üåπ', size: 50 }, { emoji: 'üå∫', size: 50 },
            { emoji: 'üåæ', size: 50 }, { emoji: 'üå∞', size: 50 }, { emoji: 'üçá', size: 50 },
            { emoji: 'üçâ', size: 50 }, { emoji: 'üçä', size: 50 }, { emoji: 'üçã', size: 50 },
            { emoji: 'üçå', size: 50 }, { emoji: 'üçç', size: 50 }, { emoji: 'ü•≠', size: 50 },
            { emoji: 'üçì', size: 50 }, { emoji: 'üçí', size: 50 }, { emoji: 'üçë', size: 50 },
            { emoji: 'ü•ù', size: 50 }, { emoji: 'ü•ë', size: 50 }, { emoji: 'ü•¶', size: 50 },
            { emoji: 'ü•ï', size: 50 }, { emoji: 'üå∂Ô∏è', size: 50 }, { emoji: 'ü•î', size: 50 },
            { emoji: 'üåΩ', size: 50 }, { emoji: 'üçû', size: 50 }, { emoji: 'ü•ê', size: 50 },
            { emoji: 'ü•®', size: 50 }, { emoji: 'üßÄ', size: 50 }, { emoji: 'ü•ö', size: 50 },
            { emoji: 'üç≥', size: 50 }, { emoji: 'ü•ì', size: 50 }, { emoji: 'üçî', size: 50 },
            { emoji: 'üçü', size: 50 }, { emoji: 'üå≠', size: 50 }, { emoji: 'ü•™', size: 50 },
            { emoji: 'üåÆ', size: 50 }, { emoji: 'üåØ', size: 50 }, { emoji: 'ü•ô', size: 50 },
            { emoji: 'ÔøΩ', size: 50 }, { emoji: 'üç©', size: 50 }, { emoji: 'üç™', size: 50 },
            { emoji: 'üéÇ', size: 50 }, { emoji: 'üç∞', size: 50 }, { emoji: 'üßÅ', size: 50 },
            { emoji: 'ü•ß', size: 50 }, { emoji: 'üç´', size: 50 }, { emoji: 'üç¨', size: 50 },
            { emoji: 'üç≠', size: 50 }, { emoji: 'üçÆ', size: 50 }, { emoji: 'üçØ', size: 50 },
            { emoji: 'ü•õ', size: 50 }, { emoji: '‚òï', size: 50 }, { emoji: 'üçµ', size: 50 },
            { emoji: 'üç∂', size: 50 }, { emoji: 'üçæ', size: 50 }, { emoji: 'üç∑', size: 50 },
            { emoji: 'üç∏', size: 50 }, { emoji: 'üçπ', size: 50 }, { emoji: 'üç∫', size: 50 },
            { emoji: 'üçª', size: 50 }, { emoji: 'ü•Ç', size: 50 }, { emoji: 'ü•É', size: 50 },
            { emoji: 'ü•§', size: 50 }, { emoji: 'üßã', size: 50 }, { emoji: 'üöó', size: 50 },
            { emoji: 'üöï', size: 50 }, { emoji: 'üöô', size: 50 }, { emoji: 'üöå', size: 50 },
            { emoji: 'üèéÔ∏è', size: 50 }, { emoji: 'üöì', size: 50 }, { emoji: 'üöë', size: 50 },
            { emoji: 'üöí', size: 50 }, { emoji: 'üöê', size: 50 }, { emoji: 'üöö', size: 50 },
            { emoji: 'üöõ', size: 50 }, { emoji: 'üöú', size: 50 }, { emoji: 'üö≤', size: 50 },
            { emoji: 'üõ¥', size: 50 }, { emoji: 'üõµ', size: 50 }, { emoji: 'üèçÔ∏è', size: 50 },
            { emoji: 'üö®', size: 50 }, { emoji: 'üöî', size: 50 }, { emoji: 'üöç', size: 50 },
            { emoji: 'üöò', size: 50 }, { emoji: 'üöñ', size: 50 }, { emoji: 'üöÜ', size: 50 },
            { emoji: 'üöá', size: 50 }, { emoji: 'üöà', size: 50 }, { emoji: 'üöâ', size: 50 },
            { emoji: 'üöä', size: 50 }, { emoji: 'üöÉ', size: 50 }, { emoji: 'üöã', size: 50 },
            { emoji: 'üöÑ', size: 50 }, { emoji: 'üöÖ', size: 50 }, { emoji: 'üöÇ', size: 50 },
            { emoji: 'üöÜ', size: 50 }, { emoji: 'üöá', size: 50 }, { emoji: 'üöà', size: 50 },
            { emoji: 'üöâ', size: 50 }, { emoji: 'üöä', size: 50 }, { emoji: 'üöÉ', size: 50 },
            { emoji: 'üöã', size: 50 }, { emoji: 'üöù', size: 50 }, { emoji: 'üöû', size: 50 },
            { emoji: 'üöü', size: 50 }, { emoji: 'üö†', size: 50 }, { emoji: 'üö°', size: 50 },
            { emoji: 'üö¢', size: 50 }, { emoji: 'üõ•Ô∏è', size: 50 }, { emoji: 'üö§', size: 50 },
            { emoji: '‚õ¥Ô∏è', size: 50 }, { emoji: '‚öì', size: 50 }, { emoji: 'üöÄ', size: 50 },
            { emoji: '‚úàÔ∏è', size: 50 }, { emoji: 'üõ´', size: 50 }, { emoji: 'üõ¨', size: 50 },
            { emoji: 'üí∫', size: 50 }, { emoji: 'üöÅ', size: 50 }, { emoji: 'üõ∞Ô∏è', size: 50 },
            { emoji: 'üõ∏', size: 50 }, { emoji: 'üè†', size: 50 }, { emoji: 'üè°', size: 50 },
            { emoji: 'üèòÔ∏è', size: 50 }, { emoji: 'üè¢', size: 50 }, { emoji: 'üè£', size: 50 },
            { emoji: 'üè§', size: 50 }, { emoji: 'üè•', size: 50 }, { emoji: 'üè¶', size: 50 },
            { emoji: 'üè®', size: 50 }, { emoji: 'üè©', size: 50 }, { emoji: 'üè™', size: 50 },
            { emoji: 'üè´', size: 50 }, { emoji: 'üè¨', size: 50 }, { emoji: 'üè≠', size: 50 },
            { emoji: 'üèØ', size: 50 }, { emoji: 'üè∞', size: 50 }, { emoji: 'üíí', size: 50 },
            { emoji: 'üóº', size: 50 }, { emoji: 'üóΩ', size: 50 }, { emoji: '‚õ™', size: 50 },
            { emoji: 'üïå', size: 50 }, { emoji: 'üõï', size: 50 }, { emoji: 'üïç', size: 50 },
            { emoji: '‚õ©Ô∏è', size: 50 }, { emoji: 'üïã', size: 50 }, { emoji: ' fountain', size: 50 },
            { emoji: '‚õ≤', size: 50 }, { emoji: '‚õ∫', size: 50 }, { emoji: 'üèïÔ∏è', size: 50 },
            { emoji: 'üèûÔ∏è', size: 50 }, { emoji: 'üõ£Ô∏è', size: 50 }, { emoji: 'üõ§Ô∏è', size: 50 },
            { emoji: 'üåÖ', size: 50 }, { emoji: 'üåÑ', size: 50 }, { emoji: 'üåá', size: 50 },
            { emoji: 'üåÜ', size: 50 }, { emoji: 'üåÉ', size: 50 }, { emoji: 'üåâ', size: 50 },
            { emoji: 'üåÅ', size: 50 }, { emoji: 'üó∫Ô∏è', size: 50 }, { emoji: 'üóæ', size: 50 },
            { emoji: 'üß≠', size: 50 }
        ];

        function showUserMessage(msg) {
            if (msgDisplay._timeoutId) {
                clearTimeout(msgDisplay._timeoutId);
            }
            msgDisplay.textContent = msg;
            msgDisplay.classList.remove('hidden', 'opacity-0');
            msgDisplay.classList.add('opacity-100');

            msgDisplay._timeoutId = setTimeout(() => {
                msgDisplay.classList.remove('opacity-100');
                msgDisplay._timeoutId = setTimeout(() => msgDisplay.classList.add('hidden'), 500);
            }, 2000);
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function rgbaToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function loadImage(src) {
            if (imageCache.has(src)) {
                return Promise.resolve(imageCache.get(src));
            }
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache.set(src, img);
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        function saveStateToHistory() {
            if (historyPtr < historyStates.length - 1) {
                historyStates = historyStates.slice(0, historyPtr + 1);
            }
            historyStates.push(JSON.parse(JSON.stringify(framesData)));
            historyPtr++;

            if (historyStates.length > MAX_HISTORY_STATES) {
                historyStates.shift();
                historyPtr--;
            }
            updateUndoRedoButtons();
        }

        function performUndo() {
            if (historyPtr > 0) {
                historyPtr--;
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr]));
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateBackgroundButtons();
                updateUndoRedoButtons();
                showUserMessage('Undo successful!');
            }
        }

        function performRedo() {
            if (historyPtr < historyStates.length - 1) {
                historyPtr++;
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr]));
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateBackgroundButtons();
                updateUndoRedoButtons();
                showUserMessage('Redo successful!');
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = !(historyPtr > 0);
            redoBtn.disabled = !(historyPtr < historyStates.length - 1);
        }

        async function loadFrameIntoBuffer() {
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const currentFrameDrawingData = framesData[currentFrameIdx].imageData;

            if (currentFrameDrawingData && typeof currentFrameDrawingData === 'string' && currentFrameDrawingData.startsWith('data:image/png;base64,')) {
                try {
                    const img = imageCache.get(currentFrameDrawingData) || await loadImage(currentFrameDrawingData);
                    bufferCtx.drawImage(img, 0, 0, bufferCanvas.width, bufferCanvas.height);
                } catch (error) {
                    console.error("Oops, couldn't load frame drawing data into the buffer:", error);
                }
            }
        }

        async function renderCanvasDisplay() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            mainCtx.fillStyle = '#ffffff';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            const currentFrame = framesData[currentFrameIdx];

            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            const offsetX = (mainCanvas.width - displayContentWidth) / 2;
            const offsetY = (mainCanvas.height - displayContentHeight) / 2;

            if (currentFrame && currentFrame.background) {
                try {
                    const bgImg = imageCache.get(currentFrame.background) || await loadImage(currentFrame.background);
                    mainCtx.drawImage(bgImg, offsetX, offsetY, displayContentWidth, displayContentHeight);
                } catch (error) {
                    console.error("Error loading background image:", error);
                }
            }

            mainCtx.save();
            mainCtx.translate(panOffset.x, panOffset.y);
            mainCtx.globalAlpha = 1.0;
            mainCtx.globalCompositeOperation = 'source-over';
            mainCtx.drawImage(bufferCanvas, offsetX, offsetY, displayContentWidth, displayContentHeight);

            if (currentTool === 'lasso' && isLassoing && lassoPoints.length > 1) {
                mainCtx.save();
                mainCtx.strokeStyle = 'blue';
                mainCtx.lineWidth = 2;
                mainCtx.setLineDash([5, 5]);
                mainCtx.beginPath();
                const firstPoint = getDisplayCoords(lassoPoints[0].x, lassoPoints[0].y);
                mainCtx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    const point = getDisplayCoords(lassoPoints[i].x, lassoPoints[i].y);
                    mainCtx.lineTo(point.x, point.y);
                }
                mainCtx.stroke();
                mainCtx.restore();
            }

            if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection && selectedImageData) {
                mainCtx.save();
                mainCtx.globalAlpha = 0.8;
                const displaySelectionX = (selectionOffset.x * displayContentWidth / projWidth) + offsetX;
                const displaySelectionY = (selectionOffset.y * displayContentHeight / projHeight) + offsetY;
                
                const displaySelectionWidth = selectedImageData.width * displayContentWidth / projWidth;
                const displaySelectionHeight = selectedImageData.height * displayContentHeight / projHeight;

                mainCtx.drawImage(selectedImageData, displaySelectionX, displaySelectionY, displaySelectionWidth, displaySelectionHeight);
                mainCtx.restore();
            }

            mainCtx.strokeStyle = '#888888';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]);
            mainCtx.strokeRect(offsetX, offsetY, displayContentWidth, displayContentHeight);
            mainCtx.setLineDash([]);

            mainCtx.restore();
            mainCtx.globalAlpha = 1.0;
            mainCtx.globalCompositeOperation = 'source-over';
        }

        function saveCurrentFrameDrawingData() {
            if (!framesData[currentFrameIdx]) {
                console.error("No current frame to save drawing data to.");
                return;
            }
            framesData[currentFrameIdx].imageData = bufferCanvas.toDataURL('image/png');
        }

        function getTransformedDrawingCoords(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            const displayOffsetX = (mainCanvas.width - displayContentWidth) / 2;
            const displayOffsetY = (mainCanvas.height - displayContentHeight) / 2;

            const transformedX = (canvasX - panOffset.x - displayOffsetX);
            const transformedY = (canvasY - panOffset.y - displayOffsetY);

            const x = transformedX * (projWidth / displayContentWidth);
            const y = transformedY * (projHeight / displayContentHeight);

            return { x, y };
        }

        async function handleInteractionStart(e) {
            e.preventDefault();

            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    drawingActive = false;
                    return;
                }
            }

            if (currentTool === 'eyedropper') {
                const rect = mainCanvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                const imageData = mainCtx.getImageData(canvasX, canvasY, 1, 1).data;
                brushColor = rgbaToHex(imageData[0], imageData[1], imageData[2]);
                brushColorInput.value = brushColor;
                bufferCtx.strokeStyle = brushColor;
                
                currentTool = 'brush';
                updateToolButtonStates();
                showUserMessage('Color picked!');
                return;
            }

            if (currentTool === 'pan') {
                panningActive = true;
                lastPanPt = { x: clientX, y: clientY };
                return;
            }

            if (currentTool === 'fill') {
                await loadFrameIntoBuffer();
                const { x, y } = getTransformedDrawingCoords(clientX, clientY);
                floodFill(x, y, hexToRgba(brushColor), bufferCtx, bufferCanvas.width, bufferCanvas.height);
                saveCurrentFrameDrawingData();
                renderCanvasDisplay();
                saveStateToHistory();
                showUserMessage('Fill applied!');
                return;
            }

            if (currentTool === 'lasso') {
                await loadFrameIntoBuffer();
                lassoPoints = [];
                isLassoing = true;
                const { x, y } = getTransformedDrawingCoords(clientX, clientY);
                lassoPoints.push({ x, y });
                return;
            }

            if (currentTool === 'edit' || currentTool === 'resize') {
                if (selectedImageData) {
                    isMovingSelection = true;
                    selectionStartProjectPoint = getTransformedDrawingCoords(clientX, clientY);
                    initialSelectionOffsetAtDragStart = { x: selectionOffset.x, y: selectionOffset.y };
                    return;
                } else {
                    showUserMessage('No selection to move/resize. Use Lasso tool first.');
                    return;
                }
            }

            bufferCtx.lineCap = 'round';
            bufferCtx.lineJoin = 'round';
            bufferCtx.strokeStyle = brushColor;
            bufferCtx.lineWidth = brushSize;
            bufferCtx.globalCompositeOperation = 'source-over';

            bufferCtx.shadowBlur = 0;
            bufferCtx.shadowColor = 'transparent';

            if (currentTool === 'pencil') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 0.4;
            } else if (currentTool === 'brush') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 0.7;
            } else if (currentTool === 'pen') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 1.0;
            } else if (currentTool === 'watercolor') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                bufferCtx.shadowColor = brushColor;
                bufferCtx.shadowBlur = brushSize * (watercolorFlow / 100) * 0.7;
            }
            
            const { x, y } = getTransformedDrawingCoords(clientX, clientY);
            bufferCtx.beginPath();
            bufferCtx.moveTo(x, y);
            drawingActive = true;
        }

        async function handleInteractionMove(e) {
            e.preventDefault();

            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    drawingActive = false;
                    return;
                }
            }

            if (currentTool === 'pan' && panningActive) {
                const dx = clientX - lastPanPt.x;
                const dy = clientY - lastPanPt.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPt = { x: clientX, y: clientY };
                renderCanvasDisplay();
                return;
            }

            if (currentTool === 'lasso' && isLassoing) {
                const { x, y } = getTransformedDrawingCoords(clientX, clientY);
                lassoPoints.push({ x, y });
                renderCanvasDisplay();
                return;
            }

            if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection) {
                const currentProjectPoint = getTransformedDrawingCoords(clientX, clientY);

                const dx = currentProjectPoint.x - selectionStartProjectPoint.x;
                const dy = currentProjectPoint.y - selectionStartProjectPoint.y;

                selectionOffset.x = initialSelectionOffsetAtDragStart.x + dx;
                selectionOffset.y = initialSelectionOffsetAtDragStart.y + dy;

                renderCanvasDisplay();
                return;
            }

            if (!drawingActive) return;

            const { x, y } = getTransformedDrawingCoords(clientX, clientY);
            
            if (currentTool === 'eraser') {
                bufferCtx.globalCompositeOperation = 'destination-out';
            } else {
                bufferCtx.globalCompositeOperation = 'source-over';
            }

            bufferCtx.lineTo(x, y);
            bufferCtx.stroke();
            renderCanvasDisplay();
        }

        async function handleInteractionEnd(e) {
            e.preventDefault();

            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            // Tap gesture detection for mobile only
            if (e.touches && e.touches.length > 0 && !drawingActive && !panningActive) {
                const currentTime = new Date().getTime();
                const tapInterval = currentTime - lastTapTime;

                if (tapInterval < TAP_TIMEOUT && tapInterval > 0) { // Check for consecutive taps
                    tapCount++;
                } else {
                    tapCount = 1; // Start new tap count
                }
                lastTapTime = currentTime;

                if (tapCount === 2) {
                    // Double tap for Undo
                    setTimeout(() => { // Small delay to allow for triple tap detection
                        if (tapCount === 2) { // Confirm it's still 2 taps after delay
                            performUndo();
                            tapCount = 0; // Reset after action
                        }
                    }, TAP_TIMEOUT);
                } else if (tapCount === 3) {
                    // Triple tap for Redo
                    performRedo();
                    tapCount = 0; // Reset after action
                }
            }


            if (currentTool === 'lasso') {
                if (isLassoing) {
                    isLassoing = false;
                    if (lassoPoints.length > 2) {
                        await extractLassoSelection();
                        showUserMessage('Lasso selection made. Use the Edit tool to move/place, or Resize tool to change size.');
                    } else {
                        showUserMessage('Lasso selection too small. Try again.');
                    }
                    currentTool = 'brush';
                    updateToolButtonStates();
                    renderCanvasDisplay();
                    return;
                }
            }

            if (currentTool !== 'fill' && currentTool !== 'eyedropper' && currentTool !== 'pan' &&
                currentTool !== 'edit' && currentTool !== 'resize' && currentTool !== 'sticker') {
                if (drawingActive) {
                    bufferCtx.closePath();
                    bufferCtx.globalCompositeOperation = 'source-over';
                    bufferCtx.globalAlpha = 1.0;
                    bufferCtx.shadowBlur = 0;
                    bufferCtx.shadowColor = 'transparent';
                    saveCurrentFrameDrawingData();
                    saveStateToHistory();
                }
            }
            drawingActive = false;
            panningActive = false;

            if (!(currentTool === 'edit' || currentTool === 'resize')) {
                 renderCanvasDisplay();
            }
        }

        function floodFill(startX, startY, fillColor, ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            const getPixelColor = (x, y) => {
                if (x < 0 || x >= width || y < 0 || y >= height) return [-1, -1, -1, -1];
                const index = (y * width + x) * 4;
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            const setPixelColor = (x, y, color) => {
                const index = (y * width + x) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            const startColor = getPixelColor(Math.floor(startX), Math.floor(startY));

            if (startColor[0] === -1 || (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3])) {
                return;
            }

            const pixelStack = [[Math.floor(startX), Math.floor(startY)]];
            const visited = new Set();

            const colorsMatch = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x >= 0 && x < width && y >= 0 && y < height && colorsMatch(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor);

                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function updateTimelineDisplay() {
            timelineDiv.innerHTML = '';
            framesData.forEach((_, index) => {
                const frameButton = document.createElement('button');
                frameButton.textContent = `F${index + 1}`;
                frameButton.classList.add(
                    'frame-button', 'flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg',
                    'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold',
                    'transition-all', 'duration-200'
                );
                
                if (index === currentFrameIdx) {
                    frameButton.classList.add('border-blue-600', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                } else {
                    frameButton.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                }
                
                frameButton.onclick = () => {
                    if (animPlaying) pauseAnimationPlayback();
                    currentFrameIdx = index;
                    loadFrameIntoBuffer().then(renderCanvasDisplay);
                    updateTimelineDisplay();
                    updateBackgroundButtons();
                };

                frameButton.draggable = true;
                frameButton.dataset.frameIndex = index;

                frameButton.addEventListener('dragstart', handleDragStart);
                frameButton.addEventListener('dragover', handleDragOver);
                frameButton.addEventListener('dragenter', handleDragEnter);
                frameButton.addEventListener('dragleave', handleDragLeave);
                frameButton.addEventListener('drop', handleDrop);
                frameButton.addEventListener('dragend', handleDragEnd);

                timelineDiv.appendChild(frameButton);
            });
        }

        function handleDragStart(e) {
            draggedFrameIndex = parseInt(e.target.dataset.frameIndex);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedFrameIndex);
            e.target.classList.add('dragging');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (e.target.classList.contains('frame-button') && parseInt(e.target.dataset.frameIndex) !== draggedFrameIndex) {
                e.target.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const droppedOnIndex = parseInt(e.target.dataset.frameIndex);
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));

            if (draggedIndex === droppedOnIndex || isNaN(draggedIndex) || isNaN(droppedOnIndex)) {
                return;
            }

            const currentFrameContent = framesData[currentFrameIdx];

            const [draggedFrame] = framesData.splice(draggedIndex, 1);
            framesData.splice(droppedOnIndex, 0, draggedFrame);

            currentFrameIdx = framesData.indexOf(currentFrameContent);

            updateTimelineDisplay();
            loadFrameIntoBuffer().then(renderCanvasDisplay);
            saveStateToHistory();
            showUserMessage('Frame reordered!');
        }

        function handleDragEnd(e) {
            const frameButtons = timelineDiv.querySelectorAll('.frame-button');
            frameButtons.forEach(btn => {
                btn.classList.remove('dragging', 'drag-over');
            });
            draggedFrameIndex = null;
        }

        function addFrame() {
            saveCurrentFrameDrawingData();

            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const blankFrameDrawingData = bufferCanvas.toDataURL('image/png');

            const newFrame = {
                imageData: blankFrameDrawingData,
                background: null
            };

            framesData.splice(currentFrameIdx + 1, 0, newFrame);
            currentFrameIdx++;

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateBackgroundButtons();
            saveStateToHistory();
            showUserMessage('New frame added!');
        }

        function deleteFrame() {
            if (framesData.length <= 1) {
                showUserMessage('Cannot delete the last frame! You need at least one.');
                return;
            }
            framesData.splice(currentFrameIdx, 1);
            if (currentFrameIdx >= framesData.length) {
                currentFrameIdx = framesData.length - 1;
            }

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateBackgroundButtons();
            saveStateToHistory();
            showUserMessage('Frame deleted!');
        }

        function duplicateFrame() {
            saveCurrentFrameDrawingData();

            const currentFrame = framesData[currentFrameIdx];
            const duplicatedFrame = JSON.parse(JSON.stringify(currentFrame));

            framesData.splice(currentFrameIdx + 1, 0, duplicatedFrame);
            currentFrameIdx++;

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateBackgroundButtons();
            saveStateToHistory();
            showUserMessage('Frame duplicated!');
        }

        function clearCurrentFrame() {
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const blankFrameDrawingData = bufferCanvas.toDataURL('image/png');

            framesData[currentFrameIdx] = {
                imageData: blankFrameDrawingData,
                background: null
            };

            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateBackgroundButtons();
            saveStateToHistory();
            showUserMessage('Current frame cleared!');
        }

        function saveProject() {
            saveCurrentFrameDrawingData();
            localStorage.setItem('animationProject', JSON.stringify(framesData));
            localStorage.setItem('currentFrameIndex', currentFrameIdx.toString());
            localStorage.setItem('projectWidth', projWidth.toString());
            localStorage.setItem('projectHeight', projHeight.toString());
            localStorage.setItem('currentOpacity', currentOpacity.toString());
            localStorage.setItem('watercolorFlow', watercolorFlow.toString());
            showUserMessage('Animation project saved!');
        }

        function loadProject() {
            const savedProjectData = localStorage.getItem('animationProject');
            const savedActiveFrameIndex = localStorage.getItem('currentFrameIndex');
            const savedProjectWidth = localStorage.getItem('projectWidth');
            const savedProjectHeight = localStorage.getItem('projectHeight');
            const savedOpacity = localStorage.getItem('currentOpacity');
            const savedFlow = localStorage.getItem('watercolorFlow');

            if (!savedProjectData) {
                showUserMessage('No saved animation project found! Start drawing something new.');
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProjectData);
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    framesData = loadedFrames.map(frame => {
                        if (typeof frame === 'string') {
                            return { imageData: frame, background: null };
                        }
                        if (!frame.background) {
                            frame.background = null;
                        }
                        return frame;
                    });

                    currentFrameIdx = Math.min(parseInt(savedActiveFrameIndex, 10) || 0, framesData.length - 1);
                    
                    const newWidth = parseInt(savedProjectWidth, 10) || 800;
                    const newHeight = parseInt(savedProjectHeight, 10) || 600;
                    
                    if (newWidth !== projWidth || newHeight !== projHeight) {
                        projWidth = newWidth;
                        projHeight = newHeight;
                        projectWidthInput.value = projWidth;
                        projectHeightInput.value = projHeight;
                    }

                    currentOpacity = parseInt(savedOpacity, 10) || 100;
                    watercolorFlow = parseInt(savedFlow, 10) || 50;
                    opacitySlider.value = currentOpacity;
                    opacityValueSpan.textContent = `${currentOpacity}%`;
                    flowSlider.value = watercolorFlow;
                    flowValueSpan.textContent = `${watercolorFlow}%`;
                    
                    historyStates = [];
                    historyPtr = -1;
                    saveStateToHistory();
                    loadFrameIntoBuffer().then(renderCanvasDisplay);
                    updateTimelineDisplay();
                    updateBackgroundButtons();
                    showUserMessage('Animation project loaded successfully!');
                } else {
                    showUserMessage('Hmm, saved project data seems a bit off or empty.');
                }
            } catch (error) {
                console.error("Error trying to parse loaded project data:", error);
                showUserMessage('Something went wrong loading the project data.');
            }
        }

        function startAnimationPlayback() {
            if (framesData.length === 0) {
                showUserMessage('Can\'t play an animation with no frames!');
                return;
            }
            if (animPlaying) return;

            animPlaying = true;
            
            renderCanvasDisplay();

            const frameDelay = 1000 / fps;
            animInterval = setInterval(() => {
                currentFrameIdx = (currentFrameIdx + 1) % framesData.length;
                loadFrameIntoBuffer().then(renderCanvasDisplay);
                updateTimelineDisplay();
                updateBackgroundButtons();
            }, frameDelay);
            
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            showUserMessage('Playing animation...');
        }

        function pauseAnimationPlayback() {
            if (animInterval) {
                clearInterval(animInterval);
                animInterval = null;
            }
            animPlaying = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            showUserMessage('Animation paused.');
        }

        function stopAnimationPlayback() {
            pauseAnimationPlayback();
            currentFrameIdx = 0;
            loadFrameIntoBuffer().then(renderCanvasDisplay);
            updateTimelineDisplay();
            updateBackgroundButtons();
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            showUserMessage('Animation stopped.');
        }

        async function exportGifAnimation() {
            if (typeof GIF === 'undefined') {
                showUserMessage('GIF.js library not loaded. Cannot export GIF.');
                console.error('GIF.js is missing! Make sure the script is loaded.');
                return;
            }
            if (framesData.length === 0) {
                showUserMessage('Nothing to export! Add some frames first.');
                return;
            }

            exporting = true;
            exportProg = 0;
            exportGifBtn.textContent = 'Exporting GIF... 0%';
            exportGifBtn.disabled = true;
            showUserMessage('Generating GIF, this might take a moment...');

            const gifEncoder = new GIF({
                workers: 2,
                quality: 10,
                delay: 1000 / fps,
                width: projWidth,
                height: projHeight,
                background: '#ffffff'
            });

            const compositeCanvas = document.createElement('canvas');
            const compositeCtx = compositeCanvas.getContext('2d');
            compositeCanvas.width = projWidth;
            compositeCanvas.height = projHeight;
            compositeCtx.imageSmoothingEnabled = true;

            for (let i = 0; i < framesData.length; i++) {
                compositeCtx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
                compositeCtx.fillStyle = '#ffffff';
                compositeCtx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);

                const frameToExport = framesData[i];
                if (frameToExport.background) {
                    try {
                        const bgImg = await loadImage(frameToExport.background);
                        compositeCtx.drawImage(bgImg, 0, 0, projWidth, projHeight);
                    } catch (error) {
                        console.error(`Problem loading background for frame ${i} for GIF export:`, error);
                    }
                }

                if (frameToExport.imageData && frameToExport.imageData.startsWith('data:image/png;base64,')) {
                    try {
                        const img = await loadImage(frameToExport.imageData);
                        compositeCtx.drawImage(img, 0, 0, projWidth, projHeight);
                    } catch (error) {
                        console.error(`Problem loading drawing data for frame ${i} for GIF export:`, error);
                    }
                }
                gifEncoder.addFrame(compositeCtx, { copy: true, delay: 1000 / fps });
            }

            gifEncoder.on('progress', function(p) {
                exportProg = Math.floor(p * 100);
                exportGifBtn.textContent = `Exporting GIF... ${exportProg}%`;
            });

            gifEncoder.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const dlLink = document.createElement('a');
                dlLink.href = url;
                dlLink.download = 'animation.gif';
                document.body.appendChild(dlLink);
                dlLink.click();
                document.body.removeChild(dlLink);
                URL.revokeObjectURL(url);

                exporting = false;
                exportProg = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showUserMessage('GIF exported successfully!');
            });

            gifEncoder.on('error', function(error) {
                console.error('GIF generation failed:', error);
                exporting = false;
                exportProg = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showUserMessage('Error exporting GIF.');
            });

            gifEncoder.render();
        }

        async function generateFrameIdea() {
            const ideaPromptText = ideaPromptInput.value.trim();
            if (!ideaPromptText) {
                showUserMessage('Please type in a little prompt for the idea generator first!');
                return;
            }

            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden');
            ideaText.textContent = '';

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${ideaPromptText}". Keep it concise and focused on visual elements."` }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const aiIdeaText = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = aiIdeaText;
                    generatedIdeaOutput.classList.remove('hidden');
                    showUserMessage('Idea generated successfully!');
                } else {
                    ideaText.textContent = 'Couldn\'t quite generate an idea this time. Please try a different prompt!';
                    generatedIdeaOutput.classList.remove('hidden');
                    showUserMessage('Error generating idea.');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to a network or API error.';
                generatedIdeaOutput.classList.remove('hidden');
                showUserMessage('Error generating idea.');
            } finally {
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }

        function updateToolButtonStates() {
            const allToolButtons = [
                pencilToolBtn, eraserToolBtn, fillToolBtn, eyedropperToolBtn,
                panToolBtn, textToolBtn, lassoToolBtn, editToolBtn, resizeToolBtn,
                stickerToolBtn
            ];
            
            allToolButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            if (['brush', 'pen', 'pencil', 'watercolor'].includes(currentTool)) {
                pencilToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                pencilToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
            } else {
                const currentToolButton = document.getElementById(`${currentTool}Tool`);
                if (currentToolButton) {
                    currentToolButton.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                    currentToolButton.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                }
            }

            const brushModalButtons = [selectBrushToolBtn, selectPenToolBtn, selectPencilToolBtn, selectWatercolorToolBtn];
            brushModalButtons.forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-700');
            });

            if (currentTool === 'brush') {
                selectBrushToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectBrushToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pen') {
                selectPenToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPenToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pencil') {
                selectPencilToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPencilToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'watercolor') {
                selectWatercolorToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectWatercolorToolBtn.classList.add('bg-blue-500', 'text-white');
            }

            if (currentTool === 'watercolor') {
                watercolorFlowSection.classList.remove('hidden');
            } else {
                watercolorFlowSection.classList.add('hidden');
            }
        }

        async function resizeDrawingBufferAndFrames(newWidth, newHeight) {
            const oldFramesData = JSON.parse(JSON.stringify(framesData));
            const newFramesData = [];

            const oldProjWidth = projWidth;
            const oldProjHeight = projHeight;

            projWidth = newWidth;
            projHeight = newHeight;

            bufferCanvas.width = newWidth;
            bufferCanvas.height = newHeight;
            bufferCtx.imageSmoothingEnabled = true;

            for (let i = 0; i < oldFramesData.length; i++) {
                const oldFrame = oldFramesData[i];
                const newFrameData = {
                    imageData: null,
                    background: null
                };

                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
                tempCtx.imageSmoothingEnabled = true;

                tempCtx.clearRect(0, 0, newWidth, newHeight); // Ensure transparency

                if (oldFrame.imageData && oldFrame.imageData.startsWith('data:image/png;base64,')) {
                    try {
                        const img = await loadImage(oldFrame.imageData);
                        const offsetX = (newWidth - oldProjWidth) / 2;
                        const offsetY = (newHeight - oldProjHeight) / 2;
                        tempCtx.drawImage(img, offsetX, offsetY, oldProjWidth, oldProjHeight);
                    } catch (error) {
                        console.error("Trouble scaling drawing data during resize:", error);
                    }
                }
                newFrameData.imageData = tempCanvas.toDataURL('image/png');

                if (oldFrame.background && oldFrame.background.startsWith('data:image/png;base64,')) {
                    newFrameData.background = oldFrame.background;
                }
                newFramesData.push(newFrameData);
            }
            
            framesData = newFramesData;

            await loadFrameIntoBuffer();
            renderCanvasDisplay();
            updateTimelineDisplay();
            updateBackgroundButtons();
            saveStateToHistory();
            showUserMessage(`Canvas successfully resized to ${newWidth}x${newHeight}!`);
        }

        function updateTextPreview() {
            textPreviewCtx.clearRect(0, 0, textPreviewCanvas.width, textPreviewCanvas.height);
            textPreviewCtx.fillStyle = '#f9fafb';
            textPreviewCtx.fillRect(0, 0, textPreviewCanvas.width, textPreviewCanvas.height);

            const text = textInput.value;
            const fontSize = fontSizeInput.value;
            const fontFamily = fontFamilySelect.value;
            const fontWeight = fontBoldToggle.checked ? 'bold' : 'normal';
            const fontStyle = fontItalicToggle.checked ? 'italic' : 'normal';

            textFont = `${fontWeight} ${fontStyle} ${fontSize}px ${fontFamily}`;
            textPreviewCtx.font = textFont;
            textPreviewCtx.fillStyle = brushColorInput.value;
            textPreviewCtx.textAlign = 'left';
            textPreviewCtx.textBaseline = 'top';

            const lines = text.split('\n');
            let yOffset = 10;
            for (const line of lines) {
                textPreviewCtx.fillText(line, 10, yOffset);
                yOffset += parseInt(fontSize) * 1.2;
            }
        }

        function drawContentOnBuffer(content, x, y, font, color, opacity) {
            bufferCtx.save();

            if (typeof content === 'string') {
                bufferCtx.font = font;
                bufferCtx.fillStyle = color;
                bufferCtx.globalAlpha = opacity / 100;
                bufferCtx.textAlign = 'left';
                bufferCtx.textBaseline = 'top';

                const lines = content.split('\n');
                let yOffset = y;
                for (const line of lines) {
                    bufferCtx.fillText(line, x, yOffset);
                    yOffset += parseInt(font.match(/(\d+)px/)[1]) * 1.2;
                }
            } else if (content instanceof HTMLCanvasElement) {
                bufferCtx.globalAlpha = opacity / 100;
                bufferCtx.drawImage(content, x, y);
            }
            bufferCtx.restore();
        }

        async function extractLassoSelection() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = projWidth;
            tempCanvas.height = projHeight;
            tempCtx.imageSmoothingEnabled = true;

            tempCtx.drawImage(bufferCanvas, 0, 0);

            tempCtx.globalCompositeOperation = 'destination-in';
            tempCtx.beginPath();
            tempCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                tempCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            tempCtx.closePath();
            tempCtx.fillStyle = '#000';
            tempCtx.fill();
            tempCtx.globalCompositeOperation = 'source-over';

            selectedImageData = tempCanvas;

            bufferCtx.save();
            bufferCtx.globalCompositeOperation = 'destination-out';
            bufferCtx.beginPath();
            bufferCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                bufferCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            bufferCtx.closePath();
            bufferCtx.fillStyle = '#fff';
            bufferCtx.fill();
            bufferCtx.restore();

            selectionOffset = { x: lassoPoints[0].x, y: lassoPoints[0].y };
        }

        async function placeLassoSelection() {
            if (selectedImageData) {
                await loadFrameIntoBuffer();
                bufferCtx.drawImage(selectedImageData, selectionOffset.x, selectionOffset.y, selectedImageData.width, selectedImageData.height);
                saveCurrentFrameDrawingData();
                saveStateToHistory();
                showUserMessage('Selection placed!');
            }
            selectedImageData = null;
            selectionOffset = { x: 0, y: 0 };
            isMovingSelection = false;
            currentTool = 'brush';
            updateToolButtonStates();
            renderCanvasDisplay();
        }

        function populateStickerSelection() {
            stickerContainer.innerHTML = '';
            availableStickers.forEach(sticker => {
                const stickerButton = document.createElement('button');
                stickerButton.classList.add('sticker-button');
                stickerButton.textContent = sticker.emoji;
                stickerButton.style.fontSize = `${sticker.size}px`;

                stickerButton.addEventListener('click', () => {
                    stickerToPlace = sticker;
                    awaitingStickerPlacement = true;
                    stickerSelectionModal.classList.add('hidden');
                    showUserMessage(`Click on the canvas to place ${sticker.emoji} sticker.`);
                    currentTool = 'sticker';
                    updateToolButtonStates();
                });
                stickerContainer.appendChild(stickerButton);
            });
        }

        async function setBackground(imageSrc) {
            saveCurrentFrameDrawingData();
            if (imageSrc) {
                framesData[currentFrameIdx].background = imageSrc;
            } else {
                framesData[currentFrameIdx].background = null;
            }
            renderCanvasDisplay();
            updateBackgroundButtons();
            saveStateToHistory();
            showUserMessage(imageSrc ? 'Background set!' : 'Background cleared!');
        }

        function updateBackgroundButtons() {
            // No longer needed to update pre-built buttons as they are removed
        }

        /**
         * Checks if the app is running inside a Median.co webview (Android/iOS app).
         * Median typically adds "x-median" to the user agent string.
         * @returns {boolean} True if running in Median app, false otherwise.
         */
        function isMedianApp() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return /x-median|Median/.test(userAgent);
        }

        /**
         * Checks if the device is an Android device based on user agent.
         * @returns {boolean} True if Android, false otherwise.
         */
        function isAndroidDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return /android/i.test(userAgent);
        }

        /**
         * Determines if the mobile app prompt should be shown.
         * It considers screen size, user agent, if it's an Android device, and if it's already in the Median app.
         * @returns {boolean} True if the mobile app prompt should be shown, false otherwise.
         */
        function shouldShowMobileAppPrompt() {
            const screenWidth = window.innerWidth;
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;

            // Factor 1: Screen size (common breakpoint for mobile devices)
            const isSmallScreen = screenWidth < 768; // Adjust threshold as needed

            // Factor 2: User Agent String for common mobile OS/browsers
            const isMobileUA = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|rim)|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thc|501i|503i|504i|505i|506i|6270|7060|7290|7370|7420|7430|8300|8101|8102|8150|8170|8180|8190|9003|9025|9590|sync|alcatel|amoi|android|aptu|aurora|a≈°enas|avaya|blackberry|benq|brvm|cdm-|cellpad|cingular|cmc-|cldc-|cmd-|coool|cybo|daco|dhp|dmob|do(c|t)|ebmco|ercu|eudoraweb|fly|fennec|htc|iemobile|ibook|kddi|kgt|kinhin|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g5|b0|ke|pn|si)|lenovo|maemo|midp|mobi|mozilla|netfront|nestscape|nitro|nokia|palm|pana|pantone|philips|phone|pg(0|x)|pda|plucker|pocket|psp|qtek|qwap|sagem|sams(atc|us)|sgh-|shar|sie-|siemens|softbank|sony|spa|tcl-|tdg-|tel(i|m)|tim-|t-mobile|toplc|ts(v|w)|user|vodafone|wap|wonu|xda|xyzzy|zte/i.test(userAgent.substr(0, 4));
            
            // Show prompt if it's a small screen or mobile UA, AND it's an Android device, AND NOT the Median app.
            return (isSmallScreen || isMobileUA) && isAndroidDevice() && !isMedianApp();
        }

        window.onload = async function() {
            // Check if mobile prompt has already been shown in this session AND if it should be shown
            if (!sessionStorage.getItem('mobileAppPromptShown') && shouldShowMobileAppPrompt()) {
                mobileAppPromptModal.classList.remove('hidden');
                // Store that the prompt has been shown to avoid repeated display in the same session
                sessionStorage.setItem('mobileAppPromptShown', 'true');
            }

            // Show "Install App" button if running inside Median app
            if (isMedianApp() && isAndroidDevice()) {
                installAppInAppBtn.classList.remove('hidden');
            } else {
                installAppInAppBtn.classList.add('hidden');
            }


            // Event Listeners for the mobile app prompt modal
            continueWebBtn.addEventListener('click', () => {
                mobileAppPromptModal.classList.add('hidden');
            });

            downloadAppBtn.addEventListener('click', () => {
                window.location.href = 'https://median.co/share/pkbqrw#apk';
            });

            // Event Listener for the new in-app install button
            installAppInAppBtn.addEventListener('click', () => {
                window.location.href = 'https://median.co/share/pkbqrw#apk';
            });


            projWidth = parseInt(localStorage.getItem('projectWidth')) || 800;
            projHeight = parseInt(localStorage.getItem('projectHeight')) || 600;
            projectWidthInput.value = projWidth;
            projectHeightInput.value = projHeight;

            currentOpacity = parseInt(localStorage.getItem('currentOpacity')) || 100;
            watercolorFlow = parseInt(localStorage.getItem('watercolorFlow')) || 50;
            opacitySlider.value = currentOpacity;
            opacityValueSpan.textContent = `${currentOpacity}%`;
            flowSlider.value = watercolorFlow;
            flowValueSpan.textContent = `${watercolorFlow}%`;

            bufferCanvas.width = projWidth;
            bufferCanvas.height = projHeight;

            mainCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingEnabled = true;

            bufferCtx.lineCap = 'round';
            bufferCtx.lineJoin = 'round';
            bufferCtx.strokeStyle = brushColor;
            bufferCtx.lineWidth = brushSize;
            
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;

            if (framesData.length === 0) {
                bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
                const initialDrawingData = bufferCanvas.toDataURL('image/png');
                framesData.push({
                    imageData: initialDrawingData,
                    background: null
                });
                saveStateToHistory();
            }
            
            await loadFrameIntoBuffer();
            renderCanvasDisplay();
            
            updateTimelineDisplay();
            updateToolButtonStates();
            updateUndoRedoButtons();
            updateBackgroundButtons();

            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            exportGifBtn.disabled = false;

            populateStickerSelection();

            pencilToolBtn.addEventListener('dblclick', () => {
                brushSelectionModal.classList.remove('hidden');
                updateToolButtonStates();
            });

            eraserToolBtn.addEventListener('click', () => {
                currentTool = 'eraser';
                updateToolButtonStates();
            });
            fillToolBtn.addEventListener('click', () => {
                currentTool = 'fill';
                updateToolButtonStates();
            });
            eyedropperToolBtn.addEventListener('click', () => {
                currentTool = 'eyedropper';
                updateToolButtonStates();
            });
            panToolBtn.addEventListener('click', () => {
                currentTool = 'pan';
                updateToolButtonStates();
            });
            textToolBtn.addEventListener('click', () => {
                currentTool = 'text';
                updateToolButtonStates();
                textToolModal.classList.remove('hidden');
                updateTextPreview();
            });
            lassoToolBtn.addEventListener('click', () => {
                currentTool = 'lasso';
                updateToolButtonStates();
                showUserMessage('Lasso tool selected. Draw a selection.');
            });
            editToolBtn.addEventListener('click', () => {
                currentTool = 'edit';
                updateToolButtonStates();
                if (selectedImageData) {
                    isMovingSelection = true;
                    showUserMessage('Edit tool selected. Drag to move, click to place.');
                } else {
                    showUserMessage('No selection to edit. Use Lasso tool first.');
                }
                renderCanvasDisplay();
            });
            resizeToolBtn.addEventListener('click', () => {
                currentTool = 'resize';
                updateToolButtonStates();
                if (selectedImageData) {
                    resizeSelectionModal.classList.remove('hidden');
                    resizeWidthInput.value = selectedImageData.width;
                    resizeHeightInput.value = selectedImageData.height;
                } else {
                    showUserMessage('No selection to resize. Use Lasso tool first.');
                }
            });
            stickerToolBtn.addEventListener('click', () => {
                currentTool = 'sticker';
                updateToolButtonStates();
                stickerSelectionModal.classList.remove('hidden');
            });

            stylusOnlyModeToggle.addEventListener('change', (e) => {
                isStylusOnlyModeEnabled = e.target.checked;
            });

            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                bufferCtx.strokeStyle = brushColor;
                updateTextPreview();
            });

            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`;
                bufferCtx.lineWidth = brushSize;
            });

            opacitySlider.addEventListener('input', (e) => {
                currentOpacity = parseInt(e.target.value);
                opacityValueSpan.textContent = `${currentOpacity}%`;
                if (drawingActive) {
                    if (currentTool === 'pencil') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 0.4;
                    } else if (currentTool === 'brush') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 0.7;
                    } else if (currentTool === 'pen') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 1.0;
                    } else if (currentTool === 'watercolor') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                        bufferCtx.shadowBlur = brushSize * (watercolorFlow / 100) * 0.7;
                    }
                }
            });

            flowSlider.addEventListener('input', (e) => {
                watercolorFlow = parseInt(e.target.value);
                flowValueSpan.textContent = `${watercolorFlow}%`;
                if (drawingActive && currentTool === 'watercolor') {
                    bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                    bufferCtx.shadowBlur = brushSize * (watercolorFlow / 100) * 0.7;
                }
            });

            uploadBackgroundBtn.addEventListener('click', () => uploadBackgroundInput.click());
            uploadBackgroundInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setBackground(e.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            });
            clearBackgroundBtn.addEventListener('click', () => setBackground(null));

            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
            duplicateFrameBtn.addEventListener('click', duplicateFrame);
            clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGifAnimation);

            playBtn.addEventListener('click', startAnimationPlayback);
            pauseBtn.addEventListener('click', pauseAnimationPlayback);
            stopBtn.addEventListener('click', stopAnimationPlayback);
            animSpeedInput.addEventListener('input', (e) => {
                fps = parseInt(e.target.value);
                animSpeedValueSpan.textContent = fps;
                if (animPlaying) {
                    pauseAnimationPlayback();
                    startAnimationPlayback();
                }
            });

            mainCanvas.addEventListener('mousedown', handleInteractionStart);
            mainCanvas.addEventListener('mousemove', handleInteractionMove);
            mainCanvas.addEventListener('mouseup', handleInteractionEnd);
            mainCanvas.addEventListener('mouseleave', handleInteractionEnd);

            mainCanvas.addEventListener('touchstart', handleInteractionStart);
            mainCanvas.addEventListener('touchmove', handleInteractionMove);
            mainCanvas.addEventListener('touchend', handleInteractionEnd);
            mainCanvas.addEventListener('touchcancel', handleInteractionEnd);

            mainCanvas.addEventListener('click', (e) => {
                if (awaitingTextPlacement) {
                    const { x, y } = getTransformedDrawingCoords(e.clientX, e.clientY);
                    loadFrameIntoBuffer().then(() => {
                        drawContentOnBuffer(textToPlace, x, y, textFont, brushColor, currentOpacity);
                        saveCurrentFrameDrawingData();
                        renderCanvasDisplay();
                        saveStateToHistory();
                        showUserMessage('Text placed!');
                        awaitingTextPlacement = false;
                        currentTool = 'brush';
                        updateToolButtonStates();
                    });
                } else if (awaitingStickerPlacement) {
                    const { x, y } = getTransformedDrawingCoords(e.clientX, e.clientY);
                    loadFrameIntoBuffer().then(() => {
                        drawContentOnBuffer(stickerToPlace.emoji, x, y, `${stickerToPlace.size}px sans-serif`, brushColor, currentOpacity);
                        saveCurrentFrameDrawingData();
                        renderCanvasDisplay();
                        saveStateToHistory();
                        showUserMessage('Sticker placed!');
                        awaitingStickerPlacement = false;
                        stickerToPlace = null;
                        currentTool = 'brush';
                        updateToolButtonStates();
                    });
                } else if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection) {
                    placeLassoSelection();
                }
            });

            generateIdeaBtn.addEventListener('click', () => {
                ideaModal.classList.remove('hidden');
                generatedIdeaOutput.classList.add('hidden');
                ideaText.textContent = '';
                ideaPromptInput.value = '';
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                ideaModal.classList.add('hidden');
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea);

            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            faqBtn.addEventListener('click', () => {
                window.open('https://sathvik-harish.github.io/ToonStart-Help/', '_blank');
            });

            palmRejectionHelpIcon.addEventListener('click', () => {
                palmRejectionHelpModal.classList.remove('hidden');
            });
            closePalmRejectionHelpModalBtn.addEventListener('click', () => {
                palmRejectionHelpModal.classList.add('hidden');
            });

            updatesBtn.addEventListener('click', () => {
                updatesModal.classList.remove('hidden');
            });
            closeUpdatesModalBtn.addEventListener('click', () => {
                updatesModal.classList.add('hidden');
            });

            customizeBtn.addEventListener('click', () => {
                customizeModal.classList.remove('hidden');
            });
            closeCustomizeModalBtn.addEventListener('click', () => {
                customizeModal.classList.add('hidden');
            });

            applyCanvasSizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(projectWidthInput.value, 10);
                const newHeight = parseInt(projectHeightInput.value, 10);
                if (isNaN(newWidth) || newWidth < 100 || newWidth > 2000 || isNaN(newHeight) || newHeight < 100 || newHeight > 1500) {
                    showUserMessage('Please enter valid dimensions (Width: 100-2000px, Height: 100-1500px).');
                    return;
                }
                resizeDrawingBufferAndFrames(newWidth, newHeight);
                showUserMessage(`Canvas size set to ${newWidth}x${newHeight}.`);
            });

            resetCanvasSizeBtn.addEventListener('click', () => {
                projectWidthInput.value = 800;
                projectHeightInput.value = 600;
                resizeDrawingBufferAndFrames(800, 600);
                showUserMessage('Canvas size reset to default (800x600).');
            });

            undoBtn.addEventListener('click', performUndo);
            redoBtn.addEventListener('click', performRedo);

            selectBrushToolBtn.addEventListener('click', () => {
                currentTool = 'brush';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            selectPenToolBtn.addEventListener('click', () => {
                currentTool = 'pen';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            selectPencilToolBtn.addEventListener('click', () => {
                currentTool = 'pencil';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            selectWatercolorToolBtn.addEventListener('click', () => {
                currentTool = 'watercolor';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            closeBrushSelectionModalBtn.addEventListener('click', () => {
                brushSelectionModal.classList.add('hidden');
            });

            textInput.addEventListener('input', updateTextPreview);
            fontFamilySelect.addEventListener('change', updateTextPreview);
            fontSizeInput.addEventListener('input', updateTextPreview);
            fontBoldToggle.addEventListener('change', updateTextPreview);
            fontItalicToggle.addEventListener('change', updateTextPreview);

            placeTextBtn.addEventListener('click', () => {
                textToPlace = textInput.value;
                const fontSize = fontSizeInput.value;
                const fontFamily = fontFamilySelect.value;
                const fontWeight = fontBoldToggle.checked ? 'bold' : 'normal';
                const fontStyle = fontItalicToggle.checked ? 'italic' : 'normal';
                textFont = `${fontWeight} ${fontStyle} ${fontSize}px ${fontFamily}`;

                textToolModal.classList.add('hidden');
                awaitingTextPlacement = true;
                showUserMessage('Click on the canvas to place text.');
            });

            cancelTextBtn.addEventListener('click', () => {
                textToolModal.classList.add('hidden');
                awaitingTextPlacement = false;
                currentTool = 'brush';
                updateToolButtonStates();
            });

            closeStickerSelectionModalBtn.addEventListener('click', () => {
                stickerSelectionModal.classList.add('hidden');
                currentTool = 'brush';
                updateToolButtonStates();
            });

            applyResizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(resizeWidthInput.value, 10);
                const newHeight = parseInt(resizeHeightInput.value, 10);

                if (isNaN(newWidth) || newWidth <= 0 || isNaN(newHeight) || newHeight <= 0) {
                    showUserMessage('Please enter valid positive numbers for width and height.');
                    return;
                }

                if (selectedImageData) {
                    const resizedCanvas = document.createElement('canvas');
                    const resizedCtx = resizedCanvas.getContext('2d');
                    resizedCanvas.width = newWidth;
                    resizedCanvas.height = newHeight;
                    resizedCtx.imageSmoothingEnabled = true;
                    resizedCtx.drawImage(selectedImageData, 0, 0, newWidth, newHeight);
                    selectedImageData = resizedCanvas;
                    isMovingSelection = true;
                    showUserMessage('Selection resized. Click to place or drag to move.');
                }
                resizeSelectionModal.classList.add('hidden');
                renderCanvasDisplay();
            });

            cancelResizeBtn.addEventListener('click', () => {
                resizeSelectionModal.classList.add('hidden');
                if (selectedImageData) {
                    currentTool = 'edit';
                    isMovingSelection = true;
                    showUserMessage('Resize cancelled. Selection remains in edit mode.');
                } else {
                    currentTool = 'brush';
                }
                updateToolButtonStates();
                renderCanvasDisplay();
            });

            window.addEventListener('resize', () => {
                saveCurrentFrameDrawingData();
                
                mainCanvas.width = mainCanvas.offsetWidth;
                mainCanvas.height = mainCanvas.offsetHeight;

                mainCtx.imageSmoothingEnabled = true;

                loadFrameIntoBuffer().then(() => {
                    bufferCtx.lineCap = 'round';
                    bufferCtx.lineJoin = 'round';
                    bufferCtx.strokeStyle = brushColor;
                    bufferCtx.lineWidth = brushSize;
                    
                    renderCanvasDisplay();
                });
            });
        };
    </script>
</body>
</html>
ÔøΩ
