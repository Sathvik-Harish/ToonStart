<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .flex-grow-container {
            flex-grow: 1;
            min-height: 0;
        }
        .overflow-y-auto-custom {
            overflow-y: auto;
        }
        #staticToolbox {
            flex-shrink: 0;
            width: 256px;
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .toolbox-section {
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }
        .toolbox-section:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        .toolbox-section h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.75rem;
        }
        .toolbox-section label {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            display: block;
        }
        .toolbox-section input[type="range"] {
            width: 100%;
            height: 0.5rem;
        }
        .toolbox-section input[type="color"] {
            width: 100%;
            height: 2.5rem;
        }
        .tool-button {
            padding: 0.625rem 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            min-width: 50px;
        }
        .zoom-info {
            font-size: 0.875rem;
            color: #4b5563;
            line-height: 1.5;
        }
        .zoom-info ul {
            padding-left: 1.25rem;
        }
        .zoom-info kbd {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            font-size: 0.875em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            line-height: 1;
            color: #4a5568;
            background-color: #edf2f7;
            border: 1px solid #cbd5e0;
            border-bottom-color: #a0aec0;
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 #a0aec0;
        }
        .help-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            background-color: #9ca3af;
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s;
        }
        .help-icon:hover {
            background-color: #6b7280;
        }
    </style>
</head>
<body class="h-screen bg-gray-100 flex flex-col items-center p-4 sm:p-6 md:p-8">

    <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-800 mb-4 text-center">
        ToonStart Animation Editor <span class="text-xs font-normal align-top ml-2 text-gray-600">S.H. - S.S.</span>
    </h1>

    <div class="flex w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow flex-grow-container">
        <div id="staticToolbox">
            <div class="flex flex-col space-y-4">
                <div class="toolbox-section">
                    <h2>Tools</h2>
                    <div class="flex flex-wrap gap-1">
                        <button id="brushTool" class="tool-button bg-blue-600 text-white shadow-md">‚úé</button>
                        <button id="eraserTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü©π</button>
                        <button id="fillTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™£</button>
                        <button id="eyedropperTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üíâ</button>
                        <button id="panTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚úã</button>
                    </div>
                    <div class="mt-4 flex items-center">
                        <input type="checkbox" id="stylusOnlyModeToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="stylusOnlyModeToggle" class="text-sm font-medium text-gray-700">Palm Rejection</label>
                        <span id="palmRejectionHelpIcon" class="help-icon">?</span>
                    </div>
                </div>

                <div class="toolbox-section">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#000000" class="rounded-lg border-2 border-gray-300 cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="brushSize">Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- <div class="toolbox-section">
                    <h2>Zoom & Pan</h2>
                    <div class="flex flex-col space-y-1">
                        <label for="zoomLevel">Zoom: <span id="zoomLevelValue" class="font-bold">100%</span></label>
                        <input type="range" id="zoomLevel" min="10" max="500" value="100" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                        <button id="resetZoomPanBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm">Reset Zoom/Pan</button>
                    </div>
                </div> -->

                <div class="toolbox-section">
                    <h2>Frames</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="addFrame" class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-blue-600 text-sm">Add New</button>
                        <button id="deleteFrame" class="bg-red-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-red-600 text-sm">Delete</button>
                        <button id="duplicateFrame" class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-green-600 text-sm">Duplicate</button>
                        <button id="clearCurrentFrame" class="bg-orange-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-orange-600 text-sm">Clear</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>History</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="undoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü©Ô∏è Undo</button>
                        <button id="redoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü™Ô∏è Redo</button>
                    </div>
                </div>

                <!-- <div class="toolbox-section">
                    <h2>Onion Skinning</h2>
                    <div class="flex items-center mb-2">
                        <input type="checkbox" id="onionSkinToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="onionSkinToggle" class="text-sm font-medium text-gray-700">Enable Onion Skin</label>
                    </div>
                    <div id="onionSkinControls" class="space-y-2 hidden">
                        <div>
                            <label for="onionSkinPrevCount" class="block text-sm font-medium text-gray-700">Previous Frames: <span id="onionSkinPrevCountValue" class="font-bold">1</span></label>
                            <input type="range" id="onionSkinPrevCount" min="0" max="5" value="1" class="w-full bg-gray-300 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="onionSkinNextCount" class="block text-sm font-medium text-gray-700">Next Frames: <span id="onionSkinNextCountValue" class="font-bold">1</span></label>
                            <input type="range" id="onionSkinNextCount" min="0" max="5" value="1" class="w-full bg-gray-300 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="onionSkinOpacity" class="block text-sm font-medium text-gray-700">Opacity: <span id="onionSkinOpacityValue" class="font-bold">30%</span></label>
                            <input type="range" id="onionSkinOpacity" min="0.1" max="1.0" step="0.05" value="0.3" class="w-full bg-gray-300 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                </div> -->

                <div class="toolbox-section">
                    <h2>Project</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="saveProject" class="bg-indigo-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-indigo-600 text-sm">Save</button>
                        <button id="loadProject" class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-purple-600 text-sm">Load</button>
                        <button id="exportGif" class="bg-teal-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-teal-600 text-sm">
                            üñºÔ∏è Export GIF
                        </button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Ideas</h2>
                    <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-yellow-600 text-sm w-full">
                        ‚ú® Generate Idea
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Info</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="helpBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì Help
                        </button>
                        <button id="updatesBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ú® Updates
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="flex flex-col relative flex-grow p-4 sm:p-6">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                        üé¨
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200">
                        ‚è∏Ô∏è
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200">
                        üõë
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner overflow-x-auto">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Timeline</h3>
                <div id="timeline" class="flex space-x-2 pb-2">
                    </div>
            </div>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">‚ùì Help & View Tips</h3>
            <p class="zoom-info mb-4">
                If parts of the editor content appear cut off or you want to see more, you can adjust your browser's zoom level:
            </p>
            <ul class="zoom-info list-disc list-inside space-y-2">
                <li>
                    <span class="font-semibold">Browser Zoom Out:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>-</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>-</kbd> (Windows)
                </li>
                <li>
                    <span class="font-semibold">Browser Reset Zoom to 100%:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>0</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>0</kbd> (Windows)
                </li>
                <li>
                    <span class="font-semibold">Canvas Pan:</span> Click and drag with the "‚úã Hand" tool to pan.
                </li>
            </ul>
            <button id="closeHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="palmRejectionHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">üñêÔ∏è What is Palm Rejection?</h3>
            <p class="text-gray-700 mb-4">
                When "Palm Rejection" is enabled, the drawing canvas will <strong>only respond to input from a digital pen or stylus</strong>.
            </p>
            <p class="text-gray-700 mb-4">
                Touches from your fingers or palm will be ignored, allowing you to rest your hand on the screen while drawing without making accidental marks.
            </p>
            <p class="text-gray-700 text-sm italic">
                Note: This feature relies on your device and browser accurately reporting stylus input. Passive styluses (rubber-tip) may still be detected as finger touches.
            </p>
            <button id="closePalmRejectionHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="updatesModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md max-h-[80vh] overflow-y-auto">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚ú® ToonStart Updates</h3>
            <div id="updatesContent" class="text-gray-700 space-y-4">
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 24, 2025 - Core Drawing Improvements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Drawing:</strong> Drawing tools now work correctly and responsively.</li>
                        <li><strong>Fixed Fill Tool:</strong> Now accurately fills areas regardless of pan.</li>
                        <li><strong>Fixed Eyedropper Tool:</strong> Accurately picks colors from the canvas.</li>
                        <li>**Enhanced Responsiveness:** Significant performance improvements for drawing and canvas interactions.</li>
                        <li>**Removed Zoom Feature:** Canvas no longer supports zoom, focusing on direct drawing.</li>
                        <li>**Pipette Icon Update:** Changed to üíâ emoji.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 23, 2025 - Initial Feature Enhancements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Undo/Redo History:</strong> Easily correct mistakes with multiple steps.</li>
                        <li><strong>Pan Tool:</strong> Navigate the canvas for detailed work or overview.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 22, 2025 - Basic Drawing & Animation</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Basic Drawing Tools:</strong> Brush, Eraser, Fill.</li>
                        <li><strong>Frame Management:</strong> Add, delete, duplicate, clear frames.</li>
                        <li><strong>Animation Playback:</strong> Play, pause, stop animation with adjustable speed.</li>
                        <li><strong>Project Save/Load:</strong> Save and load your animation projects locally.</li>
                        <li><strong>GIF Export:</strong> Export your animation as a GIF.</li>
                        <li><strong>AI Idea Generator:</strong> Get creative ideas for your frames.</li>
                        <li><strong>Touch Support:</strong> Basic drawing on touch devices like iPad.</li>
                        <li><strong>Palm Rejection:</strong> Option to enable stylus-only drawing.</li>
                    </ul>
                </div>
            </div>
            <button id="closeUpdatesModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('drawingCanvas');
        const context = canvas.getContext('2d');

        const drawingBufferCanvas = document.createElement('canvas');
        const drawingBufferContext = drawingBufferCanvas.getContext('2d');

        const brushToolBtn = document.getElementById('brushTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const eyedropperToolBtn = document.getElementById('eyedropperTool');
        const panToolBtn = document.getElementById('panTool');
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');

        const stylusOnlyModeToggle = document.getElementById('stylusOnlyModeToggle');
        let isStylusOnlyModeEnabled = false;

        // Removed zoom-related elements: zoomLevelInput, zoomLevelValueSpan, resetZoomPanBtn

        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');

        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animationSpeedInput = document.getElementById('animationSpeed');
        const animationSpeedValueSpan = document.getElementById('animationSpeedValue');

        const timelineDiv = document.getElementById('timeline');

        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');

        const helpBtn = document.getElementById('helpBtn'); // Corrected assignment
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        const palmRejectionHelpIcon = document.getElementById('palmRejectionHelpIcon');
        const palmRejectionHelpModal = document.getElementById('palmRejectionHelpModal');
        const closePalmRejectionHelpModalBtn = document.getElementById('closePalmRejectionHelpModalBtn');

        const updatesBtn = document.getElementById('updatesBtn');
        const updatesModal = document.getElementById('updatesModal');
        const closeUpdatesModalBtn = document.getElementById('closeUpdatesModalBtn');

        // Removed onion skinning related elements

        let isDrawing = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let tool = 'brush';

        let frames = [];
        let currentFrameIndex = 0;

        let isPlaying = false;
        let animationSpeed = 10;
        let animationInterval = null;

        let isExporting = false;
        let exportProgress = 0;

        let history = [];
        let historyPointer = -1;
        const MAX_HISTORY_STATES = 50;

        // Removed scale variable
        let panOffset = { x: 0, y: 0 };
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };
        
        const loadedImageCache = new Map();

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function rgbaToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function loadImage(src) {
            if (loadedImageCache.has(src)) {
                return Promise.resolve(loadedImageCache.get(src));
            }
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    loadedImageCache.set(src, img);
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        function saveState() {
            if (historyPointer < history.length - 1) {
                history = history.slice(0, historyPointer + 1);
            }
            history.push(JSON.parse(JSON.stringify(frames)));
            historyPointer++;

            if (history.length > MAX_HISTORY_STATES) {
                history.shift();
                historyPointer--;
            }
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyPointer > 0) {
                historyPointer--;
                frames = JSON.parse(JSON.stringify(history[historyPointer]));
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
                updateTimeline();
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyPointer < history.length - 1) {
                historyPointer++;
                frames = JSON.parse(JSON.stringify(history[historyPointer]));
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
                updateTimeline();
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = !(historyPointer > 0);
            redoBtn.disabled = !(historyPointer < history.length - 1);
        }

        // New function to load frame data into the off-screen drawing buffer
        async function loadFrameIntoBuffer(frameData) {
            drawingBufferContext.clearRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);

            if (frameData && typeof frameData === 'string' && frameData.startsWith('data:image/png;base64,')) {
                try {
                    const img = loadedImageCache.get(frameData) || await loadImage(frameData);
                    drawingBufferContext.drawImage(img, 0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
                } catch (error) {
                    console.error("Error loading frame data into buffer:", error);
                }
            }
        }

        function renderCanvasContent() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.save();
            context.translate(panOffset.x, panOffset.y);
            
            // Draw the drawingBufferCanvas onto the main canvas
            context.drawImage(drawingBufferCanvas, 0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);

            context.restore();
            context.globalAlpha = 1.0;
            context.globalCompositeOperation = 'source-over';
        }

        function saveCurrentFrame() {
            frames[currentFrameIndex] = drawingBufferCanvas.toDataURL('image/png');
        }

        function getTransformedCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            // Get coordinates relative to the visible canvas
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            // Reverse pan transformation to get coordinates on the original resolution drawing buffer
            const x = (canvasX - panOffset.x);
            const y = (canvasY - panOffset.y);
            return { x, y };
        }

        function startDrawing(e) {
            e.preventDefault();

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    isDrawing = false;
                    return;
                }
            }

            if (tool === 'eyedropper') {
                const rect = canvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                // Get pixel data from the *rendered* canvas at the exact screen coordinates
                const imageData = context.getImageData(canvasX, canvasY, 1, 1).data;
                brushColorInput.value = rgbaToHex(imageData[0], imageData[1], imageData[2]);
                brushColor = brushColorInput.value;
                drawingBufferContext.strokeStyle = brushColor; // Update buffer context
                tool = 'brush';
                updateToolButtons();
                return;
            }

            if (tool === 'pan') {
                isPanning = true;
                lastPanPoint = { x: clientX, y: clientY };
                return;
            }

            if (tool === 'fill') {
                const { x, y } = getTransformedCoords(clientX, clientY);
                
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(() => { // Ensure buffer is up-to-date
                    floodFill(x, y, hexToRgba(brushColor), drawingBufferContext, drawingBufferCanvas.width, drawingBufferCanvas.height);
                    frames[currentFrameIndex] = drawingBufferCanvas.toDataURL('image/png');
                    renderCanvasContent();
                    saveState();
                }).catch(error => {
                    console.error("Error loading frame for fill:", error);
                });
                return;
            }

            const { x, y } = getTransformedCoords(clientX, clientY);
            drawingBufferContext.beginPath();
            drawingBufferContext.moveTo(x, y);
            isDrawing = true;
        }

        function draw(e) {
            e.preventDefault();

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    isDrawing = false;
                    return;
                }
            }

            if (tool === 'pan' && isPanning) {
                const dx = clientX - lastPanPoint.x;
                const dy = clientY - lastPanPoint.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPoint = { x: clientX, y: clientY };
                renderCanvasContent();
                return;
            }

            if (!isDrawing) return;

            const { x, y } = getTransformedCoords(clientX, clientY);
            drawingBufferContext.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
            drawingBufferContext.lineTo(x, y);
            drawingBufferContext.stroke();
            renderCanvasContent(); // Rerender main canvas to show live drawing
        }

        function stopDrawing(e) {
            e.preventDefault();

            if (tool !== 'fill' && tool !== 'eyedropper' && tool !== 'pan') {
                if (isDrawing) {
                    drawingBufferContext.closePath();
                    drawingBufferContext.globalCompositeOperation = 'source-over';
                    saveCurrentFrame();
                    saveState();
                }
            }
            isDrawing = false;
            isPanning = false;
            renderCanvasContent();
        }

        function floodFill(startX, startY, fillColor, ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            const getPixelColor = (x, y) => {
                if (x < 0 || x >= width || y < 0 || y >= height) return [-1, -1, -1, -1];
                const index = (y * width + x) * 4;
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            const setPixelColor = (x, y, color) => {
                const index = (y * width + x) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            const startColor = getPixelColor(Math.floor(startX), Math.floor(startY));

            if (startColor[0] === -1 || (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3])) {
                return;
            }

            const pixelStack = [[Math.floor(startX), Math.floor(startY)]];
            const visited = new Set();

            const matchColor = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x >= 0 && x < width && y >= 0 && y < height && matchColor(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor);

                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function updateTimeline() {
            timelineDiv.innerHTML = '';
            frames.forEach((_, index) => {
                const button = document.createElement('button');
                button.textContent = `F${index + 1}`;
                button.classList.add('flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold', 'transition-all', 'duration-200');
                if (index === currentFrameIndex) {
                    button.classList.add('border-blue-600', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                } else {
                    button.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                }
                button.onclick = () => {
                    if (isPlaying) pauseAnimation();
                    currentFrameIndex = index;
                    loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
                    updateTimeline();
                };
                timelineDiv.appendChild(button);
            });
        }

        function addFrame() {
            saveCurrentFrame();

            drawingBufferContext.clearRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            const blankCanvasData = drawingBufferCanvas.toDataURL('image/png');

            frames.splice(currentFrameIndex + 1, 0, blankCanvasData);
            currentFrameIndex++;
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
            updateTimeline();
            saveState();
        }

        function deleteFrame() {
            if (frames.length <= 1) {
                return;
            }
            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) {
                currentFrameIndex = frames.length - 1;
            }
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
            updateTimeline();
            saveState();
        }

        function duplicateFrame() {
            const currentFrameData = frames[currentFrameIndex];
            frames.splice(currentFrameIndex + 1, 0, currentFrameData);
            currentFrameIndex++;
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
            updateTimeline();
            saveState();
        }

        function clearCurrentFrame() {
            drawingBufferContext.clearRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            saveCurrentFrame();
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
            saveState();
        }

        function saveProject() {
            saveCurrentFrame();
            localStorage.setItem('animationProject', JSON.stringify(frames));
            localStorage.setItem('currentFrameIndex', currentFrameIndex.toString());
        }

        function loadProject() {
            const savedProject = localStorage.getItem('animationProject');
            const savedIndex = localStorage.getItem('currentFrameIndex');

            if (!savedProject) {
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProject);
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    frames = loadedFrames;
                    currentFrameIndex = Math.min(parseInt(savedIndex, 10) || 0, frames.length - 1);
                    history = [];
                    historyPointer = -1;
                    saveState();
                    loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
                    updateTimeline();
                } else {
                    console.error('Saved project data is corrupt or empty.');
                }
            } catch (error) {
                console.error("Error parsing loaded project:", error);
            }
        }

        function playAnimation() {
            if (frames.length === 0) {
                return;
            }
            if (isPlaying) return;

            isPlaying = true;
            
            // No need to load into buffer here, it's handled by interval and updateTimeline
            renderCanvasContent(); 

            const interval = 1000 / animationSpeed;
            animationInterval = setInterval(() => {
                currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
                updateTimeline();
            }, interval);
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            isPlaying = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
        }

        function stopAnimation() {
            pauseAnimation();
            currentFrameIndex = 0;
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load into buffer then render
            updateTimeline();
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
        }

        function exportGif() {
            if (typeof GIF === 'undefined') {
                console.error('GIF.js is not available. Ensure the script is loaded.');
                return;
            }
            if (frames.length === 0) {
                return;
            }

            isExporting = true;
            exportProgress = 0;
            exportGifBtn.textContent = `Exporting GIF... 0%`;
            exportGifBtn.disabled = true;

            const gif = new GIF({
                workers: 2,
                quality: 10,
                delay: 1000 / animationSpeed,
                width: drawingBufferCanvas.width,
                height: drawingBufferCanvas.height,
                background: '#ffffff',
                transparent: '#ffffff'
            });

            frames.forEach(frameData => {
                const img = new Image();
                img.src = frameData;
                gif.addFrame(img, { delay: 1000 / animationSpeed });
            });

            gif.on('progress', function(p) {
                exportProgress = Math.floor(p * 100);
                exportGifBtn.textContent = `Exporting GIF... ${exportProgress}%`;
            });

            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.gif';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
            });

            gif.on('error', function(error) {
                console.error('GIF generation error:', error);
                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
            });

            gif.render();
        }

        async function generateFrameIdea() {
            const prompt = ideaPromptInput.value.trim();
            if (!prompt) {
                return;
            }

            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden');
            ideaText.textContent = '';

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${prompt}". Keep it concise and focused on visual elements."` }] });
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = text;
                    generatedIdeaOutput.classList.remove('hidden');
                } else {
                    ideaText.textContent = 'Could not generate an idea. Please try again.';
                    generatedIdeaOutput.classList.remove('hidden');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to an error.';
                generatedIdeaOutput.classList.remove('hidden');
            } finally {
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }

        // Removed handleZoom function

        // Removed resetZoomPan function

        function updateToolButtons() {
            const allTools = [brushToolBtn, eraserToolBtn, fillToolBtn, eyedropperToolBtn, panToolBtn];
            allTools.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            const currentToolBtn = document.getElementById(`${tool}Tool`);
            if (currentToolBtn) {
                currentToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                currentToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
            }
        }

        window.onload = async function() { // Made onload async to await loadFrameIntoBuffer
            // Set visible canvas dimensions based on its container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Set drawing buffer dimensions. Provide a fallback if offsetWidth/Height are 0.
            // Use a reasonable default if the canvas is not yet laid out (e.g., 800x600)
            drawingBufferCanvas.width = canvas.width > 0 ? canvas.width : 800;
            drawingBufferCanvas.height = canvas.height > 0 ? canvas.height : 600;

            // Initialize drawing buffer context properties
            drawingBufferContext.lineCap = 'round';
            drawingBufferContext.lineJoin = 'round';
            drawingBufferContext.strokeStyle = brushColor;
            drawingBufferContext.lineWidth = brushSize;
            
            // Ensure the drawing buffer is initialized with a white background
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);


            if (frames.length === 0) {
                const initialCanvasData = drawingBufferCanvas.toDataURL('image/png');
                frames.push(initialCanvasData);
                saveState();
            }
            
            // Ensure the buffer has the current frame's content after initial setup or load
            await loadFrameIntoBuffer(frames[currentFrameIndex]);
            renderCanvasContent(); // Now render the content from the prepared buffer
            
            updateTimeline();
            updateToolButtons();
            updateUndoRedoButtons();

            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            exportGifBtn.disabled = false;

            brushToolBtn.addEventListener('click', () => {
                tool = 'brush';
                updateToolButtons();
            });
            eraserToolBtn.addEventListener('click', () => {
                tool = 'eraser';
                updateToolButtons();
            });
            fillToolBtn.addEventListener('click', () => {
                tool = 'fill';
                updateToolButtons();
            });
            eyedropperToolBtn.addEventListener('click', () => {
                tool = 'eyedropper';
                updateToolButtons();
            });
            panToolBtn.addEventListener('click', () => {
                tool = 'pan';
                updateToolButtons();
            });

            stylusOnlyModeToggle.addEventListener('change', (e) => {
                isStylusOnlyModeEnabled = e.target.checked;
            });

            // Removed zoomLevelInput and resetZoomPanBtn listeners

            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                drawingBufferContext.strokeStyle = brushColor;
            });

            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`;
                drawingBufferContext.lineWidth = brushSize;
            });

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);

            // Removed wheel event listener for zoom: canvas.addEventListener('wheel', handleZoom, { passive: false });

            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
            duplicateFrameBtn.addEventListener('click', duplicateFrame);
            clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGif);

            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            stopBtn.addEventListener('click', stopAnimation);
            animationSpeedInput.addEventListener('input', (e) => {
                animationSpeed = parseInt(e.target.value);
                animationSpeedValueSpan.textContent = animationSpeed;
                if (isPlaying) {
                    pauseAnimation();
                    playAnimation();
                }
            });

            generateIdeaBtn.addEventListener('click', () => {
                ideaModal.classList.remove('hidden');
                generatedIdeaOutput.classList.add('hidden');
                ideaText.textContent = '';
                ideaPromptInput.value = '';
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                ideaModal.classList.add('hidden');
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea);

            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            palmRejectionHelpIcon.addEventListener('click', () => {
                palmRejectionHelpModal.classList.remove('hidden');
            });
            closePalmRejectionHelpModalBtn.addEventListener('click', () => {
                palmRejectionHelpModal.classList.add('hidden');
            });

            updatesBtn.addEventListener('click', () => {
                updatesModal.classList.remove('hidden');
            });
            closeUpdatesModalBtn.addEventListener('click', () => {
                updatesModal.classList.add('hidden');
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            // Removed onion skinning event listeners

            window.addEventListener('resize', () => {
                const currentFrameData = drawingBufferCanvas.toDataURL('image/png');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                // Ensure drawingBufferCanvas also updates its size, with fallback
                drawingBufferCanvas.width = canvas.width > 0 ? canvas.width : 800;
                drawingBufferCanvas.height = canvas.height > 0 ? canvas.height : 600;

                // Load the captured state back into the (now resized) drawing buffer
                loadFrameIntoBuffer(currentFrameData).then(() => {
                    // Reapply drawing settings to the buffer context (important after resize)
                    drawingBufferContext.lineCap = 'round';
                    drawingBufferContext.lineJoin = 'round';
                    drawingBufferContext.strokeStyle = brushColor;
                    drawingBufferContext.lineWidth = brushSize;
                    
                    renderCanvasContent();
                });
            });
        };
    </script>
</body>
</html>
