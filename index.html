<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrolling */
        }
        /* Custom styles for canvas to ensure it fills space */
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0; /* gray-300 */
            border-radius: 0.75rem; /* rounded-lg */
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06); /* shadow-inner */
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }
        /* Ensure the main content area takes up remaining height */
        .flex-grow-container {
            flex-grow: 1;
            min-height: 0; /* Allow flex item to shrink */
        }
        .overflow-y-auto-custom {
            overflow-y: auto;
            /* Optional: Add max-height if you want to limit how much it grows before scrolling */
            /* max-height: calc(100vh - 150px); Adjust based on header/footer height */
        }
    </style>
</head>
<body class="h-screen bg-gray-100 flex flex-col items-center p-4 sm:p-6 md:p-8">

    <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-800 mb-4 text-center">
        ToonStart Animation Editor <span class="text-xs font-normal align-top ml-2 text-gray-600">S.H. - S.S.</span>
    </h1>

    <div id="messageDisplay" class="hidden bg-blue-500 text-white px-4 py-2 rounded-lg mb-4 shadow-md transition-opacity duration-500 opacity-0"></div>

    <div class="flex flex-col md:flex-row w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow flex-grow-container">
        <div class="w-full md:w-1/4 lg:w-1/5 bg-gray-50 p-4 sm:p-6 border-b md:border-b-0 md:border-r border-gray-200 flex flex-col space-y-4 overflow-y-auto-custom">
            <h2 class="text-xl font-semibold text-gray-700 mb-2">Tools</h2>

            <div class="flex flex-wrap gap-2 mb-4">
                <button id="brushTool" class="flex-1 min-w-[100px] px-4 py-2 rounded-lg transition-all duration-200 text-2xl bg-blue-600 text-white shadow-md">
                    ‚úèÔ∏è
                </button>
                <button id="eraserTool" class="flex-1 min-w-[100px] px-4 py-2 rounded-lg transition-all duration-200 text-2xl bg-gray-200 text-gray-700 hover:bg-blue-100">
                    ü©π
                </button>
                <button id="fillTool" class="flex-1 min-w-[100px] px-4 py-2 rounded-lg transition-all duration-200 text-2xl bg-gray-200 text-gray-700 hover:bg-blue-100">
                    ü™£
                </button>
            </div>

            <div class="flex flex-col">
                <label for="brushColor" class="text-gray-700 font-medium mb-2">Brush Color:</label>
                <input type="color" id="brushColor" value="#000000" class="w-full h-10 rounded-lg border-2 border-gray-300 cursor-pointer">
            </div>

            <div class="flex flex-col">
                <label for="brushSize" class="text-gray-700 font-medium mb-2">Brush Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                <input type="range" id="brushSize" min="1" max="50" value="5" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
            </div>

            <div class="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Frame Actions</h2>
                <button id="addFrame" class="bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-600 transition-colors duration-200">
                    Add New Frame
                </button>
                <button id="deleteFrame" class="bg-red-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-600 transition-colors duration-200">
                    Delete Current Frame
                </button>
                <button id="duplicateFrame" class="bg-green-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-green-600 transition-colors duration-200">
                    Duplicate Current Frame
                </button>
                <button id="clearCurrentFrame" class="bg-orange-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-600 transition-colors duration-200">
                    Clear Current Frame
                </button>
            </div>

            <div class="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Project Actions</h2>
                <button id="saveProject" class="bg-indigo-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-indigo-600 transition-colors duration-200">
                    Save Project
                </button>
                <button id="loadProject" class="bg-purple-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-purple-600 transition-colors duration-200">
                    Load Project
                </button>
                <button id="exportGif" class="bg-teal-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-teal-600 transition-colors duration-200">
                    üñºÔ∏è Export GIF
                </button>
            </div>

            <div class="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Onion Skinning</h2>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="onionSkinEnabled" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span class="text-gray-700">Enable Onion Skin</span>
                </label>

                <div id="onionSkinControls" class="space-y-2" style="display: none;">
                    <div class="flex flex-col">
                        <label for="onionPrev" class="text-gray-700 font-medium mb-1">Previous Frames: <span id="onionPrevValue" class="font-bold">1</span></label>
                        <input type="range" id="onionPrev" min="0" max="5" value="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex flex-col">
                        <label for="onionNext" class="text-gray-700 font-medium mb-1">Next Frames: <span id="onionNextValue" class="font-bold">1</span></label>
                        <input type="range" id="onionNext" min="0" max="5" value="1" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex flex-col">
                        <label for="onionOpacity" class="text-gray-700 font-medium mb-1">Opacity: <span id="onionOpacityValue" class="font-bold">30%</span></label>
                        <input type="range" id="onionOpacity" min="0.1" max="0.8" step="0.05" value="0.3" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex flex-col">
                        <label for="onionSkinColor" class="text-gray-700 font-medium mb-1">Onion Skin Color:</label>
                        <input type="color" id="onionSkinColor" value="#ff0000" class="w-full h-10 rounded-lg border-2 border-gray-300 cursor-pointer">
                    </div>
                </div>
            </div>

            <div class="flex flex-col space-y-2 pt-4 border-t border-gray-200">
                <h2 class="text-xl font-semibold text-gray-700 mb-2">Creative Ideas</h2>
                <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-4 py-2 rounded-lg shadow-md hover:bg-yellow-600 transition-colors duration-200">
                    ‚ú® Generate Frame Idea
                </button>
            </div>
        </div>

        <div class="w-full md:w-3/4 lg:w-4/5 p-4 sm:p-6 flex flex-col relative flex-grow">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                        ‚ñ∂Ô∏è Play
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200">
                        ‚è∏Ô∏è Pause
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200">
                        ‚èπÔ∏è Stop
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed" class="text-gray-700">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner overflow-x-auto">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Timeline</h3>
                <div id="timeline" class="flex space-x-2 pb-2">
                    </div>
            </div>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const context = canvas.getContext('2d');
        const messageDisplay = document.getElementById('messageDisplay');

        // Tool elements
        const brushToolBtn = document.getElementById('brushTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');

        // Frame action buttons
        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        // Project action buttons
        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');

        // Playback elements
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animationSpeedInput = document.getElementById('animationSpeed');
        const animationSpeedValueSpan = document.getElementById('animationSpeedValue');

        // Timeline element
        const timelineDiv = document.getElementById('timeline');

        // Onion Skin elements
        const onionSkinEnabledCheckbox = document.getElementById('onionSkinEnabled');
        const onionSkinControlsDiv = document.getElementById('onionSkinControls');
        const onionPrevInput = document.getElementById('onionPrev');
        const onionPrevValueSpan = document.getElementById('onionPrevValue');
        const onionNextInput = document.getElementById('onionNext');
        const onionNextValueSpan = document.getElementById('onionNextValue');
        const onionOpacityInput = document.getElementById('onionOpacity');
        const onionOpacityValueSpan = document.getElementById('onionOpacityValue');
        const onionSkinColorInput = document.getElementById('onionSkinColor');

        // Idea Generator elements
        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');


        // State variables
        let isDrawing = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let tool = 'brush'; // 'brush', 'eraser', 'fill'

        let frames = []; // Array of canvas data URLs
        let currentFrameIndex = 0;

        let isPlaying = false;
        let animationSpeed = 10; // FPS
        let animationInterval = null;

        let onionSkinEnabled = false;
        let onionSkinPrevCount = 1;
        let onionSkinNextCount = 1;
        let onionSkinOpacity = 0.3;
        let onionSkinColor = '#ff0000';

        let isExporting = false;
        let exportProgress = 0;


        // --- Utility Functions ---

        function showMessage(msg) {
            messageDisplay.textContent = msg;
            messageDisplay.classList.remove('hidden');
            messageDisplay.classList.add('opacity-100');
            setTimeout(() => {
                messageDisplay.classList.remove('opacity-100');
                messageDisplay.classList.add('opacity-0');
                // Hide after transition
                setTimeout(() => messageDisplay.classList.add('hidden'), 500);
            }, 2000);
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255]; // Always return with full alpha for internal comparison
        }

        function rgbaToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // --- Canvas Drawing and Rendering ---

        function loadImageAndDraw(imageData, alpha, tintColor = null) {
            if (typeof imageData !== 'string' || !imageData.startsWith('data:image/png;base64,')) {
                // console.warn("Invalid image data provided for drawing:", imageData);
                return;
            }

            const img = new Image();
            img.src = imageData;
            img.onload = () => {
                context.save(); // Save current context state

                context.globalAlpha = 1.0; // Draw base image fully opaque
                context.drawImage(img, 0, 0, canvas.width, canvas.height);

                if (tintColor) {
                    context.globalCompositeOperation = 'source-atop'; // Draw tint over the image
                    context.fillStyle = tintColor;
                    context.globalAlpha = alpha; // Use the desired opacity for the tint
                    context.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                context.restore(); // Restore context state
            };
            img.onerror = () => {
                console.error("Error loading image data for onion skin/frame:", imageData);
            };
        }

        function renderCanvasContent() {
            context.clearRect(0, 0, canvas.width, canvas.height); // Clear completely

            // 1. Draw previous frames (onion skin)
            if (onionSkinEnabled) {
                for (let i = onionSkinPrevCount; i >= 1; i--) {
                    const prevFrameIndex = currentFrameIndex - i;
                    if (prevFrameIndex >= 0) {
                        loadImageAndDraw(frames[prevFrameIndex], onionSkinOpacity, onionSkinColor);
                    }
                }
            }

            // 2. Draw the current frame (full opacity, no tint)
            loadImageAndDraw(frames[currentFrameIndex], 1.0);

            // 3. Draw next frames (onion skin)
            if (onionSkinEnabled) {
                for (let i = 1; i <= onionSkinNextCount; i++) {
                    const nextFrameIndex = currentFrameIndex + i;
                    if (nextFrameIndex < frames.length) {
                        loadImageAndDraw(frames[nextFrameIndex], onionSkinOpacity, onionSkinColor);
                    }
                }
            }
            // Ensure globalAlpha and globalCompositeOperation are reset for subsequent drawing operations (brush/eraser)
            context.globalAlpha = 1.0;
            context.globalCompositeOperation = 'source-over';
        }

        function saveCurrentFrame() {
            frames[currentFrameIndex] = canvas.toDataURL('image/png');
        }

        // --- Event Handlers ---

        function startDrawing(e) {
            if (tool === 'fill') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                floodFill(x, y, hexToRgba(brushColor));
                saveCurrentFrame();
                renderCanvasContent();
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;

            // Clear canvas and redraw only the current frame's content before drawing
            // This ensures drawing operations only affect the current frame's content
            context.clearRect(0, 0, canvas.width, canvas.height);
            const currentFrameData = frames[currentFrameIndex];
            if (currentFrameData && currentFrameData.startsWith('data:image/png;base64,')) {
                const img = new Image();
                img.src = currentFrameData;
                img.onload = () => {
                    context.drawImage(img, 0, 0, canvas.width, canvas.height);
                    context.beginPath();
                    context.moveTo(offsetX, offsetY);
                    isDrawing = true;
                };
                img.onerror = () => {
                    context.beginPath();
                    context.moveTo(offsetX, offsetY);
                    isDrawing = true;
                };
            } else {
                context.beginPath();
                context.moveTo(offsetX, offsetY);
                isDrawing = true;
            }
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;

            context.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
            context.lineTo(offsetX, offsetY);
            context.stroke();
        }

        function stopDrawing() {
            if (tool !== 'fill') { // Only close path and save if it was a drawing tool (not fill)
                context.closePath();
                isDrawing = false;
                context.globalCompositeOperation = 'source-over';
                saveCurrentFrame();
                renderCanvasContent(); // Redraw with onion skins after saving
            }
        }

        // --- Flood Fill Algorithm ---
        function floodFill(startX, startY, fillColor) {
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            const getPixelColor = (x, y) => {
                const index = (y * width + x) * 4;
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            const setPixelColor = (x, y, color) => {
                const index = (y * width + x) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            const startColor = getPixelColor(startX, startY);

            // If start color is already the fill color, do nothing
            if (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3]) {
                return;
            }

            const pixelStack = [[startX, startY]];
            const visited = new Set(); // To prevent infinite loops and re-processing

            const matchColor = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                // Check bounds and color match
                if (x >= 0 && x < width && y >= 0 && y < height && matchColor(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor);

                    // Add neighbors
                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            context.putImageData(imageData, 0, 0);
        }

        // --- Frame Management ---

        function updateTimeline() {
            timelineDiv.innerHTML = ''; // Clear existing buttons
            frames.forEach((_, index) => {
                const button = document.createElement('button');
                button.textContent = `F${index + 1}`;
                button.classList.add('flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold', 'transition-all', 'duration-200');
                if (index === currentFrameIndex) {
                    button.classList.add('border-blue-600', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                } else {
                    button.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                }
                button.onclick = () => {
                    if (isPlaying) pauseAnimation();
                    currentFrameIndex = index;
                    renderCanvasContent();
                    updateTimeline(); // Re-render to highlight new current frame
                };
                timelineDiv.appendChild(button);
            });
        }

        function addFrame() {
            saveCurrentFrame(); // Save current frame's state
            const blankCanvasData = canvas.toDataURL('image/png'); // Get blank state
            frames.splice(currentFrameIndex + 1, 0, blankCanvasData);
            currentFrameIndex++;
            renderCanvasContent();
            updateTimeline();
            showMessage('New frame added!');
        }

        function deleteFrame() {
            if (frames.length <= 1) {
                showMessage('Cannot delete the last frame!');
                return;
            }
            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) {
                currentFrameIndex = frames.length - 1;
            }
            renderCanvasContent();
            updateTimeline();
            showMessage('Frame deleted!');
        }

        function duplicateFrame() {
            const currentFrameData = frames[currentFrameIndex];
            frames.splice(currentFrameIndex + 1, 0, currentFrameData);
            currentFrameIndex++;
            renderCanvasContent();
            updateTimeline();
            showMessage('Frame duplicated!');
        }

        function clearCurrentFrame() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            saveCurrentFrame();
            renderCanvasContent();
            showMessage('Current frame cleared!');
        }

        // --- Project Save/Load ---

        function saveProject() {
            saveCurrentFrame();
            localStorage.setItem('animationProject', JSON.stringify(frames));
            localStorage.setItem('currentFrameIndex', currentFrameIndex.toString());
            showMessage('Animation project saved!');
        }

        function loadProject() {
            const savedProject = localStorage.getItem('animationProject');
            const savedIndex = localStorage.getItem('currentFrameIndex');

            if (!savedProject) {
                showMessage('No saved animation project found!');
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProject);
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    frames = loadedFrames;
                    currentFrameIndex = Math.min(parseInt(savedIndex, 10) || 0, frames.length - 1);
                    renderCanvasContent();
                    updateTimeline();
                    showMessage('Animation project loaded!');
                } else {
                    showMessage('Saved project data is corrupt or empty.');
                }
            } catch (error) {
                console.error("Error parsing loaded project:", error);
                showMessage('Error loading project data.');
            }
        }

        // --- Playback Functions ---

        function playAnimation() {
            if (frames.length === 0) {
                showMessage('No frames to play!');
                return;
            }
            if (isPlaying) return;

            isPlaying = true;
            onionSkinEnabled = false; // Disable onion skin during playback
            onionSkinEnabledCheckbox.checked = false; // Update UI
            onionSkinControlsDiv.style.display = 'none'; // Hide controls
            renderCanvasContent(); // Re-render to remove onion skins

            const interval = 1000 / animationSpeed;
            animationInterval = setInterval(() => {
                currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                renderCanvasContent();
                updateTimeline(); // Keep timeline highlight updated
            }, interval);
            showMessage('Playing animation...');
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            isPlaying = false;
            showMessage('Animation paused.');
            playBtn.disabled = false;
            pauseBtn.disabled = true;
        }

        function stopAnimation() {
            pauseAnimation();
            currentFrameIndex = 0;
            renderCanvasContent();
            updateTimeline();
            showMessage('Animation stopped.');
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
        }

        // --- GIF Export ---
        function exportGif() {
            if (typeof GIF === 'undefined') {
                showMessage('GIF.js library not loaded. Cannot export GIF.');
                console.error('GIF.js is not available. Ensure the script is loaded.');
                return;
            }
            if (frames.length === 0) {
                showMessage('No frames to export!');
                return;
            }

            isExporting = true;
            exportProgress = 0;
            exportGifBtn.textContent = `Exporting GIF... 0%`;
            exportGifBtn.disabled = true;
            showMessage('Generating GIF...');

            const gif = new GIF({
                workers: 2,
                quality: 10,
                delay: 1000 / animationSpeed,
                width: canvas.width,
                height: canvas.height,
                background: '#ffffff',
                transparent: '#ffffff'
            });

            // Add each frame to the GIF
            frames.forEach(frameData => {
                const img = new Image();
                img.src = frameData;
                gif.addFrame(img, { delay: 1000 / animationSpeed });
            });

            gif.on('progress', function(p) {
                exportProgress = Math.floor(p * 100);
                exportGifBtn.textContent = `Exporting GIF... ${exportProgress}%`;
            });

            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.gif';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showMessage('GIF exported successfully!');
            });

            gif.on('error', function(error) {
                console.error('GIF generation error:', error);
                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showMessage('Error exporting GIF.');
            });

            gif.render();
        }

        async function generateFrameIdea() {
            const prompt = ideaPromptInput.value.trim();
            if (!prompt) {
                showMessage('Please enter a prompt for the idea generator.');
                return;
            }

            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden');
            ideaText.textContent = '';

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${prompt}". Keep it concise and focused on visual elements.` }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // API key will be provided by Canvas runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = text;
                    generatedIdeaOutput.classList.remove('hidden');
                    showMessage('Idea generated successfully!');
                } else {
                    ideaText.textContent = 'Could not generate an idea. Please try again.';
                    generatedIdeaOutput.classList.remove('hidden');
                    showMessage('Error generating idea.');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to an error.';
                generatedIdeaOutput.classList.remove('hidden');
                showMessage('Error generating idea.');
            } finally {
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }


        // --- Initialization ---

        window.onload = function() {
            // Set initial canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            context.lineCap = 'round';
            context.lineJoin = 'round';
            context.strokeStyle = brushColor;
            context.lineWidth = brushSize;

            // Initialize with one blank frame
            frames.push(canvas.toDataURL('image/png'));
            updateTimeline();
            renderCanvasContent(); // Initial render

            // Set initial button states
            brushToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
            brushToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            exportGifBtn.disabled = false; // Enable export initially

            // --- Event Listeners ---

            // Tool selection
            brushToolBtn.addEventListener('click', () => {
                tool = 'brush';
                brushToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                brushToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                eraserToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                eraserToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                fillToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                fillToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                context.strokeStyle = brushColor; // Ensure brush color is active
            });
            eraserToolBtn.addEventListener('click', () => {
                tool = 'eraser';
                eraserToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                eraserToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                brushToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                brushToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                fillToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                fillToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });
            fillToolBtn.addEventListener('click', () => {
                tool = 'fill';
                fillToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                fillToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                brushToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                brushToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                eraserToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                eraserToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                context.strokeStyle = brushColor;
            });

            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`;
                context.lineWidth = brushSize;
            });

            // Canvas drawing events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            // Frame actions
            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
            duplicateFrameBtn.addEventListener('click', duplicateFrame);
            clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            // Project actions
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGif);

            // Playback controls
            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            stopBtn.addEventListener('click', stopAnimation);
            animationSpeedInput.addEventListener('input', (e) => {
                animationSpeed = parseInt(e.target.value);
                animationSpeedValueSpan.textContent = animationSpeed;
                if (isPlaying) { // Restart animation with new speed if playing
                    pauseAnimation();
                    playAnimation();
                }
            });

            // Onion Skin controls
            onionSkinEnabledCheckbox.addEventListener('change', (e) => {
                onionSkinEnabled = e.target.checked;
                onionSkinControlsDiv.style.display = onionSkinEnabled ? 'block' : 'none';
                renderCanvasContent(); // Re-render to apply/remove onion skins
            });
            onionPrevInput.addEventListener('input', (e) => {
                onionPrevCount = parseInt(e.target.value);
                onionPrevValueSpan.textContent = onionPrevCount;
                renderCanvasContent();
            });
            onionNextInput.addEventListener('input', (e) => {
                onionNextCount = parseInt(e.target.value);
                onionNextValueSpan.textContent = onionNextCount;
                renderCanvasContent();
            });
            onionOpacityInput.addEventListener('input', (e) => {
                onionOpacity = parseFloat(e.target.value);
                onionOpacityValueSpan.textContent = `${(onionOpacity * 100).toFixed(0)}%`;
                renderCanvasContent();
            });
            onionSkinColorInput.addEventListener('input', (e) => {
                onionSkinColor = e.target.value;
                renderCanvasContent();
            });

            // Idea Generator Modal
            generateIdeaBtn.addEventListener('click', () => {
                ideaModal.classList.remove('hidden');
                generatedIdeaOutput.classList.add('hidden'); // Hide previous output
                ideaText.textContent = ''; // Clear previous text
                ideaPromptInput.value = ''; // Clear prompt input
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                ideaModal.classList.add('hidden');
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea);

            // Handle window resize
            window.addEventListener('resize', () => {
                // Save current frame's image data
                const currentFrameData = canvas.toDataURL('image/png');
                // Update canvas dimensions
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                // Redraw the saved image data onto the resized canvas
                const img = new Image();
                img.src = currentFrameData;
                img.onload = () => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.drawImage(img, 0, 0, canvas.width, canvas.height);
                    // Reapply drawing styles after resize
                    context.lineCap = 'round';
                    context.lineJoin = 'round';
                    context.strokeStyle = brushColor;
                    context.lineWidth = brushSize;
                    renderCanvasContent(); // Re-render with onion skins
                };
            });
        };
    </script>
</body>
</html>
