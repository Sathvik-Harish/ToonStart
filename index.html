<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        /* Basic body styling to ensure full height and font consistency */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrolling */
        }
        /* Canvas styling for visual appeal and responsiveness */
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            width: 100%;
            height: 100%;
            touch-action: none; /* Disable default touch actions like pan/zoom */
        }
        /* Flex container to ensure the main content area grows to fill space */
        .flex-grow-container {
            flex-grow: 1;
            min-height: 0; /* Important for flex items in a column to shrink correctly */
        }
        /* Custom overflow for scrollable sections */
        .overflow-y-auto-custom {
            overflow-y: auto;
        }
        /* Styles for the fixed toolbox sidebar */
        #staticToolbox {
            flex-shrink: 0; /* Prevent toolbox from shrinking */
            width: 256px; /* Fixed width for the toolbox */
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            overflow-y: auto; /* Enable vertical scrolling for toolbox content */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Styling for sections within the toolbox */
        .toolbox-section {
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }
        /* No top border for the first toolbox section */
        .toolbox-section:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        /* Heading styles for toolbox sections */
        .toolbox-section h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.75rem;
        }
        /* Label styles within toolbox sections */
        .toolbox-section label {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            display: block;
        }
        /* Styling for range input sliders */
        .toolbox-section input[type="range"] {
            width: 100%;
            height: 0.5rem;
        }
        /* Styling for color input */
        .toolbox-section input[type="color"] {
            width: 100%;
            height: 2.5rem;
        }
        /* Common styles for tool buttons */
        .tool-button {
            padding: 0.625rem 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            min-width: 50px;
        }
        /* Styling for zoom information text */
        .zoom-info {
            font-size: 0.875rem;
            color: #4b5563;
            line-height: 1.5;
        }
        /* List padding for zoom info */
        .zoom-info ul {
            padding-left: 1.25rem;
        }
        /* Keyboard key styling for instructions */
        .zoom-info kbd {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            font-size: 0.875em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            line-height: 1;
            color: #4a5568;
            background-color: #edf2f7;
            border: 1px solid #cbd5e0;
            border-bottom-color: #a0aec0;
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 #a0aec0;
        }
        /* Help icon styling */
        .help-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            background-color: #9ca3af;
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s;
        }
        /* Hover effect for help icon */
        .help-icon:hover {
            background-color: #6b7280;
        }
        /* Styles for draggable frame buttons in the timeline */
        .frame-button.dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa;
            background-color: #bfdbfe;
        }
        .frame-button.drag-over {
            border: 2px dashed #3b82f6;
            background-color: #dbeafe;
        }
        /* Styling for sticker buttons within the sticker selection modal */
        .sticker-button {
            font-size: 2.5rem; /* Larger emoji size */
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #e2e8f0;
            transition: background-color 0.2s;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .sticker-button:hover {
            background-color: #cbd5e0;
        }
    </style>
</head>
<body class="h-screen bg-gray-100 flex flex-col items-center p-4 sm:p-6 md:p-8">

    <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-800 mb-4 text-center">
        ToonStart Animation Editor <span class="text-xs font-normal align-top ml-2 text-gray-600">S.H. - S.S.</span>
    </h1>

    <div id="messageDisplay" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md transition-opacity duration-500 opacity-0 z-1000 hidden"></div>

    <div class="flex w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow flex-grow-container">
        <div id="staticToolbox">
            <div class="flex flex-col space-y-4">
                <div class="toolbox-section">
                    <h2>Tools</h2>
                    <div class="flex flex-wrap gap-1">
                        <button id="pencilTool" class="tool-button bg-blue-600 text-white shadow-md">‚úèÔ∏è</button>
                        <button id="eraserTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü©π</button>
                        <button id="fillTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™£</button>
                        <button id="eyedropperTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üíâ</button>
                        <button id="panTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚úã</button>
                        <button id="textTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üÖ∞Ô∏è</button>
                        <button id="lassoTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™¢</button>
                        <button id="editTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚úÇÔ∏è</button>
                        <button id="resizeTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üìè</button>
                        <button id="stickerTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚ú®</button>
                    </div>
                    <div class="mt-4 flex items-center">
                        <input type="checkbox" id="stylusOnlyModeToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="stylusOnlyModeToggle" class="text-sm font-medium text-gray-700">Palm Rejection</label>
                        <span id="palmRejectionHelpIcon" class="help-icon">?</span>
                    </div>
                </div>

                <div class="toolbox-section">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#000000" class="rounded-lg border-2 border-gray-300 cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="brushSize">Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="opacitySlider">Opacity: <span id="opacityValue" class="font-bold">100%</span></label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div id="watercolorFlowSection" class="toolbox-section hidden">
                    <label for="flowSlider">Flow: <span id="flowValue" class="font-bold">50%</span></label>
                    <input type="range" id="flowSlider" min="0" max="100" value="50" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <h2>Frames</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="addFrame" class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-blue-600 text-sm">Add New</button>
                        <button id="deleteFrame" class="bg-red-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-red-600 text-sm">Delete</button>
                        <button id="duplicateFrame" class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-green-600 text-sm">Duplicate</button>
                        <button id="clearCurrentFrame" class="bg-orange-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-orange-600 text-sm">Clear</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>History</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="undoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü©Ô∏è Undo</button>
                        <button id="redoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü™Ô∏è Redo</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Project</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="saveProject" class="bg-indigo-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-indigo-600 text-sm">Save</button>
                        <button id="loadProject" class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-purple-600 text-sm">Load</button>
                        <button id="exportGif" class="bg-teal-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-teal-600 text-sm">
                            üñºÔ∏è Export GIF
                        </button>
                        <button id="customizeBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚öôÔ∏è Customize
                        </button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Ideas</h2>
                    <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-yellow-600 text-sm w-full">
                        ‚ú® Generate Idea
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Info</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="helpBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì Help
                        </button>
                        <button id="faqBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì FAQ
                        </button>
                        <button id="updatesBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ú® Updates
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="flex flex-col relative flex-grow p-4 sm:p-6">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                        üé¨
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200">
                        ‚è∏Ô∏è
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200">
                        üõë
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner max-h-24">
                <div id="timelineContainer" class="overflow-x-auto pb-2">
                    <div id="timeline" class="flex flex-nowrap space-x-2 items-center">
                        </div>
                </div>
            </div>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4 flex-shrink-0">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 flex-shrink-0">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200 flex-shrink-0">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden flex-grow overflow-y-auto">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ùì Help & View Tips</h3>
            <div class="flex-grow overflow-y-auto pr-2">
                <p class="zoom-info mb-4">
                    If parts of the editor content appear cut off or you want to see more, you can adjust your browser's zoom level.
                </p>
                <ul class="zoom-info list-disc list-inside space-y-2">
                    <li>
                        <span class="font-semibold">Browser Zoom Out:</span>
                        <br>
                        <kbd>Cmd</kbd> + <kbd>-</kbd> (Mac)
                        <br>
                        <kbd>Ctrl</kbd> + <kbd>-</kbd> (Windows)
                    </li>
                    <li>
                        <span class="font-semibold">Browser Reset Zoom to 100%:</span>
                        <br>
                        <kbd>Cmd</kbd> + <kbd>0</kbd> (Mac)
                        <br>
                        <kbd>Ctrl</kbd> + <kbd>0</kbd> (Windows)
                    </li>
                    <li>
                        <span class="font-semibold">If browser zooming in and out doesn't work as expected, try setting your browser zoom to 150% and then refresh the page. This can sometimes resolve layout issues and bring the timeline back into view.</span>
                    </li>
                    <li>
                        <span class="font-semibold">Canvas Pan:</span> Click and drag with the "‚úã Hand" tool to pan.
                    </li>
                    <li>
                        <span class="font-semibold">Line Smoothness:</span> If lines appear jagged or pixelated (especially at smaller brush sizes or high canvas resolutions), ensure your browser's "image smoothing" is enabled. This feature is enabled by default in ToonStart to improve line quality.
                    </li>
                    <li>
                        <span class="font-semibold">Brush Selection:</span> Double-click the 'Pencil' tool to open a menu and choose between 'Brush', 'Pen', 'Pencil', and 'Watercolor' drawing styles. Each style offers a distinct drawing feel.
                    </li>
                    <li>
                        <span class="font-semibold">Opacity Control:</span> Use the 'Opacity' slider in the toolbox to adjust the transparency of your brush strokes.
                    </li>
                    <li>
                        <span class="font-semibold">Watercolor Flow:</span> When the 'Watercolor' tool is selected, a 'Flow' slider will appear. This controls how much the color spreads out and and accumulates with each stroke, mimicking real watercolor effects.
                    </li>
                    <li>
                        <span class="font-semibold">Text Tool:</span> Select the 'Text' tool (üÖ∞Ô∏è) to add text to your canvas. A modal will appear where you can type your text, choose font family, size, and style (bold/italic). Click 'Place Text' and then click on the canvas to position your text.
                    </li>
                    <li>
                        <span class="font-semibold">Lasso Tool (ü™¢):</span> Draw a freehand selection. Once the selection is made, it will be cut from the canvas. You must then use the 'Edit' or 'Resize' tools to manipulate it.
                    </li>
                    <li>
                        <span class="font-semibold">Edit Tool (‚úÇÔ∏è):</span> After using the Lasso tool, select the 'Edit' tool. Click and drag on the canvas to move your lassoed selection. Click again to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Resize Tool (üìè):</span> After using the Lasso tool, select the 'Resize' tool. A modal will appear allowing you to input new dimensions for your lassoed selection. After applying, click on the canvas to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Sticker Tool (‚ú®):</span> Select the 'Sticker' tool to open a menu of emojis. Choose an emoji and then click on the canvas to place it.
                    </li>
                    <li>
                        <span class="font-semibold">Edit (For text only):</span> This option is currently a placeholder for a future enhancement, as text is rasterized upon placement. This means once text is placed, it becomes part of the image and cannot be directly edited as text again.
                    </li>
                </ul>
            </div>
            <button id="closeHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="palmRejectionHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">üñêÔ∏è What is Palm Rejection?</h3>
            <p class="text-gray-700 mb-4">
                When "Palm Rejection" is enabled, the drawing canvas will <strong>only respond to input from a digital pen or stylus</strong>.
            </p>
            <p class="text-gray-700 mb-4">
                Touches from your fingers or palm will be ignored, allowing you to rest your hand on the screen while drawing without making accidental marks.
            </p>
            <p class="text-gray-700 text-sm italic">
                Note: This feature relies on your device and browser accurately reporting stylus input. Passive styluses (rubber-tip) may still be detected as finger touches.
            </p>
            <button id="closePalmRejectionHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="updatesModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col" style="max-height: 90vh;">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 flex-shrink-0">‚ú® ToonStart Updates</h3>
            <div id="updatesContent" class="text-gray-700 space-y-4 flex-grow overflow-y-auto">
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Code Readability & Stickers</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Code Comments:</strong> Added extensive comments throughout the JavaScript code to explain logic, variables, and functions, improving readability and maintainability.</li>
                        <li><strong>HTML Comments:</strong> Added basic comments to HTML sections for better structure understanding.</li>
                        <li><strong>Sticker Tool (‚ú®):</strong> A new tool to add fun emoji stickers to your animation frames.</li>
                        <li><strong>Lasso/Edit/Resize Fixes:</strong> Resolved issues with object duplication, improved mouse alignment during moves, and ensured accurate display of pixel dimensions in the resize modal.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Separate Edit/Resize Tools for Lasso</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool (ü™¢):</strong> Now solely for drawing selections. Moving and resizing are handled by new dedicated tools.</li>
                        <li><strong>New Edit Tool (‚úÇÔ∏è):</strong> Move lassoed selections.</li>
                        <li><strong>New Resize Tool (üìè):</strong> Resize lassoed selections with precise dimensions.</li>
                        <li><strong>Help & Updates:</strong> Updated to reflect the new tool functionalities.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Enhanced Lasso Tool</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool Placement:</strong> Lassoed selections now require an explicit click to be placed on the canvas, giving you more control.</li>
                        <li><strong>Lasso Double-Click Options:</strong> Double-clicking the lasso tool now opens a menu with 'Move', 'Resize', and 'Edit (For text only)' options.</li>
                        <li><strong>Lasso Resize:</strong> You can now resize your lassoed selection by inputting new dimensions.</li>
                        <li><strong>Lasso Text Edit (Future):</strong> The 'Edit (For text only)' option is currently a placeholder for a future enhancement, as text is rasterized upon placement.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Movement Fix</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool:</strong> Corrected the behavior of the lasso tool so that selected areas now move precisely with the mouse/stylus and are placed accurately.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Fix & Fixed Help Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool Fix:</strong> Resolved issues where the lasso tool would clear the entire canvas. Now, only the selected area is cut and moved.</li>
                        <li><strong>Fixed Help Button:</strong> The "Close" button in the Help modal now remains fixed at the bottom, even when the content scrolls.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Lasso Tool Added</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Lasso Tool:</strong> A new tool (ü™¢) has been added, allowing you to draw freehand selections, cut them from the canvas, and then move and place them elsewhere.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Text Tool, Refined Watercolor, No Comments</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Text Tool:</strong> Added a new tool to place customizable text on the canvas, with options for font family, size, bold, and italic.</li>
                        <li><strong>Watercolor Flow Refinement:</strong> The 'Watercolor' tool now features an improved slow-spreading effect for more natural color accumulation.</li>
                        <li><strong>No Comments:</strong> All comments have been removed from the code for a cleaner, more human-written aesthetic.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - No Comments & Draggable Frames</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Comments Removed:</strong> All code comments (`/* */` and `//`) have been removed for a cleaner, more human-written aesthetic.</li>
                        <li><strong>Draggable Frames:</strong> You can now drag and drop frames in the timeline to easily reorder them.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Refined Watercolor Flow & Comment Style</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Watercolor Flow:</strong> Enhanced the 'Watercolor' tool to provide a more natural, spreading effect with gradual color accumulation.</li>
                        <li><strong>Comment Style:</strong> Replaced all block comments (`/* ... */`) with single-line comments (`// ...`) for a more human-written code aesthetic.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Opacity & Watercolor Flow</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Opacity Slider:</strong> Added a new slider to control the general transparency of all drawing tools.</li>
                        <li><strong>Watercolor Tool:</strong> Introduced a new 'Watercolor' brush type in the double-click menu.</li>
                        <li><strong>Flow Slider:</strong> A 'Flow' slider now appears when the 'Watercolor' tool is active, allowing for natural color accumulation in strokes.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Fixed Modal Scrolling</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Modal Scrolling:</strong> The "Generate Idea" and "Updates" modals now correctly handle long content by allowing the content to scroll while keeping the "Close" button fixed at the bottom.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Brush Selection Persistence Fix</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Selection:</strong> Fixed an issue where the selected brush type (Brush, Pen, or Pencil) wasn't consistently active after choosing it from the double-click menu. Your brush choice will now stick!</li>
                        <li><strong>Pencil Tool Behavior:</strong> The main 'Pencil' tool button in the sidebar will now *only* open the brush selection menu on double-click, preventing accidental changes to your brush type.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Improved Brush Selection Highlight</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Clearer Selection:</strong> When you open the brush selection menu, the currently active brush style (Brush, Pen, or Pencil) will now be clearly highlighted, making it easier to see your current choice.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Enhanced Brush Styles & Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Behavior:</strong> The 'Brush', 'Pen', and 'Pencil' tools now have distinct drawing feels:
                            <ul>
                                <li>'Pencil' offers a light, sketchy line.</li>
                                <li>'Pen' draws a solid, straightforward line.</li>
                                <li>'Brush' provides a slightly softer, more "painterly" stroke.</li>
                            </ul>
                        </li>
                        <li><strong>Tool Selection Reliability:</strong> Fixed an issue where selecting a brush type from the double-click menu wasn't consistently applying the chosen tool.</li>
                        <li><strong>Pencil Tool Feedback:</strong> The main 'Pencil' tool button will now stay highlighted whenever 'Brush', 'Pen', or 'Pencil' is the active drawing style.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Refined Brush Selection</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Streamlined Tools:</strong> The main toolbox now features only the 'Pencil' tool for drawing.</li>
                        <li><strong>Intuitive Brush Menu:</strong> Double-clicking the 'Pencil' tool will bring up a menu, allowing you to select between 'Brush', 'Pen', and 'Pencil' drawing styles.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - New Brush Tools</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>New Brushes:</strong> Added 'Pen' and 'Pencil' tools for more drawing variety.</li>
                        <li><strong>Brush Selection Menu:</strong> Double-clicking the 'Pencil' tool now brings up a menu to easily switch between 'Brush', 'Pen', and 'Pencil' modes.</li>
                        <li><strong>Pencil Feel:</strong> The 'Pencil' tool now draws with a lighter, sketchier appearance.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Updated GIF Export Logic</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>GIF Export:</strong> Updated the GIF export logic to explicitly draw each frame onto a temporary canvas before adding it to the GIF, ensuring consistent output.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Improved Drawing Smoothness</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Shape & Diagonal Lines:</strong> Fixed issues where circular brush strokes would appear square or jagged, especially on diagonals or after canvas resizing. Image smoothing is now explicitly enabled for both drawing and display contexts to ensure smoother line rendering.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Added FAQ Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>FAQ Button:</strong> Added a new "FAQ" button in the "Info" section linking to the help page.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Fixed Canvas Resizing</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Canvas Resizing:</strong> Lines and existing drawings now maintain their original thickness when resizing the project canvas.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Zoom Feature Removed</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature Removed:</strong> Zoom functionality has been removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 29, 2025 - Zoom Feature & UI Polish</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature:</strong> Added zoom functionality via scroll wheel and a dedicated slider in the new "Zoom & Pan" section.</li>
                        <li><strong>"Zoom & Pan" Section:</strong> New toolbox section for zoom and pan controls.</li>
                        <li><strong>Timeline Text Removed:</strong> "Timeline" heading removed as requested.</li>
                        <li><strong>Help Text Updated:</strong> Included instructions for the new zoom feature.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 28, 2025 - Canvas Resizing & UI Refinements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Canvas Resizing:</strong> Added ability to change project width and height in Customize modal. Existing frames scale proportionally.</li>
                        <li><strong>Customize Button Relocated:</strong> Moved to the "Project" section for better organization.</li>
                        <li><strong>Onion Skinning Removed:</strong> Feature removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Layout & Drawing Stability</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Brush Offset:</strong> Drawing now consistently aligns with cursor regardless of timeline changes.</li>
                        <li><strong>Timeline Horizontal Scroll:</strong> Timeline now scrolls horizontally when many frames are added, preventing vertical layout shifts.</li>
                        <li><strong>Improved GIF Export:</strong> More reliable GIF generation due to consistent internal canvas dimensions.</li>
                        <li>**Help Text Updated:** Added a new tip regarding browser zoom and refreshing.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 25, 2025 - Critical Bug Fixes & Improvements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Drawing:</strong> Drawing tools now work correctly and responsively.</li>
                        <li><strong>Fixed Undo/Redo:</strong> History system is fully functional.</li>
                        <li><strong>Fixed Generate Idea:</strong> AI idea generator now works as expected.</li>
                        <li><strong>Fixed Updates Button:</strong> The updates modal now opens correctly.</li>
                        <li><strong>Restored Message Display:</strong> Temporary on-screen messages are back for user feedback.</li>
                        <li><strong>Fixed Fill Tool:</strong> Now accurately fills areas regardless of pan.</li>
                        <li><strong>Fixed Eyedropper Tool:</strong> Accurately picks colors from the canvas.</li>
                        <li>**Enhanced Responsiveness:** Significant performance improvements for drawing and canvas interactions.</li>
                        <li>**Removed Zoom Feature:** Canvas no longer supports zoom, focusing on direct drawing.</li>
                        <li>**Pipette Icon Update:** Changed to üíâ emoji.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 23, 2025 - Initial Feature Enhancements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Undo/Redo History:</strong> Easily correct mistakes with multiple steps.</li>
                        <li><strong>Pan Tool:</strong> Navigate the canvas for detailed work or overview.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 22, 2025 - Basic Drawing & Animation</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Basic Drawing Tools:</strong> Brush, Eraser, Fill.</li>
                        <li><strong>Frame Management:</strong> Add, delete, duplicate, clear frames.</li>
                        <li><strong>Animation Playback:</strong> Play, pause, stop animation with adjustable speed.</li>
                        <li><strong>Project Save/Load:</strong> Save and load your animation projects locally.</li>
                        <li><strong>GIF Export:</strong> Export your animation as a GIF.</li>
                        <li><strong>AI Idea Generator:</strong> Get creative ideas for your frames.</li>
                        <li><strong>Touch Support:</strong> Basic drawing on touch devices like iPad.</li>
                        <li><strong>Palm Rejection:</strong> Option to enable stylus-only drawing.</li>
                    </ul>
                </div>
            </div>
            <button id="closeUpdatesModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200 flex-shrink-0">
                Close
            </button>
        </div>
    </div>

    <div id="customizeModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚öôÔ∏è Customize Editor</h3>
            <div class="space-y-4">
                <div>
                    <label for="projectWidth" class="block text-sm font-medium text-gray-700">Project Width (px):</label>
                    <input type="number" id="projectWidth" min="100" max="2000" value="800"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="projectHeight" class="block text-sm font-medium text-gray-700">Project Height (px):</label>
                    <input type="number" id="projectHeight" min="100" max="1500" value="600"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyCanvasSizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Canvas Size
                </button>
                <button id="resetCanvasSizeBtn" class="w-full bg-gray-300 text-gray-800 px-4 py-2 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Reset to Default (800x600)
                </button>
            </div>
            <button id="closeCustomizeModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="brushSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-xs">
            <h3 class="text-xl font-bold text-gray-800 mb-4 text-center">Choose Brush</h3>
            <div class="flex flex-col space-y-3">
                <button id="selectBrushTool" class="bg-blue-500 text-white px-4 py-2 rounded-lg shadow-sm hover:bg-blue-600">Brush</button>
                <button id="selectPenTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pen</button>
                <button id="selectPencilTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Pencil</button>
                <button id="selectWatercolorTool" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-lg shadow-sm hover:bg-blue-100">Watercolor</button>
            </div>
            <button id="closeBrushSelectionModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="textToolModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md flex flex-col">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">üÖ∞Ô∏è Add Text</h3>
            <textarea id="textInput" class="w-full p-3 border border-gray-300 rounded-lg mb-4 h-24 resize-y focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Type your text here..."></textarea>
            
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <div class="flex-1">
                    <label for="fontFamilySelect" class="block text-sm font-medium text-gray-700">Font Family:</label>
                    <select id="fontFamilySelect" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="Inter, sans-serif">Inter</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Courier New, monospace">Courier New</option>
                        <option value="Comic Sans MS, cursive">Comic Sans MS</option>
                    </select>
                </div>
                <div class="flex-1">
                    <label for="fontSizeInput" class="block text-sm font-medium text-gray-700">Font Size (px):</label>
                    <input type="number" id="fontSizeInput" min="10" max="200" value="30" class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>

            <div class="flex gap-4 mb-4">
                <div class="flex items-center">
                    <input type="checkbox" id="fontBoldToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                    <label for="fontBoldToggle" class="text-sm font-medium text-gray-700">Bold</label>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="fontItalicToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                    <label for="fontItalicToggle" class="text-sm font-medium text-gray-700">Italic</label>
                </div>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Text Preview:</label>
                <canvas id="textPreviewCanvas" class="w-full border border-gray-300 rounded-lg bg-gray-50" width="400" height="100"></canvas>
            </div>

            <div class="flex gap-4 mt-auto">
                <button id="placeTextBtn" class="flex-1 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Place Text
                </button>
                <button id="cancelTextBtn" class="flex-1 bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <div id="resizeSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Resize Selection</h3>
            <div class="space-y-4">
                <div>
                    <label for="resizeWidth" class="block text-sm font-medium text-gray-700">New Width (px):</label>
                    <input type="number" id="resizeWidth" min="1" value="100"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="resizeHeight" class="block text-sm font-medium text-gray-700">New Height (px):</label>
                    <input type="number" id="resizeHeight" min="1" value="100"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyResizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Resize
                </button>
            </div>
            <button id="cancelResizeBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Cancel
            </button>
        </div>
    </div>

    <div id="stickerSelectionModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-lg flex flex-col">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Choose a Sticker</h3>
            <div id="stickerContainer" class="grid grid-cols-5 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2 overflow-y-auto max-h-96 pb-4">
                </div>
            <button id="closeStickerSelectionModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>


    <script>
        // --- Canvas and Context References ---
        const mainCanvas = document.getElementById('drawingCanvas');
        const mainCtx = mainCanvas.getContext('2d'); // Main rendering context

        const bufferCanvas = document.createElement('canvas'); // Off-screen canvas for drawing operations
        const bufferCtx = bufferCanvas.getContext('2d'); // Context for the off-screen buffer

        // --- Project Dimensions ---
        let projWidth = 800; // Default project width
        let projHeight = 600; // Default project height

        // --- UI Elements (Buttons, Sliders, Inputs) ---
        const msgDisplay = document.getElementById('messageDisplay'); // Element to display temporary user messages

        // Tool buttons
        const pencilToolBtn = document.getElementById('pencilTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const eyedropperToolBtn = document.getElementById('eyedropperTool');
        const panToolBtn = document.getElementById('panTool');
        const textToolBtn = document.getElementById('textTool');
        const lassoToolBtn = document.getElementById('lassoTool');
        const editToolBtn = document.getElementById('editTool'); // New Edit (Move) Tool
        const resizeToolBtn = document.getElementById('resizeTool'); // New Resize Tool
        const stickerToolBtn = document.getElementById('stickerTool'); // New Sticker Tool

        // Brush settings
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValueSpan = document.getElementById('opacityValue');
        const watercolorFlowSection = document.getElementById('watercolorFlowSection');
        const flowSlider = document.getElementById('flowSlider');
        const flowValueSpan = document.getElementById('flowValue');

        // Palm rejection toggle
        const stylusOnlyModeToggle = document.getElementById('stylusOnlyModeToggle');
        let isStylusOnlyModeEnabled = false;

        // Frame management buttons
        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        // Project actions
        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');

        // Playback controls
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animSpeedInput = document.getElementById('animationSpeed');
        const animSpeedValueSpan = document.getElementById('animationSpeedValue');

        // Timeline elements
        const timelineDiv = document.getElementById('timeline');
        const timelineContainer = document.getElementById('timelineContainer');

        // Idea generation modal elements
        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');

        // Help and Info modals
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
        const faqBtn = document.getElementById('faqBtn');
        const updatesBtn = document.getElementById('updatesBtn');
        const updatesModal = document.getElementById('updatesModal');
        const closeUpdatesModalBtn = document.getElementById('closeUpdatesModalBtn');

        // Undo/Redo buttons
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        // Palm rejection help
        const palmRejectionHelpIcon = document.getElementById('palmRejectionHelpIcon');
        const palmRejectionHelpModal = document.getElementById('palmRejectionHelpModal');
        const closePalmRejectionHelpModalBtn = document.getElementById('closePalmRejectionHelpModalBtn');

        // Customize canvas size modal
        const customizeBtn = document.getElementById('customizeBtn');
        const customizeModal = document.getElementById('customizeModal');
        const closeCustomizeModalBtn = document.getElementById('closeCustomizeModalBtn');
        const projectWidthInput = document.getElementById('projectWidth');
        const projectHeightInput = document.getElementById('projectHeight');
        const applyCanvasSizeBtn = document.getElementById('applyCanvasSizeBtn');
        const resetCanvasSizeBtn = document.getElementById('resetCanvasSizeBtn');

        // Brush selection modal (for pencil tool's double-click)
        const brushSelectionModal = document.getElementById('brushSelectionModal');
        const selectBrushToolBtn = document.getElementById('selectBrushTool');
        const selectPenToolBtn = document.getElementById('selectPenTool');
        const selectPencilToolBtn = document.getElementById('selectPencilTool');
        const selectWatercolorToolBtn = document.getElementById('selectWatercolorTool');
        const closeBrushSelectionModalBtn = document.getElementById('closeBrushSelectionModalBtn');

        // Text tool modal elements
        const textToolModal = document.getElementById('textToolModal');
        const textInput = document.getElementById('textInput');
        const fontFamilySelect = document.getElementById('fontFamilySelect');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const fontBoldToggle = document.getElementById('fontBoldToggle');
        const fontItalicToggle = document.getElementById('fontItalicToggle');
        const textPreviewCanvas = document.getElementById('textPreviewCanvas');
        const textPreviewCtx = textPreviewCanvas.getContext('2d');
        const placeTextBtn = document.getElementById('placeTextBtn');
        const cancelTextBtn = document.getElementById('cancelTextBtn');

        // Resize selection modal elements
        const resizeSelectionModal = document.getElementById('resizeSelectionModal');
        const resizeWidthInput = document.getElementById('resizeWidth');
        const resizeHeightInput = document.getElementById('resizeHeight');
        const applyResizeBtn = document.getElementById('applyResizeBtn');
        const cancelResizeBtn = document.getElementById('cancelResizeBtn');

        // Sticker selection modal elements
        const stickerSelectionModal = document.getElementById('stickerSelectionModal');
        const stickerContainer = document.getElementById('stickerContainer');
        const closeStickerSelectionModalBtn = document.getElementById('closeStickerSelectionModalBtn');

        // --- Application State Variables ---
        let drawingActive = false; // True when a drawing stroke is in progress
        let brushColor = '#000000'; // Current drawing color
        let brushSize = 5; // Current brush size
        let currentOpacity = 100; // Current drawing opacity (0-100)
        let watercolorFlow = 50; // Flow setting for watercolor brush
        let currentTool = 'brush'; // Currently active tool (e.g., 'brush', 'eraser', 'fill', 'lasso', 'edit', 'resize', 'sticker')

        let framesData = []; // Array to store base64 image data for each animation frame
        let currentFrameIdx = 0; // Index of the currently active frame

        let animPlaying = false; // True if animation is currently playing
        let fps = 10; // Frames per second for animation playback
        let animInterval = null; // Interval ID for animation loop

        let exporting = false; // True if GIF export is in progress
        let exportProg = 0; // GIF export progress (0-100)

        let historyStates = []; // Array to store canvas states for undo/redo
        let historyPtr = -1; // Current position in the historyStates array
        const MAX_HISTORY_STATES = 50; // Maximum number of undo/redo states

        let panOffset = { x: 0, y: 0 }; // Current pan offset for the canvas view
        let panningActive = false; // True if panning is in progress
        let lastPanPt = { x: 0, y: 0 }; // Last mouse/touch position during panning

        const imageCache = new Map(); // Cache for loaded image data (frames) to improve performance

        let draggedFrameIndex = null; // Index of the frame being dragged in the timeline

        let awaitingTextPlacement = false; // True when text tool is active and waiting for click to place text
        let textToPlace = ''; // Text string to be placed
        let textFont = ''; // Font style string for text

        let lassoPoints = []; // Array of points defining the lasso selection path
        let isLassoing = false; // True if a lasso selection is currently being drawn
        let selectedImageData = null; // Stores the canvas element of the lasso-selected region
        let isMovingSelection = false; // True if a lasso selection is currently being moved/dragged by the Edit tool
        let selectionOffset = { x: 0, y: 0 }; // Offset of the selectedImageData relative to canvas origin
        let selectionStartProjectPoint = { x: 0, y: 0 }; // Mouse position in project coords when moving started
        let initialSelectionOffsetAtDragStart = { x: 0, y: 0 }; // selectionOffset at the start of a drag

        let awaitingStickerPlacement = false; // True when sticker tool is active and waiting for click to place sticker
        let stickerToPlace = null; // Stores the selected sticker object {emoji: '...', size: ...}

        // Predefined list of stickers (emojis) with their default sizes
        const availableStickers = [
            { emoji: 'üòÄ', size: 50 }, { emoji: 'üòÇ', size: 50 }, { emoji: 'üòç', size: 50 },
            { emoji: 'ü§©', size: 50 }, { emoji: 'ü•≥', size: 50 }, { emoji: 'üòá', size: 50 },
            { emoji: 'üòé', size: 50 }, { emoji: 'ü§ì', size: 50 }, { emoji: 'ü§î', size: 50 },
            { emoji: 'üòè', size: 50 }, { emoji: 'ü•∫', size: 50 }, { emoji: 'ü§Ø', size: 50 },
            { emoji: 'üëç', size: 50 }, { emoji: '‚ù§Ô∏è', size: 50 }, { emoji: 'üåü', size: 50 },
            { emoji: 'üåà', size: 50 }, { emoji: 'üöÄ', size: 50 }, { emoji: 'üí°', size: 50 },
            { emoji: 'üéâ', size: 50 }, { emoji: 'üî•', size: 50 }, { emoji: 'üíØ', size: 50 },
            { emoji: '‚úÖ', size: 50 }, { emoji: 'üé∂', size: 50 }, { emoji: 'üê±', size: 50 },
            { emoji: 'üê∂', size: 50 }, { emoji: 'üêº', size: 50 }, { emoji: 'üçé', size: 50 },
            { emoji: 'üçï', size: 50 }, { emoji: '‚òï', size: 50 }, { emoji: 'üéà', size: 50 }
        ];

        // --- Utility Functions ---

        /**
         * Displays a temporary message to the user.
         * @param {string} msg - The message to display.
         */
        function showUserMessage(msg) {
            // Clear any existing timeout to prevent messages from disappearing too quickly
            if (msgDisplay._timeoutId) {
                clearTimeout(msgDisplay._timeoutId);
            }
            msgDisplay.textContent = msg;
            msgDisplay.classList.remove('hidden', 'opacity-0'); // Show message
            msgDisplay.classList.add('opacity-100'); // Fade in

            // Set a timeout to hide the message after 2 seconds
            msgDisplay._timeoutId = setTimeout(() => {
                msgDisplay.classList.remove('opacity-100'); // Fade out
                msgDisplay.classList.add('opacity-0');
                // Fully hide after fade out
                msgDisplay._timeoutId = setTimeout(() => msgDisplay.classList.add('hidden'), 500);
            }, 2000);
        }

        /**
         * Converts a hexadecimal color string to an RGBA array.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @returns {number[]} An array [R, G, B, A] where A is always 255.
         */
        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255]; // Alpha is always 255 (fully opaque)
        }

        /**
         * Converts an RGBA color array to a hexadecimal color string.
         * @param {number} r - Red component (0-255).
         * @param {number} g - Green component (0-255).
         * @param {number} b - Blue component (0-255).
         * @returns {string} The hexadecimal color string (e.g., "#RRGGBB").
         */
        function rgbaToHex(r, g, b) {
            // Convert RGB components to hex and pad with leading zeros if necessary
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        /**
         * Loads an image from a given source URL (or data URL) and caches it.
         * This helps prevent re-loading the same image multiple times, improving performance.
         * @param {string} src - The image source (URL or base64 data URL).
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the loaded Image object.
         */
        function loadImage(src) {
            // Return cached image if available
            if (imageCache.has(src)) {
                return Promise.resolve(imageCache.get(src));
            }
            // Load image and cache it
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache.set(src, img); // Store in cache
                    resolve(img);
                };
                img.onerror = reject; // Reject promise on error if image fails to load
                img.src = src;
            });
        }

        /**
         * Saves the current state of framesData to the history stack for undo/redo functionality.
         * It manages the history pointer and limits the number of stored states.
         */
        function saveStateToHistory() {
            // If the history pointer is not at the end (meaning we've undone some actions),
            // clear any "future" (redo) states to ensure a linear history.
            if (historyPtr < historyStates.length - 1) {
                historyStates = historyStates.slice(0, historyPtr + 1);
            }
            // Add the current frames data to the history.
            // We use JSON.parse(JSON.stringify()) for a deep copy to ensure that
            // future modifications to `framesData` don't affect past history states.
            historyStates.push(JSON.parse(JSON.stringify(framesData)));
            historyPtr++; // Move the history pointer to the new state

            // Enforce the maximum history size. If we exceed it, remove the oldest state.
            if (historyStates.length > MAX_HISTORY_STATES) {
                historyStates.shift(); // Remove the first (oldest) element
                historyPtr--; // Adjust the pointer as the array shifted
            }
            updateUndoRedoButtons(); // Update the visual state of the undo/redo buttons
        }

        /**
         * Reverts the canvas to the previous state in the history stack.
         */
        function performUndo() {
            if (historyPtr > 0) { // Check if there's a previous state to undo to
                historyPtr--; // Move the pointer back one step
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr])); // Load the previous state
                loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Update the canvas display
                updateTimelineDisplay(); // Refresh the timeline to reflect any changes
                updateUndoRedoButtons(); // Update button states
                showUserMessage('Undo successful!');
            }
        }

        /**
         * Advances the canvas to the next state in the history stack (after an undo).
         */
        function performRedo() {
            if (historyPtr < historyStates.length - 1) { // Check if there's a future state to redo to
                historyPtr++; // Move the pointer forward one step
                framesData = JSON.parse(JSON.stringify(historyStates[historyPtr])); // Load the next state
                loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Update the canvas display
                updateTimelineDisplay(); // Refresh the timeline
                updateUndoRedoButtons(); // Update button states
                showUserMessage('Redo successful!');
            }
        }

        /**
         * Updates the disabled state of the Undo and Redo buttons based on the current history pointer position.
         */
        function updateUndoRedoButtons() {
            undoBtn.disabled = !(historyPtr > 0); // Disable Undo if at the beginning of history
            redoBtn.disabled = !(historyPtr < historyStates.length - 1); // Disable Redo if at the end of history
        }

        /**
         * Loads a specific frame's image data (base64 PNG) onto the off-screen buffer canvas.
         * This function is crucial for preparing frame content for drawing or display.
         * @param {string} frameData - Base64 image data of the frame.
         */
        async function loadFrameIntoBuffer(frameData) {
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height); // Clear the entire buffer canvas
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height); // Fill with a white background

            // Check if frameData is valid and starts with the expected data URL prefix
            if (frameData && typeof frameData === 'string' && frameData.startsWith('data:image/png;base64,')) {
                try {
                    // Get the image from cache or load it if not cached
                    const img = imageCache.get(frameData) || await loadImage(frameData);
                    // Draw the loaded image onto the buffer canvas, scaled to fit its dimensions
                    bufferCtx.drawImage(img, 0, 0, bufferCanvas.width, bufferCanvas.height);
                } catch (error) {
                    console.error("Oops, couldn't load frame data into the buffer:", error);
                }
            }
        }

        /**
         * Converts project coordinates (internal canvas coordinates) to display coordinates (main canvas coordinates).
         * This is essential for accurately mapping drawing operations and visual feedback from the internal
         * project dimensions to the user's view on the screen, accounting for scaling, centering, and panning.
         * @param {number} projX - X coordinate in project space.
         * @param {number} projY - Y coordinate in project space.
         * @returns {{x: number, y: number}} The corresponding coordinates on the main display canvas.
         */
        function getDisplayCoords(projX, projY) {
            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            // Adjust display content dimensions to fit within mainCanvas while maintaining aspect ratio.
            // This ensures the drawing area is always visible and correctly scaled.
            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            // Calculate offsets to center the content within the main canvas.
            const offsetX = (mainCanvas.width - displayContentWidth) / 2;
            const offsetY = (mainCanvas.height - displayContentHeight) / 2;

            // Scale project coordinates to display content size, then apply centering offsets and current pan offset.
            const canvasX = (projX * displayContentWidth / projWidth) + offsetX + panOffset.x;
            const canvasY = (projY * displayContentHeight / projHeight) + offsetY + panOffset.y;
            return { x: canvasX, y: canvasY };
        }

        /**
         * Renders the content of the off-screen buffer canvas onto the main display canvas.
         * It also handles drawing visual overlays like the lasso selection outline and
         * the semi-transparent "ghost" of a selected image being moved or resized.
         */
        async function renderCanvasDisplay() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height); // Clear the entire main canvas
            mainCtx.fillStyle = '#ffffff';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height); // Fill with a white background

            mainCtx.save(); // Save the current state of the main canvas context

            mainCtx.translate(panOffset.x, panOffset.y); // Apply the current pan offset to the context

            // Calculate display dimensions for the project content, maintaining its aspect ratio.
            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            // Calculate offsets to center the scaled project content within the main canvas.
            const offsetX = (mainCanvas.width - displayContentWidth) / 2;
            const offsetY = (mainCanvas.height - displayContentHeight) / 2;

            mainCtx.globalAlpha = 1.0; // Ensure full opacity for the base drawing
            mainCtx.globalCompositeOperation = 'source-over'; // Default blend mode for drawing
            // Draw the content from the buffer canvas onto the main canvas, scaled and positioned.
            mainCtx.drawImage(bufferCanvas, offsetX, offsetY, displayContentWidth, displayContentHeight);

            // If the lasso tool is active and a lasso path is being drawn, render its outline.
            if (currentTool === 'lasso' && isLassoing && lassoPoints.length > 1) {
                mainCtx.save(); // Save context state before drawing outline
                mainCtx.strokeStyle = 'blue';
                mainCtx.lineWidth = 2;
                mainCtx.setLineDash([5, 5]); // Create a dashed line for the selection
                mainCtx.beginPath();
                const firstPoint = getDisplayCoords(lassoPoints[0].x, lassoPoints[0].y);
                mainCtx.moveTo(firstPoint.x, firstPoint.y);
                for (let i = 1; i < lassoPoints.length; i++) {
                    const point = getDisplayCoords(lassoPoints[i].x, lassoPoints[i].y);
                    mainCtx.lineTo(point.x, point.y);
                }
                mainCtx.stroke(); // Draw the lasso path
                mainCtx.restore(); // Restore context state
            }

            // If the Edit or Resize tool is active and there's selected image data (a "ghost"), render it.
            if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection && selectedImageData) {
                mainCtx.save(); // Save context state before drawing ghost
                mainCtx.globalAlpha = 0.8; // Make the ghost semi-transparent
                // Calculate the display position and size of the selected image data based on its current offset.
                const displaySelectionX = (selectionOffset.x * displayContentWidth / projWidth) + offsetX;
                const displaySelectionY = (selectionOffset.y * displayContentHeight / projHeight) + offsetY;
                
                const displaySelectionWidth = selectedImageData.width * displayContentWidth / projWidth;
                const displaySelectionHeight = selectedImageData.height * displayContentHeight / projHeight;

                mainCtx.drawImage(selectedImageData, displaySelectionX, displaySelectionY, displaySelectionWidth, displaySelectionHeight);
                mainCtx.restore(); // Restore context state
            }

            // Draw a dashed border around the active drawing area (project canvas boundaries).
            mainCtx.strokeStyle = '#888888';
            mainCtx.lineWidth = 2;
            mainCtx.setLineDash([5, 5]);
            mainCtx.strokeRect(offsetX, offsetY, displayContentWidth, displayContentHeight);
            mainCtx.setLineDash([]); // Reset line dash to solid for subsequent drawings

            mainCtx.restore(); // Restore the main canvas context to its state before any pan/transformations
            mainCtx.globalAlpha = 1.0; // Reset global alpha to full opacity
            mainCtx.globalCompositeOperation = 'source-over'; // Reset composite operation to default
        }

        /**
         * Saves the current content of the off-screen buffer canvas as a base64 PNG data URL
         * and updates the `framesData` array for the `currentFrameIdx`. This effectively
         * "commits" the current drawing to the active frame.
         */
        function saveCurrentFrameData() {
            framesData[currentFrameIdx] = bufferCanvas.toDataURL('image/png');
        }

        /**
         * Converts client coordinates (from mouse/touch events relative to the viewport)
         * to project coordinates (internal canvas coordinates). This is the inverse of `getDisplayCoords`
         * and is used to translate user input on the screen to positions within the drawing project.
         * @param {number} clientX - X coordinate from mouse/touch event (relative to viewport).
         * @param {number} clientY - Y coordinate from mouse/touch event (relative to viewport).
         * @returns {{x: number, y: number}} The corresponding coordinates in project space.
         */
        function getTransformedDrawingCoords(clientX, clientY) {
            const rect = mainCanvas.getBoundingClientRect(); // Get the size and position of the main canvas element
            const canvasX = clientX - rect.left; // X coordinate relative to the canvas element's top-left corner
            const canvasY = clientY - rect.top; // Y coordinate relative to the canvas element's top-left corner

            // Calculate display content dimensions based on the project's aspect ratio.
            // This logic mirrors what's in `renderCanvasDisplay` to ensure consistent scaling.
            const aspectRatio = projWidth / projHeight;
            let displayContentWidth = mainCanvas.width;
            let displayContentHeight = mainCanvas.width / aspectRatio;

            if (displayContentHeight > mainCanvas.height) {
                displayContentHeight = mainCanvas.height;
                displayContentWidth = mainCanvas.height * aspectRatio;
            }

            // Calculate offsets for centering the scaled content within the main canvas.
            const displayOffsetX = (mainCanvas.width - displayContentWidth) / 2;
            const displayOffsetY = (mainCanvas.height - displayContentHeight) / 2;

            // Reverse the transformations:
            // 1. Remove the current pan offset.
            // 2. Remove the centering offset.
            // 3. Scale back from display content dimensions to original project dimensions.
            const transformedX = (canvasX - panOffset.x - displayOffsetX);
            const transformedY = (canvasY - panOffset.y - displayOffsetY);

            const x = transformedX * (projWidth / displayContentWidth);
            const y = transformedY * (projHeight / displayContentHeight);

            return { x, y };
        }

        /**
         * Handles the start of a mouse or touch interaction (mousedown, touchstart) on the canvas.
         * This is the entry point for most drawing, panning, and selection operations.
         * It determines the active tool and initializes relevant state variables.
         * @param {Event} e - The mouse or touch event.
         */
        async function handleInteractionStart(e) {
            e.preventDefault(); // Prevent default browser actions (e.g., scrolling, text selection)

            // If the application is currently waiting for text or sticker placement,
            // ignore other interaction starts to prevent unintended drawing.
            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            // Get client coordinates from the event, handling both mouse and touch events.
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // Implement palm rejection: if stylus-only mode is enabled and the input is from a finger, ignore it.
            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct'; // 'direct' typically means finger, 'stylus' for pen
                if (touchType === 'direct') {
                    drawingActive = false; // Prevent drawing from finger touches
                    return;
                }
            }

            // --- Tool-specific logic for interaction start ---

            // Eyedropper tool: pick a color from the canvas.
            if (currentTool === 'eyedropper') {
                const rect = mainCanvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                // Get the pixel data at the clicked point on the main display canvas.
                const imageData = mainCtx.getImageData(canvasX, canvasY, 1, 1).data;
                brushColor = rgbaToHex(imageData[0], imageData[1], imageData[2]); // Convert RGBA to hex color
                brushColorInput.value = brushColor; // Update the color picker UI
                bufferCtx.strokeStyle = brushColor; // Set the stroke style for the drawing buffer
                
                currentTool = 'brush'; // Revert to the brush tool after picking a color
                updateToolButtonStates(); // Update the UI to show the active tool
                showUserMessage('Color picked!');
                return; // Exit function after handling eyedropper
            }

            // Pan tool: start dragging the canvas view.
            if (currentTool === 'pan') {
                panningActive = true; // Set panning state to active
                lastPanPt = { x: clientX, y: clientY }; // Record the starting mouse/touch position
                return; // Exit function after handling pan
            }

            // Fill tool: perform a flood fill operation.
            if (currentTool === 'fill') {
                await loadFrameIntoBuffer(framesData[currentFrameIdx]); // Ensure the buffer has the current frame's content
                const { x, y } = getTransformedDrawingCoords(clientX, clientY); // Get the project coordinates of the click
                floodFill(x, y, hexToRgba(brushColor), bufferCtx, bufferCanvas.width, bufferCanvas.height); // Execute flood fill
                saveCurrentFrameData(); // Save the modified frame data
                renderCanvasDisplay(); // Update the main canvas display
                saveStateToHistory(); // Save the state for undo/redo
                showUserMessage('Fill applied!');
                return; // Exit function after handling fill
            }

            // Lasso tool: start drawing a freehand selection.
            if (currentTool === 'lasso') {
                await loadFrameIntoBuffer(framesData[currentFrameIdx]); // Ensure buffer has current frame content
                lassoPoints = []; // Initialize an empty array for lasso points
                isLassoing = true; // Set lassoing state to active
                const { x, y } = getTransformedDrawingCoords(clientX, clientY); // Get project coordinates
                lassoPoints.push({ x, y }); // Add the first point to the lasso path
                return; // Exit function after handling lasso
            }

            // Edit (Move) or Resize tool: start moving a selected image (if one exists).
            if (currentTool === 'edit' || currentTool === 'resize') {
                if (selectedImageData) { // Check if there's an active selection to move/resize
                    isMovingSelection = true; // Set moving state to active
                    selectionStartProjectPoint = getTransformedDrawingCoords(clientX, clientY); // Record the starting point of the drag in project coords
                    initialSelectionOffsetAtDragStart = { x: selectionOffset.x, y: selectionOffset.y }; // Store the selection's current offset
                    return; // Exit function after handling edit/resize move start
                } else {
                    showUserMessage('No selection to move/resize. Use Lasso tool first.');
                    return; // Exit if no selection to move
                }
            }

            // --- General drawing tool setup (brush, eraser, pen, watercolor) ---
            // These settings apply to tools that draw strokes on the canvas.
            bufferCtx.lineCap = 'round'; // Ensures rounded ends for lines
            bufferCtx.lineJoin = 'round'; // Ensures rounded corners for lines
            bufferCtx.strokeStyle = brushColor; // Set the stroke color to the current brush color
            bufferCtx.lineWidth = brushSize; // Set the line thickness
            bufferCtx.globalCompositeOperation = 'source-over'; // Default blend mode (new pixels draw over old ones)

            bufferCtx.shadowBlur = 0; // Reset shadow blur
            bufferCtx.shadowColor = 'transparent'; // Reset shadow color (important for non-watercolor tools)

            // Apply tool-specific global alpha (transparency) and shadow effects.
            if (currentTool === 'pencil') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 0.4; // Lighter alpha for a pencil-like effect
            } else if (currentTool === 'brush') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 0.7; // Medium alpha for a brush-like effect
            } else if (currentTool === 'pen') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * 1.0; // Full opacity for a solid pen line
            } else if (currentTool === 'watercolor') {
                bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1; // Very low alpha for watercolor accumulation
                bufferCtx.shadowColor = brushColor; // Watercolor effect uses shadow for spread
                bufferCtx.shadowBlur = brushSize * (watercolorFlow / 100) * 0.7; // Shadow blur based on size and flow
            }
            
            const { x, y } = getTransformedDrawingCoords(clientX, clientY); // Get the starting coordinates in project space
            bufferCtx.beginPath(); // Start a new drawing path
            bufferCtx.moveTo(x, y); // Move the drawing cursor to the starting point
            drawingActive = true; // Set the drawing state to active
        }

        /**
         * Handles mouse or touch movement (mousemove, touchmove) on the canvas.
         * It updates the drawing, panning, or selection movement based on the active tool.
         * @param {Event} e - The mouse or touch event.
         */
        async function handleInteractionMove(e) {
            e.preventDefault(); // Prevent default browser actions (e.g., scrolling, text selection)

            // If the application is awaiting text or sticker placement, ignore movement.
            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            // Get client coordinates from the event, handling both mouse and touch events.
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // Implement palm rejection: if stylus-only mode is enabled and the input is from a finger, ignore it.
            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    drawingActive = false; // Prevent drawing from finger touches
                    return;
                }
            }

            // --- Tool-specific logic for interaction move ---

            // Pan tool: update the canvas pan offset.
            if (currentTool === 'pan' && panningActive) {
                const dx = clientX - lastPanPt.x; // Calculate change in X since last move
                const dy = clientY - lastPanPt.y; // Calculate change in Y since last move
                panOffset.x += dx; // Update the global pan offset
                panOffset.y += dy;
                lastPanPt = { x: clientX, y: clientY }; // Update the last recorded position
                renderCanvasDisplay(); // Re-render the canvas to show the new pan position
                return; // Exit function after handling pan
            }

            // Lasso tool: continue drawing the lasso path.
            if (currentTool === 'lasso' && isLassoing) {
                const { x, y } = getTransformedDrawingCoords(clientX, clientY); // Get current project coordinates
                lassoPoints.push({ x, y }); // Add the new point to the lasso path
                renderCanvasDisplay(); // Re-render to update the lasso outline
                return; // Exit function after handling lasso
            }

            // Edit (Move) or Resize tool: update the position of the selected image data.
            if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection) {
                const currentProjectPoint = getTransformedDrawingCoords(clientX, clientY); // Get current project coordinates

                // Calculate the displacement from where the drag started.
                const dx = currentProjectPoint.x - selectionStartProjectPoint.x;
                const dy = currentProjectPoint.y - selectionStartProjectPoint.y;

                // Update the selection's offset by adding the displacement to its initial offset.
                // This maintains the relative position of the mouse cursor within the selected image.
                selectionOffset.x = initialSelectionOffsetAtDragStart.x + dx;
                selectionOffset.y = initialSelectionOffsetAtDragStart.y + dy;

                renderCanvasDisplay(); // Re-render to show the moving ghost image
                return; // Exit function after handling edit/resize move
            }

            // If no specific tool is active for movement (i.e., a drawing tool is active),
            // continue the drawing stroke.
            if (!drawingActive) return; // If drawing is not active, do nothing

            const { x, y } = getTransformedDrawingCoords(clientX, clientY); // Get current project coordinates
            
            // Set global composite operation based on the tool (eraser or normal drawing).
            if (currentTool === 'eraser') {
                bufferCtx.globalCompositeOperation = 'destination-out'; // Erase by making pixels transparent
            } else {
                bufferCtx.globalCompositeOperation = 'source-over'; // Normal drawing (new pixels drawn over existing)
            }

            bufferCtx.lineTo(x, y); // Draw a line segment to the current point
            bufferCtx.stroke(); // Apply the stroke to the path
            renderCanvasDisplay(); // Update the main canvas display with the new stroke
        }

        /**
         * Handles the end of a mouse or touch interaction (mouseup, touchend, mouseleave, touchcancel) on the canvas.
         * It finalizes drawing strokes, lasso selections, or pan operations, and cleans up temporary states.
         * @param {Event} e - The mouse or touch event.
         */
        async function handleInteractionEnd(e) {
            e.preventDefault(); // Prevent default browser actions

            // If the application is awaiting text or sticker placement, ignore interaction end.
            if (awaitingTextPlacement || awaitingStickerPlacement) {
                return;
            }

            // --- Tool-specific logic for interaction end ---

            // Lasso tool: finalize the selection path.
            if (currentTool === 'lasso') {
                if (isLassoing) { // If a lasso selection was actively being drawn
                    isLassoing = false; // Stop lasso drawing
                    if (lassoPoints.length > 2) { // Ensure at least a triangle is formed (minimum for a valid shape)
                        await extractLassoSelection(); // Extract the selected area from the canvas
                        showUserMessage('Lasso selection made. Use the Edit tool to move/place, or Resize tool to change size.');
                    } else {
                        showUserMessage('Lasso selection too small. Try again.'); // Inform user if selection is too small
                    }
                    currentTool = 'brush'; // Revert to the default brush tool after lassoing
                    updateToolButtonStates(); // Update the UI to reflect the tool change
                    renderCanvasDisplay(); // Re-render the canvas to clear the lasso outline
                    return; // Exit function after handling lasso end
                }
            }

            // For drawing tools (not fill, eyedropper, pan, edit, resize, sticker)
            // This block finalizes drawing strokes (pencil, brush, pen, watercolor, eraser).
            if (currentTool !== 'fill' && currentTool !== 'eyedropper' && currentTool !== 'pan' &&
                currentTool !== 'edit' && currentTool !== 'resize' && currentTool !== 'sticker') {
                if (drawingActive) { // If a drawing stroke was in progress
                    bufferCtx.closePath(); // Close the current drawing path
                    bufferCtx.globalCompositeOperation = 'source-over'; // Reset blend mode to default
                    bufferCtx.globalAlpha = 1.0; // Reset global alpha to full opacity
                    bufferCtx.shadowBlur = 0; // Clear any active shadow blur
                    bufferCtx.shadowColor = 'transparent'; // Reset shadow color
                    saveCurrentFrameData(); // Save the completed stroke to the current frame's data
                    saveStateToHistory(); // Save the canvas state for undo/redo
                }
            }
            drawingActive = false; // Deactivate general drawing state
            panningActive = false; // Deactivate panning state

            // If the current tool is 'edit' or 'resize', the `isMovingSelection` flag remains true
            // until the user explicitly clicks to place the selection via `placeLassoSelection()`.
            // We only re-render to clear the ghost if we are *not* in edit/resize mode,
            // as the ghost needs to persist for placement.
            if (!(currentTool === 'edit' || currentTool === 'resize')) {
                 renderCanvasDisplay(); // Re-render the canvas to ensure visual consistency
            }
        }

        /**
         * Implements a flood fill algorithm to fill a contiguous area with a specified color.
         * This is used by the fill bucket tool.
         * @param {number} startX - The X coordinate (in project space) to start the fill from.
         * @param {number} startY - The Y coordinate (in project space) to start the fill from.
         * @param {number[]} fillColor - The RGBA color array to fill with (e.g., [255, 0, 0, 255] for red).
         * @param {CanvasRenderingContext2D} ctx - The canvas rendering context to perform the fill on.
         * @param {number} width - The width of the canvas.
         * @param {number} height - The height of the canvas.
         */
        function floodFill(startX, startY, fillColor, ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height); // Get all pixel data from the canvas
            const pixels = imageData.data; // Access the raw pixel array (R, G, B, A for each pixel)

            /**
             * Helper function to get the RGBA color of a pixel at specified coordinates.
             * @param {number} x - X coordinate.
             * @param {number} y - Y coordinate.
             * @returns {number[]} An array [R, G, B, A] or [-1, -1, -1, -1] if out of bounds.
             */
            const getPixelColor = (x, y) => {
                // Check for out-of-bounds coordinates
                if (x < 0 || x >= width || y < 0 || y >= height) return [-1, -1, -1, -1];
                const index = (y * width + x) * 4; // Calculate the starting index in the pixel array
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            /**
             * Helper function to set the RGBA color of a pixel at specified coordinates.
             * @param {number} x - X coordinate.
             * @param {number} y - Y coordinate.
             * @param {number[]} color - The RGBA color array to set.
             */
            const setPixelColor = (x, y, color) => {
                const index = (y * width + x) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            const startColor = getPixelColor(Math.floor(startX), Math.floor(startY)); // Get the color of the pixel where the fill starts

            // If the starting pixel is out of bounds or already the fill color, there's nothing to do.
            if (startColor[0] === -1 || (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3])) {
                return;
            }

            const pixelStack = [[Math.floor(startX), Math.floor(startY)]]; // Initialize a stack for a Breadth-First Search (BFS) or Depth-First Search (DFS)
            const visited = new Set(); // Use a Set to efficiently track visited pixels and prevent infinite loops

            /**
             * Helper function to check if two colors are "similar" within a given tolerance.
             * This is important for anti-aliased edges where colors might not be exact matches.
             * @param {number[]} color1 - First RGBA color.
             * @param {number[]} color2 - Second RGBA color.
             * @param {number} tolerance - Maximum allowed difference for each color component.
             * @returns {boolean} True if colors are similar, false otherwise.
             */
            const colorsMatch = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            // Main flood fill loop: continues as long as there are pixels in the stack to process.
            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop(); // Get the next pixel from the stack
                const key = `${x},${y}`; // Create a unique string key for the pixel's coordinates

                if (visited.has(key)) continue; // If this pixel has already been visited, skip it
                visited.add(key); // Mark the current pixel as visited

                // Check if the pixel is within canvas bounds and if its color matches the starting color (within tolerance).
                if (x >= 0 && x < width && y >= 0 && y < height && colorsMatch(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor); // Change the pixel's color to the fill color

                    // Add neighboring pixels to the stack for further processing.
                    // This explores the contiguous area.
                    pixelStack.push([x + 1, y]); // Right
                    pixelStack.push([x - 1, y]); // Left
                    pixelStack.push([x, y + 1]); // Down
                    pixelStack.push([x, y - 1]); // Up
                }
            }
            ctx.putImageData(imageData, 0, 0); // Put the modified pixel data back onto the canvas
        }

        /**
         * Updates the display of frame buttons in the timeline.
         * It dynamically creates, styles, and attaches event listeners to each frame button.
         */
        function updateTimelineDisplay() {
            timelineDiv.innerHTML = ''; // Clear any existing frame buttons to rebuild the timeline
            framesData.forEach((_, index) => { // Iterate through each frame in the `framesData` array
                const frameButton = document.createElement('button');
                frameButton.textContent = `F${index + 1}`; // Display the frame number (e.g., "F1", "F2")
                frameButton.classList.add(
                    'frame-button', 'flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg',
                    'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold',
                    'transition-all', 'duration-200'
                );
                
                // Highlight the current active frame with distinct styling.
                if (index === currentFrameIdx) {
                    frameButton.classList.add('border-blue-600', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                } else {
                    frameButton.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                }
                
                // Attach a click handler to switch to the selected frame.
                frameButton.onclick = () => {
                    if (animPlaying) pauseAnimationPlayback(); // Pause animation if it's currently playing
                    currentFrameIdx = index; // Set the new current frame index
                    loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and render the content of the new frame
                    updateTimelineDisplay(); // Re-render the timeline to update the active frame's highlight
                };

                // Make frame buttons draggable for reordering functionality.
                frameButton.draggable = true;
                frameButton.dataset.frameIndex = index; // Store the original index as a data attribute

                // Attach drag and drop event listeners for reordering frames.
                frameButton.addEventListener('dragstart', handleDragStart);
                frameButton.addEventListener('dragover', handleDragOver);
                frameButton.addEventListener('dragenter', handleDragEnter);
                frameButton.addEventListener('dragleave', handleDragLeave);
                frameButton.addEventListener('drop', handleDrop);
                frameButton.addEventListener('dragend', handleDragEnd);

                timelineDiv.appendChild(frameButton); // Add the newly created button to the timeline container
            });
        }

        /**
         * Handles the `dragstart` event for a frame button in the timeline.
         * Initiates the drag operation and sets up data transfer.
         * @param {Event} e - The drag event.
         */
        function handleDragStart(e) {
            draggedFrameIndex = parseInt(e.target.dataset.frameIndex); // Get the index of the frame being dragged
            e.dataTransfer.effectAllowed = 'move'; // Specify that this is a "move" operation
            e.dataTransfer.setData('text/plain', draggedFrameIndex); // Store the dragged frame's index in the data transfer object
            e.target.classList.add('dragging'); // Add a visual class to indicate dragging
        }

        /**
         * Handles the `dragover` event for a frame button.
         * Prevents the default behavior to allow a drop operation.
         * @param {Event} e - The drag event.
         */
        function handleDragOver(e) {
            e.preventDefault(); // This is crucial to allow a drop on this element
            e.dataTransfer.dropEffect = 'move'; // Set the visual feedback for the drop operation
        }

        /**
         * Handles the `dragenter` event for a frame button.
         * Adds a visual indicator to show that the element is a valid drop target.
         * @param {Event} e - The drag event.
         */
        function handleDragEnter(e) {
            e.preventDefault();
            // Add the 'drag-over' class if the target is a frame button and not the one being dragged
            if (e.target.classList.contains('frame-button') && parseInt(e.target.dataset.frameIndex) !== draggedFrameIndex) {
                e.target.classList.add('drag-over');
            }
        }

        /**
         * Handles the `dragleave` event for a frame button.
         * Removes the visual indicator when the dragged item leaves the element.
         * @param {Event} e - The drag event.
         */
        function handleDragLeave(e) {
            e.target.classList.remove('drag-over'); // Remove the 'drag-over' class
        }

        /**
         * Handles the `drop` event for a frame button.
         * Reorders the frames in the `framesData` array based on the drag and drop operation.
         * @param {Event} e - The drag event.
         */
        function handleDrop(e) {
            e.preventDefault();
            const droppedOnIndex = parseInt(e.target.dataset.frameIndex); // Get the index of the frame where the item was dropped
            const draggedIndex = parseInt(e.dataTransfer.getData('text/plain')); // Retrieve the index of the dragged frame

            // If the dragged item is dropped on itself, or if indices are invalid, do nothing.
            if (draggedIndex === droppedOnIndex || isNaN(draggedIndex) || isNaN(droppedOnIndex)) {
                return;
            }

            const currentFrameContent = framesData[currentFrameIdx]; // Store the content of the currently active frame

            // Perform the reordering:
            // 1. Remove the dragged frame from its original position.
            const [draggedFrame] = framesData.splice(draggedIndex, 1);
            // 2. Insert the dragged frame at the new position.
            framesData.splice(droppedOnIndex, 0, draggedFrame);

            // After reordering, find the new index of the previously active frame
            currentFrameIdx = framesData.indexOf(currentFrameContent);

            updateTimelineDisplay(); // Re-render the timeline to reflect the new order
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Update the canvas display
            saveStateToHistory(); // Save the new state for undo/redo
            showUserMessage('Frame reordered!');
        }

        /**
         * Handles the `dragend` event for a frame button.
         * Cleans up any visual states related to dragging.
         * @param {Event} e - The drag event.
         */
        function handleDragEnd(e) {
            const frameButtons = timelineDiv.querySelectorAll('.frame-button');
            frameButtons.forEach(btn => {
                btn.classList.remove('dragging', 'drag-over'); // Remove all dragging-related classes
            });
            draggedFrameIndex = null; // Reset the dragged frame index
        }

        /**
         * Adds a new blank frame after the current frame in the animation sequence.
         */
        function addFrame() {
            saveCurrentFrameData(); // Ensure the current frame's drawing is saved before adding a new one

            // Create a blank white image data URL for the new frame.
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);
            const blankFrameData = bufferCanvas.toDataURL('image/png');

            // Insert the new blank frame into the `framesData` array right after the current frame.
            framesData.splice(currentFrameIdx + 1, 0, blankFrameData);
            currentFrameIdx++; // Advance the `currentFrameIdx` to the newly added frame.
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display the new frame.
            updateTimelineDisplay(); // Refresh the timeline UI to show the new frame.
            saveStateToHistory(); // Save this action to the undo/redo history.
            showUserMessage('New frame added!');
        }

        /**
         * Deletes the current frame from the animation sequence.
         * Prevents deleting the last remaining frame to ensure the project always has at least one.
         */
        function deleteFrame() {
            if (framesData.length <= 1) { // Check if there's only one frame left
                showUserMessage('Cannot delete the last frame! You need at least one.');
                return;
            }
            framesData.splice(currentFrameIdx, 1); // Remove the current frame from the array
            // Adjust `currentFrameIdx` if the deleted frame was the last one in the array.
            if (currentFrameIdx >= framesData.length) {
                currentFrameIdx = framesData.length - 1;
            }
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display the new current frame.
            updateTimelineDisplay(); // Refresh the timeline UI.
            saveStateToHistory(); // Save this action to the undo/redo history.
            showUserMessage('Frame deleted!');
        }

        /**
         * Duplicates the current frame and inserts the copy immediately after it.
         */
        function duplicateFrame() {
            const currentFrameData = framesData[currentFrameIdx]; // Get the data of the current frame
            framesData.splice(currentFrameIdx + 1, 0, currentFrameData); // Insert a copy right after
            currentFrameIdx++; // Move to the newly duplicated frame
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display the duplicated frame
            updateTimelineDisplay(); // Refresh the timeline UI
            saveStateToHistory(); // Save this action to the undo/redo history
            showUserMessage('Frame duplicated!');
        }

        /**
         * Clears the content of the current frame, effectively making it a blank white canvas.
         */
        function clearCurrentFrame() {
            bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height); // Clear the buffer canvas
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height); // Fill with white
            saveCurrentFrameData(); // Save the cleared frame data
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and display the cleared frame
            saveStateToHistory(); // Save this action to the undo/redo history
            showUserMessage('Current frame cleared!');
        }

        /**
         * Saves the entire animation project to the browser's local storage.
         * This includes all frame data, the current active frame, project dimensions,
         * and current tool settings like opacity and watercolor flow.
         */
        function saveProject() {
            saveCurrentFrameData(); // Ensure the very last drawing on the current frame is saved
            localStorage.setItem('animationProject', JSON.stringify(framesData)); // Save all frames
            localStorage.setItem('currentFrameIndex', currentFrameIdx.toString()); // Save current frame index
            localStorage.setItem('projectWidth', projWidth.toString()); // Save project width
            localStorage.setItem('projectHeight', projHeight.toString()); // Save project height
            localStorage.setItem('currentOpacity', currentOpacity.toString()); // Save current opacity setting
            localStorage.setItem('watercolorFlow', watercolorFlow.toString()); // Save current watercolor flow setting
            showUserMessage('Animation project saved!');
        }

        /**
         * Loads an animation project from the browser's local storage.
         * It retrieves saved frame data, current frame index, project dimensions,
         * and tool settings, then updates the application state accordingly.
         */
        function loadProject() {
            const savedProjectData = localStorage.getItem('animationProject');
            const savedActiveIndex = localStorage.getItem('currentFrameIndex');
            const savedProjectWidth = localStorage.getItem('projectWidth');
            const savedProjectHeight = localStorage.getItem('projectHeight');
            const savedOpacity = localStorage.getItem('currentOpacity');
            const savedFlow = localStorage.getItem('watercolorFlow');

            if (!savedProjectData) {
                showUserMessage('No saved animation project found! Start drawing something new!');
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProjectData);
                // Validate loaded data to ensure it's an array and not empty
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    framesData = loadedFrames; // Replace current frames with loaded ones
                    // Set current frame index, ensuring it's within bounds of loaded frames
                    currentFrameIdx = Math.min(parseInt(savedActiveIndex, 10) || 0, framesData.length - 1);
                    
                    // Apply saved project dimensions if they differ from current defaults
                    const newWidth = parseInt(savedProjectWidth, 10) || 800;
                    const newHeight = parseInt(savedProjectHeight, 10) || 600;
                    
                    if (newWidth !== projWidth || newHeight !== projHeight) {
                        projWidth = newWidth;
                        projHeight = newHeight;
                        projectWidthInput.value = projWidth; // Update UI input fields
                        projectHeightInput.value = projHeight;
                    }

                    // Apply saved opacity and watercolor flow settings to UI and state
                    currentOpacity = parseInt(savedOpacity, 10) || 100;
                    watercolorFlow = parseInt(savedFlow, 10) || 50;
                    opacitySlider.value = currentOpacity;
                    opacityValueSpan.textContent = `${currentOpacity}%`;
                    flowSlider.value = watercolorFlow;
                    flowValueSpan.textContent = `${watercolorFlow}%`;
                    
                    // Reset history and save the newly loaded state as the first history entry
                    historyStates = [];
                    historyPtr = -1;
                    saveStateToHistory();
                    loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and render current frame
                    updateTimelineDisplay(); // Refresh timeline display
                    showUserMessage('Animation project loaded successfully!');
                } else {
                    showUserMessage('Hmm, saved project data seems a bit off or empty.');
                }
            } catch (error) {
                console.error("Error trying to parse loaded project data:", error);
                showUserMessage('Something went wrong loading the project data.');
            }
        }

        /**
         * Starts playing the animation sequence.
         * It sets up an interval to cycle through frames at the specified FPS.
         */
        function startAnimationPlayback() {
            if (framesData.length === 0) {
                showUserMessage('Can\'t play an animation with no frames!');
                return;
            }
            if (animPlaying) return; // Prevent starting playback if already playing

            animPlaying = true; // Set animation playing flag to true
            
            renderCanvasDisplay(); // Render the current frame immediately

            const frameDelay = 1000 / fps; // Calculate the delay between frames in milliseconds
            animInterval = setInterval(() => {
                currentFrameIdx = (currentFrameIdx + 1) % framesData.length; // Move to the next frame, looping back to start
                loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and render the next frame
                updateTimelineDisplay(); // Update the timeline UI to highlight the active frame
            }, frameDelay);
            
            // Update playback button states
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            showUserMessage('Playing animation...');
        }

        /**
         * Pauses the animation playback.
         * Clears the interval responsible for cycling through frames.
         */
        function pauseAnimationPlayback() {
            if (animInterval) {
                clearInterval(animInterval); // Stop the animation interval
                animInterval = null; // Clear the interval ID
            }
            animPlaying = false; // Set animation playing flag to false
            // Update playback button states
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            showUserMessage('Animation paused.');
        }

        /**
         * Stops the animation playback and resets the current frame to the first one.
         */
        function stopAnimationPlayback() {
            pauseAnimationPlayback(); // First, pause the animation
            currentFrameIdx = 0; // Reset to the first frame (index 0)
            loadFrameIntoBuffer(framesData[currentFrameIdx]).then(renderCanvasDisplay); // Load and render the first frame
            updateTimelineDisplay(); // Update the timeline UI
            // Update playback button states
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            showUserMessage('Animation stopped.');
        }

        /**
         * Exports the entire animation as a GIF file using the GIF.js library.
         * It iterates through all frames, adds them to the GIF encoder, and triggers download upon completion.
         */
        async function exportGifAnimation() {
            // Check if GIF.js library is loaded. This is a crucial dependency.
            if (typeof GIF === 'undefined') {
                showUserMessage('GIF.js library not loaded. Cannot export GIF.');
                console.error('GIF.js is missing! Make sure the script is loaded.');
                return;
            }
            if (framesData.length === 0) {
                showUserMessage('Nothing to export! Add some frames first.');
                return;
            }

            exporting = true; // Set a flag to indicate export is in progress
            exportProg = 0; // Initialize export progress to 0%
            exportGifBtn.textContent = 'Exporting GIF... 0%'; // Update button text to show progress
            exportGifBtn.disabled = true; // Disable the button to prevent multiple exports
            showUserMessage('Generating GIF, this might take a moment...');

            // Initialize the GIF encoder with desired properties.
            const gifEncoder = new GIF({
                workers: 2, // Use 2 web workers for potentially faster encoding (can be adjusted)
                quality: 10, // GIF quality (0-100, lower means better quality but larger file size)
                delay: 1000 / fps, // Delay between frames in milliseconds, based on current FPS setting
                width: projWidth, // Set GIF width to the project's width
                height: projHeight, // Set GIF height to the project's height
                background: '#ffffff' // Set a default background color for the GIF
            });

            // Iterate through each frame in `framesData` and add it to the GIF encoder.
            for (let i = 0; i < framesData.length; i++) {
                try {
                    const frameImage = await loadImage(framesData[i]); // Load the image data for the current frame

                    // Create a temporary canvas for each frame to ensure consistent drawing context for GIF.js.
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = projWidth;
                    tempCanvas.height = projHeight;
                    tempCtx.imageSmoothingEnabled = true; // Ensure smooth drawing when adding frames

                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, projWidth, projHeight); // Fill with background color
                    tempCtx.drawImage(frameImage, 0, 0, projWidth, projHeight); // Draw the frame image onto the temp canvas

                    gifEncoder.addFrame(tempCtx, { copy: true, delay: 1000 / fps }); // Add the rendered frame to the GIF
                } catch (error) {
                    console.error(`Problem loading frame ${i} for GIF export:`, error);
                }
            }

            // Listen for progress updates from the GIF encoder.
            gifEncoder.on('progress', function(p) {
                exportProg = Math.floor(p * 100); // Convert progress (0-1) to percentage
                exportGifBtn.textContent = `Exporting GIF... ${exportProg}%`; // Update button text
            });

            // Listen for the 'finished' event when GIF generation is complete.
            gifEncoder.on('finished', function(blob) {
                const url = URL.createObjectURL(blob); // Create a URL for the generated GIF blob
                const dlLink = document.createElement('a'); // Create a temporary anchor element for download
                dlLink.href = url;
                dlLink.download = 'animation.gif'; // Set the default filename for the download
                document.body.appendChild(dlLink); // Append the link to the document (it doesn't need to be visible)
                dlLink.click(); // Programmatically click the link to trigger the download
                document.body.removeChild(dlLink); // Remove the temporary link
                URL.revokeObjectURL(url); // Release the object URL to free up memory

                exporting = false; // Reset exporting flag
                exportProg = 0; // Reset progress
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF'; // Restore original button text
                exportGifBtn.disabled = false; // Re-enable the button
                showUserMessage('GIF exported successfully!');
            });

            // Listen for any errors during GIF generation.
            gifEncoder.on('error', function(error) {
                console.error('GIF generation failed:', error);
                exporting = false;
                exportProg = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showUserMessage('Error exporting GIF.');
            });

            gifEncoder.render(); // Start the GIF rendering process
        }

        /**
         * Generates a creative drawing idea for an animation frame using the Gemini API.
         * It sends a user prompt to the AI model and displays the generated idea.
         */
        async function generateFrameIdea() {
            const ideaPromptText = ideaPromptInput.value.trim();
            if (!ideaPromptText) {
                showUserMessage('Please type in a little prompt for the idea generator first!');
                return;
            }

            // Disable UI elements and show a loading state while generating.
            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden'); // Hide any previously generated idea
            ideaText.textContent = ''; // Clear the text content area

            try {
                // Prepare the chat history payload for the Gemini API call.
                // The prompt is structured to ask for a concise, visual animation idea.
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${ideaPromptText}". Keep it concise and focused on visual elements."` }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // The API key will be automatically provided by the Canvas runtime environment.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                // Make the API call using fetch.
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json(); // Parse the JSON response from the API.

                // Check if the response contains valid generated content.
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const aiIdeaText = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = aiIdeaText; // Display the generated idea
                    generatedIdeaOutput.classList.remove('hidden'); // Show the output area
                    showUserMessage('Idea generated successfully!');
                } else {
                    // Handle cases where the API response structure is unexpected or content is missing.
                    ideaText.textContent = 'Couldn\'t quite generate an idea this time. Please try a different prompt!';
                    generatedIdeaOutput.classList.remove('hidden');
                    showUserMessage('Error generating idea.');
                }
            } catch (error) {
                // Catch and log any network or API errors.
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to a network or API error.';
                generatedIdeaOutput.classList.remove('hidden');
                showUserMessage('Error generating idea.');
            } finally {
                // Re-enable UI elements and reset button text regardless of success or failure.
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }

        /**
         * Updates the visual state (highlighting) of all tool buttons in the toolbox.
         * This function ensures that only the currently active tool is highlighted.
         */
        function updateToolButtonStates() {
            // Get references to all tool buttons in the sidebar.
            const allToolButtons = [
                pencilToolBtn, eraserToolBtn, fillToolBtn, eyedropperToolBtn,
                panToolBtn, textToolBtn, lassoToolBtn, editToolBtn, resizeToolBtn,
                stickerToolBtn // Include the new sticker tool button
            ];
            
            // First, reset all tool buttons to their default (unselected) gray state.
            allToolButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            // Then, highlight the currently active tool.
            // Drawing tools (brush, pen, pencil, watercolor) share the 'pencilToolBtn' visual highlight.
            if (['brush', 'pen', 'pencil', 'watercolor'].includes(currentTool)) {
                pencilToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                pencilToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
            } else {
                // For other tools, find their specific button by ID and apply the highlight.
                const currentToolButton = document.getElementById(`${currentTool}Tool`);
                if (currentToolButton) {
                    currentToolButton.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                    currentToolButton.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                }
            }

            // Update highlighting for the brush selection modal buttons (Brush, Pen, Pencil, Watercolor).
            const brushModalButtons = [selectBrushToolBtn, selectPenToolBtn, selectPencilToolBtn, selectWatercolorToolBtn];
            brushModalButtons.forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-700');
            });

            // Highlight the active brush type within the brush selection modal.
            if (currentTool === 'brush') {
                selectBrushToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectBrushToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pen') {
                selectPenToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPenToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'pencil') {
                selectPencilToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectPencilToolBtn.classList.add('bg-blue-500', 'text-white');
            } else if (currentTool === 'watercolor') {
                selectWatercolorToolBtn.classList.remove('bg-gray-200', 'text-gray-700');
                selectWatercolorToolBtn.classList.add('bg-blue-500', 'text-white');
            }

            // Show or hide the watercolor flow slider section based on whether the watercolor tool is active.
            if (currentTool === 'watercolor') {
                watercolorFlowSection.classList.remove('hidden');
            } else {
                watercolorFlowSection.classList.add('hidden');
            }
        }

        /**
         * Resizes the main drawing buffer and all existing animation frames to new specified dimensions.
         * Existing content on frames is scaled proportionally to fit the new size.
         * @param {number} newWidth - The new width for the project in pixels.
         * @param {number} newHeight - The new height for the project in pixels.
         */
        async function resizeDrawingBufferAndFrames(newWidth, newHeight) {
            const oldFramesData = [...framesData]; // Create a copy of the current frame data
            const newFramesData = []; // Initialize an array to store the newly resized frames

            const oldProjWidth = projWidth; // Store the current project width
            const oldProjHeight = projHeight; // Store the current project height

            projWidth = newWidth; // Update the global project width
            projHeight = newHeight; // Update the global project height

            bufferCanvas.width = newWidth; // Resize the off-screen buffer canvas
            bufferCanvas.height = newHeight;
            bufferCtx.imageSmoothingEnabled = true; // Ensure image smoothing is enabled for quality scaling

            // Iterate through each old frame to resize its content.
            for (let i = 0; i < oldFramesData.length; i++) {
                const frameData = oldFramesData[i];
                const tempCanvas = document.createElement('canvas'); // Create a temporary canvas for resizing each frame
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = newWidth; // Set the new dimensions for the temporary canvas
                tempCanvas.height = newHeight;
                tempCtx.imageSmoothingEnabled = true; // Ensure smoothing for the temporary canvas too

                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, newWidth, newHeight); // Fill the new canvas with a white background

                // If the frame has existing image data, draw it onto the new canvas and scale it.
                if (frameData && frameData.startsWith('data:image/png;base64,')) {
                    try {
                        const img = await loadImage(frameData); // Load the image data for the frame
                        // Calculate offset to center the old content within the new, potentially larger/smaller, canvas.
                        const offsetX = (newWidth - oldProjWidth) / 2;
                        const offsetY = (newHeight - oldProjHeight) / 2;

                        // Draw the old image onto the new canvas.
                        // It's drawn at its original pixel size relative to its top-left,
                        // centered within the new canvas.
                        tempCtx.drawImage(img, offsetX, offsetY, oldProjWidth, oldProjHeight);
                    } catch (error) {
                        console.error("Trouble scaling frame during resize:", error);
                    }
                }
                newFramesData.push(tempCanvas.toDataURL('image/png')); // Save the resized frame's data URL
            }
            
            framesData = newFramesData; // Replace the old frames data with the newly resized ones

            // Load and render the current frame with the new dimensions.
            await loadFrameIntoBuffer(framesData[currentFrameIdx]);
            renderCanvasDisplay();
            updateTimelineDisplay(); // Update the timeline display if needed
            saveStateToHistory(); // Save this resizing action to history for undo/redo
            showUserMessage(`Canvas successfully resized to ${newWidth}x${newHeight}!`);
        }

        /**
         * Updates the preview canvas in the text tool modal with the current text and font settings.
         * This provides a live visual feedback of how the text will appear.
         */
        function updateTextPreview() {
            textPreviewCtx.clearRect(0, 0, textPreviewCanvas.width, textPreviewCanvas.height); // Clear the preview canvas
            textPreviewCtx.fillStyle = '#f9fafb';
            textPreviewCtx.fillRect(0, 0, textPreviewCanvas.width, textPreviewCanvas.height); // Fill with a light gray background

            const text = textInput.value; // Get the text from the input field
            const fontSize = fontSizeInput.value; // Get the font size
            const fontFamily = fontFamilySelect.value; // Get the font family
            const fontWeight = fontBoldToggle.checked ? 'bold' : 'normal'; // Determine font weight
            const fontStyle = fontItalicToggle.checked ? 'italic' : 'normal'; // Determine font style

            // Construct the CSS font string (e.g., "bold italic 30px Inter, sans-serif")
            textFont = `${fontWeight} ${fontStyle} ${fontSize}px ${fontFamily}`;
            textPreviewCtx.font = textFont; // Apply the font to the preview context
            textPreviewCtx.fillStyle = brushColorInput.value; // Set text color to current brush color
            textPreviewCtx.textAlign = 'left'; // Align text to the left
            textPreviewCtx.textBaseline = 'top'; // Set text baseline to top

            const lines = text.split('\n'); // Split text by newlines to handle multi-line input
            let yOffset = 10; // Initial Y offset for the first line of text
            for (const line of lines) {
                textPreviewCtx.fillText(line, 10, yOffset); // Draw each line of text
                yOffset += parseInt(fontSize) * 1.2; // Increment Y offset for the next line (1.2 times font size for spacing)
            }
        }

        /**
         * Draws text or a pre-rendered canvas (containing text) onto the off-screen buffer canvas.
         * This function is used when placing text or stickers onto the actual drawing area.
         * @param {string|HTMLCanvasElement} content - The text string to draw, or a canvas element containing rendered content (like a sticker or text preview).
         * @param {number} x - The X coordinate (in project space) to draw the content at.
         * @param {number} y - The Y coordinate (in project space) to draw the content at.
         * @param {string} [font] - Optional: CSS font string (e.g., "bold 30px Arial"). Required if `content` is a string.
         * @param {string} [color] - Optional: CSS color string (e.g., "#000000"). Required if `content` is a string.
         * @param {number} opacity - Opacity (0-100).
         */
        function drawContentOnBuffer(content, x, y, font, color, opacity) {
            bufferCtx.save(); // Save the current state of the buffer context

            if (typeof content === 'string') {
                // If the content is a string (e.g., raw text or an emoji sticker)
                bufferCtx.font = font; // Apply the specified font
                bufferCtx.fillStyle = color; // Apply the specified color
                bufferCtx.globalAlpha = opacity / 100; // Apply the specified opacity
                bufferCtx.textAlign = 'left'; // Align text to the left
                bufferCtx.textBaseline = 'top'; // Set text baseline to top

                const lines = content.split('\n'); // Handle multi-line text
                let yOffset = y;
                for (const line of lines) {
                    bufferCtx.fillText(line, x, yOffset); // Draw each line of text
                    // Calculate line height based on font size for proper vertical spacing
                    yOffset += parseInt(font.match(/(\d+)px/)[1]) * 1.2;
                }
            } else if (content instanceof HTMLCanvasElement) {
                // If the content is a canvas element (e.g., a pre-rendered sticker or text preview)
                bufferCtx.globalAlpha = opacity / 100; // Apply the specified opacity
                bufferCtx.drawImage(content, x, y); // Draw the entire canvas onto the buffer
            }
            bufferCtx.restore(); // Restore the buffer context to its previous state
        }

        /**
         * Extracts the lassoed selection from the buffer canvas, clears that area from the buffer,
         * and stores the extracted image data in `selectedImageData` for subsequent moving or resizing.
         */
        async function extractLassoSelection() {
            const tempCanvas = document.createElement('canvas'); // Create a temporary off-screen canvas for extraction
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = projWidth;
            tempCanvas.height = projHeight;
            tempCtx.imageSmoothingEnabled = true; // Ensure smooth drawing for the temporary canvas

            tempCtx.drawImage(bufferCanvas, 0, 0); // Draw the entire current buffer content onto the temporary canvas

            // Use 'destination-in' composite operation to effectively "cut out" the lassoed shape.
            // This means only pixels that are opaque in both the source (buffer content) and the destination (the filled lasso path) will remain.
            tempCtx.globalCompositeOperation = 'destination-in';
            tempCtx.beginPath();
            tempCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y); // Start path from the first lasso point
            for (let i = 1; i < lassoPoints.length; i++) {
                tempCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y); // Draw lines to connect all lasso points
            }
            tempCtx.closePath(); // Close the lasso path to form a complete shape
            tempCtx.fillStyle = '#000'; // Fill the lasso path with any opaque color (it acts as a mask)
            tempCtx.fill(); // Apply the fill
            tempCtx.globalCompositeOperation = 'source-over'; // Reset composite operation to default

            selectedImageData = tempCanvas; // Store the temporary canvas (which now contains only the lassoed image)

            // Now, clear the lassoed area from the original buffer canvas.
            bufferCtx.save(); // Save the buffer context state
            bufferCtx.globalCompositeOperation = 'destination-out'; // Use 'destination-out' to erase pixels
            bufferCtx.beginPath();
            bufferCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
            for (let i = 1; i < lassoPoints.length; i++) {
                bufferCtx.lineTo(lassoPoints[i].x, lassoPoints[i].y);
            }
            bufferCtx.closePath();
            bufferCtx.fillStyle = '#fff'; // Fill with any color (it acts as an eraser with 'destination-out')
            bufferCtx.fill();
            bufferCtx.restore(); // Restore the buffer context state

            // Set the initial offset for the selected image data.
            // This is the top-left corner of the bounding box of the lassoed region.
            // It's used as the reference point for moving the selection.
            selectionOffset = { x: lassoPoints[0].x, y: lassoPoints[0].y };
        }

        /**
         * Places the currently `selectedImageData` (the lassoed content) onto the buffer canvas
         * at its current `selectionOffset`. This finalizes the move or resize operation.
         * It then resets the selection state and updates history.
         */
        async function placeLassoSelection() {
            if (selectedImageData) { // Check if there's active selected image data
                await loadFrameIntoBuffer(framesData[currentFrameIdx]); // Reload the current frame to the buffer to ensure a clean base
                // Draw the selected image data onto the buffer at its current position and size.
                bufferCtx.drawImage(selectedImageData, selectionOffset.x, selectionOffset.y, selectedImageData.width, selectedImageData.height);
                saveCurrentFrameData(); // Save the modified frame data
                saveStateToHistory(); // Save this action to the undo/redo history
                showUserMessage('Selection placed!');
            }
            // Reset all selection-related state variables.
            selectedImageData = null;
            selectionOffset = { x: 0, y: 0 };
            isMovingSelection = false;
            currentTool = 'brush'; // Revert to the default brush tool
            updateToolButtonStates(); // Update the UI to reflect the tool change
            renderCanvasDisplay(); // Re-render the canvas to clear the ghost image
        }

        /**
         * Dynamically populates the sticker selection modal with available emojis.
         * Attaches click listeners to each sticker button for selection.
         */
        function populateStickerSelection() {
            stickerContainer.innerHTML = ''; // Clear previous stickers
            availableStickers.forEach(sticker => {
                const stickerButton = document.createElement('button');
                stickerButton.classList.add('sticker-button');
                stickerButton.textContent = sticker.emoji;
                stickerButton.style.fontSize = `${sticker.size}px`; // Apply specific size

                stickerButton.addEventListener('click', () => {
                    stickerToPlace = sticker; // Store the selected sticker object
                    awaitingStickerPlacement = true; // Set flag to await canvas click
                    stickerSelectionModal.classList.add('hidden'); // Hide the modal
                    showUserMessage(`Click on the canvas to place ${sticker.emoji} sticker.`);
                    currentTool = 'sticker'; // Set current tool to sticker
                    updateToolButtonStates(); // Update UI
                });
                stickerContainer.appendChild(stickerButton);
            });
        }

        // --- Event Listeners and Initialization ---

        // Executed when the entire window content (including images) has loaded.
        // This is the main initialization function for the application.
        window.onload = async function() {
            // Load saved project dimensions from local storage or use defaults.
            projWidth = parseInt(localStorage.getItem('projectWidth')) || 800;
            projHeight = parseInt(localStorage.getItem('projectHeight')) || 600;
            projectWidthInput.value = projWidth; // Update the UI input field
            projectHeightInput.value = projHeight; // Update the UI input field

            // Load saved opacity and watercolor flow settings from local storage or use defaults.
            currentOpacity = parseInt(localStorage.getItem('currentOpacity')) || 100;
            watercolorFlow = parseInt(localStorage.getItem('watercolorFlow')) || 50;
            opacitySlider.value = currentOpacity; // Update UI slider
            opacityValueSpan.textContent = `${currentOpacity}%`; // Update UI text
            flowSlider.value = watercolorFlow; // Update UI slider
            flowValueSpan.textContent = `${watercolorFlow}%`; // Update UI text

            // Set the dimensions of the off-screen buffer canvas.
            bufferCanvas.width = projWidth;
            bufferCanvas.height = projHeight;

            // Enable image smoothing for both main and buffer contexts for better drawing quality.
            mainCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingEnabled = true;

            // Set initial drawing styles for the buffer context.
            bufferCtx.lineCap = 'round'; // Rounded ends for lines
            bufferCtx.lineJoin = 'round'; // Rounded corners for lines
            bufferCtx.strokeStyle = brushColor; // Default stroke color
            bufferCtx.lineWidth = brushSize; // Default line width
            
            // Fill the buffer with an initial white background.
            bufferCtx.fillStyle = '#ffffff';
            bufferCtx.fillRect(0, 0, bufferCanvas.width, bufferCanvas.height);

            // Set the main canvas display dimensions to match its CSS size.
            // This ensures the canvas fills its container responsively.
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;

            // Initialize `framesData` if no project is loaded from local storage.
            // This creates the very first blank frame.
            if (framesData.length === 0) {
                const initialCanvasData = bufferCanvas.toDataURL('image/png');
                framesData.push(initialCanvasData);
                saveStateToHistory(); // Save this initial blank frame to history.
            }
            
            // Load the current frame's content into the buffer and render it to the display.
            await loadFrameIntoBuffer(framesData[currentFrameIdx]);
            renderCanvasDisplay();
            
            // Update various UI components based on the initial state.
            updateTimelineDisplay();
            updateToolButtonStates();
            updateUndoRedoButtons();

            // Set initial playback button states (play enabled, pause/stop disabled).
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            exportGifBtn.disabled = false;

            // Populate the sticker selection modal with emojis.
            populateStickerSelection();

            // --- Tool Button Event Listeners ---
            // Double-click on Pencil tool to open brush selection modal.
            pencilToolBtn.addEventListener('dblclick', () => {
                brushSelectionModal.classList.remove('hidden'); // Show modal
                updateToolButtonStates(); // Update tool highlights
            });

            // Click listeners for other tools to set `currentTool` and update UI.
            eraserToolBtn.addEventListener('click', () => {
                currentTool = 'eraser';
                updateToolButtonStates();
            });
            fillToolBtn.addEventListener('click', () => {
                currentTool = 'fill';
                updateToolButtonStates();
            });
            eyedropperToolBtn.addEventListener('click', () => {
                currentTool = 'eyedropper';
                updateToolButtonStates();
            });
            panToolBtn.addEventListener('click', () => {
                currentTool = 'pan';
                updateToolButtonStates();
            });
            textToolBtn.addEventListener('click', () => {
                currentTool = 'text';
                updateToolButtonStates();
                textToolModal.classList.remove('hidden'); // Show text input modal
                updateTextPreview(); // Update text preview
            });
            lassoToolBtn.addEventListener('click', () => {
                currentTool = 'lasso';
                updateToolButtonStates();
                showUserMessage('Lasso tool selected. Draw a selection.');
            });
            // New Edit Tool listener.
            editToolBtn.addEventListener('click', () => {
                currentTool = 'edit';
                updateToolButtonStates();
                if (selectedImageData) { // If a selection exists, automatically enter move mode.
                    isMovingSelection = true;
                    showUserMessage('Edit tool selected. Drag to move, click to place.');
                } else {
                    showUserMessage('No selection to edit. Use Lasso tool first.');
                }
                renderCanvasDisplay(); // Re-render to show ghost if entering edit mode.
            });
            // New Resize Tool listener.
            resizeToolBtn.addEventListener('click', () => {
                currentTool = 'resize';
                updateToolButtonStates();
                if (selectedImageData) { // If a selection exists, open resize modal.
                    resizeSelectionModal.classList.remove('hidden');
                    resizeWidthInput.value = selectedImageData.width; // Pre-fill with actual selection dimensions
                    resizeHeightInput.value = selectedImageData.height;
                } else {
                    showUserMessage('No selection to resize. Use Lasso tool first.');
                }
            });
            // New Sticker Tool listener.
            stickerToolBtn.addEventListener('click', () => {
                currentTool = 'sticker';
                updateToolButtonStates();
                stickerSelectionModal.classList.remove('hidden'); // Show sticker selection modal
            });

            // --- Input and Slider Event Listeners ---
            stylusOnlyModeToggle.addEventListener('change', (e) => {
                isStylusOnlyModeEnabled = e.target.checked;
            });

            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                bufferCtx.strokeStyle = brushColor;
                updateTextPreview(); // Update text preview with new color
            });

            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`;
                bufferCtx.lineWidth = brushSize;
            });

            opacitySlider.addEventListener('input', (e) => {
                currentOpacity = parseInt(e.target.value);
                opacityValueSpan.textContent = `${currentOpacity}%`;
                // If drawing is active, update the context's global alpha immediately.
                if (drawingActive) {
                    if (currentTool === 'pencil') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 0.4;
                    } else if (currentTool === 'brush') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 0.7;
                    } else if (currentTool === 'pen') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * 1.0;
                    } else if (currentTool === 'watercolor') {
                        bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                    }
                }
            });

            flowSlider.addEventListener('input', (e) => {
                watercolorFlow = parseInt(e.target.value);
                flowValueSpan.textContent = `${watercolorFlow}%`;
                // If watercolor tool is active and drawing, update flow immediately.
                if (drawingActive && currentTool === 'watercolor') {
                    bufferCtx.globalAlpha = (currentOpacity / 100) * (watercolorFlow / 100) * 0.1;
                    bufferCtx.shadowBlur = brushSize * (watercolorFlow / 100) * 0.7;
                }
            });

            // --- Canvas Interaction Listeners (Mouse and Touch) ---
            mainCanvas.addEventListener('mousedown', handleInteractionStart);
            mainCanvas.addEventListener('mousemove', handleInteractionMove);
            mainCanvas.addEventListener('mouseup', handleInteractionEnd);
            mainCanvas.addEventListener('mouseleave', handleInteractionEnd); // End interaction if mouse leaves canvas

            mainCanvas.addEventListener('touchstart', handleInteractionStart);
            mainCanvas.addEventListener('touchmove', handleInteractionMove);
            mainCanvas.addEventListener('touchend', handleInteractionEnd);
            mainCanvas.addEventListener('touchcancel', handleInteractionEnd); // End interaction if touch is cancelled

            // Global click listener for placing text or lasso selections or stickers.
            mainCanvas.addEventListener('click', (e) => {
                if (awaitingTextPlacement) {
                    const { x, y } = getTransformedDrawingCoords(e.clientX, e.clientY);
                    loadFrameIntoBuffer(framesData[currentFrameIdx]).then(() => {
                        drawContentOnBuffer(textToPlace, x, y, textFont, brushColor, currentOpacity);
                        saveCurrentFrameData();
                        renderCanvasDisplay();
                        saveStateToHistory();
                        showUserMessage('Text placed!');
                        awaitingTextPlacement = false;
                        currentTool = 'brush'; // Reset tool after placing text
                        updateToolButtonStates();
                    });
                } else if (awaitingStickerPlacement) {
                    const { x, y } = getTransformedDrawingCoords(e.clientX, e.clientY);
                    loadFrameIntoBuffer(framesData[currentFrameIdx]).then(() => {
                        // Draw sticker as text on the buffer
                        drawContentOnBuffer(stickerToPlace.emoji, x, y, `${stickerToPlace.size}px sans-serif`, brushColor, currentOpacity);
                        saveCurrentFrameData();
                        renderCanvasDisplay();
                        saveStateToHistory();
                        showUserMessage('Sticker placed!');
                        awaitingStickerPlacement = false;
                        stickerToPlace = null;
                        currentTool = 'brush'; // Reset tool after placing sticker
                        updateToolButtonStates();
                    });
                } else if ((currentTool === 'edit' || currentTool === 'resize') && isMovingSelection) {
                    placeLassoSelection(); // Place the lassoed selection
                }
            });

            // --- Frame Management Button Listeners ---
            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
            duplicateFrameBtn.addEventListener('click', duplicateFrame);
            clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            // --- Project Button Listeners ---
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGifAnimation);

            // --- Playback Button Listeners ---
            playBtn.addEventListener('click', startAnimationPlayback);
            pauseBtn.addEventListener('click', pauseAnimationPlayback);
            stopBtn.addEventListener('click', stopAnimationPlayback);
            animSpeedInput.addEventListener('input', (e) => {
                fps = parseInt(e.target.value);
                animSpeedValueSpan.textContent = fps;
                if (animPlaying) { // Restart animation if playing to apply new speed
                    pauseAnimationPlayback();
                    startAnimationPlayback();
                }
            });

            // --- Idea Generation Modal Listeners ---
            generateIdeaBtn.addEventListener('click', () => {
                ideaModal.classList.remove('hidden'); // Show modal
                generatedIdeaOutput.classList.add('hidden'); // Hide previous output
                ideaText.textContent = ''; // Clear previous idea
                ideaPromptInput.value = ''; // Clear prompt input
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                ideaModal.classList.add('hidden'); // Hide modal
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea); // Trigger idea generation

            // --- Help and Info Modal Listeners ---
            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            faqBtn.addEventListener('click', () => {
                window.open('https://sathvik-harish.github.io/ToonStart-Help/', '_blank'); // Open FAQ in new tab
            });

            palmRejectionHelpIcon.addEventListener('click', () => {
                palmRejectionHelpModal.classList.remove('hidden');
            });
            closePalmRejectionHelpModalBtn.addEventListener('click', () => {
                palmRejectionHelpModal.classList.add('hidden');
            });

            updatesBtn.addEventListener('click', () => {
                updatesModal.classList.remove('hidden');
            });
            closeUpdatesModalBtn.addEventListener('click', () => {
                updatesModal.classList.add('hidden');
            });

            // --- Customize Modal Listeners ---
            customizeBtn.addEventListener('click', () => {
                customizeModal.classList.remove('hidden');
            });
            closeCustomizeModalBtn.addEventListener('click', () => {
                customizeModal.classList.add('hidden');
            });

            applyCanvasSizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(projectWidthInput.value, 10);
                const newHeight = parseInt(projectHeightInput.value, 10);
                // Validate input dimensions
                if (isNaN(newWidth) || newWidth < 100 || newWidth > 2000 || isNaN(newHeight) || newHeight < 100 || newHeight > 1500) {
                    showUserMessage('Please enter valid dimensions (Width: 100-2000px, Height: 100-1500px).');
                    return;
                }
                resizeDrawingBufferAndFrames(newWidth, newHeight); // Apply new size
                showUserMessage(`Canvas size set to ${newWidth}x${newHeight}.`);
            });

            resetCanvasSizeBtn.addEventListener('click', () => {
                projectWidthInput.value = 800;
                projectHeightInput.value = 600;
                resizeDrawingBufferAndFrames(800, 600); // Reset to default size
                showUserMessage('Canvas size reset to default (800x600).');
            });

            // --- Undo/Redo Listeners ---
            undoBtn.addEventListener('click', performUndo);
            redoBtn.addEventListener('click', performRedo);

            // --- Brush Selection Modal Listeners ---
            selectBrushToolBtn.addEventListener('click', () => {
                currentTool = 'brush';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            selectPenToolBtn.addEventListener('click', () => {
                currentTool = 'pen';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            selectPencilToolBtn.addEventListener('click', () => {
                currentTool = 'pencil';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            selectWatercolorToolBtn.addEventListener('click', () => {
                currentTool = 'watercolor';
                updateToolButtonStates();
                brushSelectionModal.classList.add('hidden');
            });
            closeBrushSelectionModalBtn.addEventListener('click', () => {
                brushSelectionModal.classList.add('hidden');
            });

            // --- Text Tool Modal Input Listeners ---
            textInput.addEventListener('input', updateTextPreview);
            fontFamilySelect.addEventListener('change', updateTextPreview);
            fontSizeInput.addEventListener('input', updateTextPreview);
            fontBoldToggle.addEventListener('change', updateTextPreview);
            fontItalicToggle.addEventListener('change', updateTextPreview);

            placeTextBtn.addEventListener('click', () => {
                textToPlace = textInput.value;
                // Capture all font properties
                const fontSize = fontSizeInput.value;
                const fontFamily = fontFamilySelect.value;
                const fontWeight = fontBoldToggle.checked ? 'bold' : 'normal';
                const fontStyle = fontItalicToggle.checked ? 'italic' : 'normal';
                textFont = `${fontWeight} ${fontStyle} ${fontSize}px ${fontFamily}`;

                textToolModal.classList.add('hidden');
                awaitingTextPlacement = true; // Set flag to await canvas click for placement
                showUserMessage('Click on the canvas to place text.');
            });

            cancelTextBtn.addEventListener('click', () => {
                textToolModal.classList.add('hidden');
                awaitingTextPlacement = false;
                currentTool = 'brush'; // Revert to default tool
                updateToolButtonStates();
            });

            // --- Sticker Selection Modal Listeners ---
            closeStickerSelectionModalBtn.addEventListener('click', () => {
                stickerSelectionModal.classList.add('hidden');
                currentTool = 'brush'; // Revert to default tool if sticker selection is cancelled
                updateToolButtonStates();
            });

            // --- Resize Selection Modal Listeners ---
            applyResizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(resizeWidthInput.value, 10);
                const newHeight = parseInt(resizeHeightInput.value, 10);

                // Validate resize input
                if (isNaN(newWidth) || newWidth <= 0 || isNaN(newHeight) || newHeight <= 0) {
                    showUserMessage('Please enter valid positive numbers for width and height.');
                    return;
                }

                if (selectedImageData) {
                    const resizedCanvas = document.createElement('canvas');
                    const resizedCtx = resizedCanvas.getContext('2d');
                    resizedCanvas.width = newWidth;
                    resizedCanvas.height = newHeight;
                    resizedCtx.imageSmoothingEnabled = true;
                    resizedCtx.drawImage(selectedImageData, 0, 0, newWidth, newHeight); // Draw and scale
                    selectedImageData = resizedCanvas; // Update selectedImageData with resized version
                    isMovingSelection = true; // Keep moving state after resize for placement
                    showUserMessage('Selection resized. Click to place or drag to move.');
                }
                resizeSelectionModal.classList.add('hidden');
                renderCanvasDisplay(); // Re-render to show resized image ghost
            });

            cancelResizeBtn.addEventListener('click', () => {
                resizeSelectionModal.classList.add('hidden');
                // If user cancels resize, and a selection was active, keep it in edit mode
                if (selectedImageData) {
                    currentTool = 'edit';
                    isMovingSelection = true;
                    showUserMessage('Resize cancelled. Selection remains in edit mode.');
                } else {
                    currentTool = 'brush'; // If no selection, revert to brush
                }
                updateToolButtonStates();
                renderCanvasDisplay();
            });

            // --- Window Resize Listener ---
            window.addEventListener('resize', () => {
                // Save current frame data before canvas resize to prevent loss
                const currentFrameData = bufferCanvas.toDataURL('image/png');
                
                // Adjust main canvas dimensions to match its new CSS size
                mainCanvas.width = mainCanvas.offsetWidth;
                mainCanvas.height = mainCanvas.offsetHeight;

                mainCtx.imageSmoothingEnabled = true;

                // Reload current frame and re-render after resize
                loadFrameIntoBuffer(currentFrameData).then(() => {
                    // Re-apply buffer context styles as canvas resize might reset them
                    bufferCtx.lineCap = 'round';
                    bufferCtx.lineJoin = 'round';
                    bufferCtx.strokeStyle = brushColor;
                    bufferCtx.lineWidth = brushSize;
                    
                    renderCanvasDisplay();
                });
            });
        };
    </script>
</body>
</html>
