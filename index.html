<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents default touch actions like scrolling/zooming */
        }
        .flex-grow-container {
            flex-grow: 1;
            min-height: 0;
        }
        .overflow-y-auto-custom {
            overflow-y: auto;
        }
        #staticToolbox {
            flex-shrink: 0;
            width: 256px;
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .toolbox-section {
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }
        .toolbox-section:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        .toolbox-section h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.75rem;
        }
        .toolbox-section label {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            display: block;
        }
        .toolbox-section input[type="range"] {
            width: 100%;
            height: 0.5rem;
        }
        .toolbox-section input[type="color"] {
            width: 100%;
            height: 2.5rem;
        }
        .tool-button {
            padding: 0.625rem 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            min-width: 50px;
        }
        .zoom-info {
            font-size: 0.875rem; /* Adjusted font size for better readability in modal */
            color: #4b5563; /* Darker gray for better contrast */
            line-height: 1.5;
        }
        .zoom-info ul {
            padding-left: 1.25rem; /* Indent list items */
        }
        .zoom-info kbd {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            font-size: 0.875em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            line-height: 1;
            color: #4a5568;
            background-color: #edf2f7;
            border: 1px solid #cbd5e0;
            border-bottom-color: #a0aec0;
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 #a0aec0;
        }
        /* Fixed message display */
        #messageDisplay {
            position: fixed;
            top: 1rem; /* Adjust as needed */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000; /* Ensure it's on top of other content */
            min-width: 250px;
            text-align: center;
        }
        .help-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 1.25rem; /* w-5 */
            height: 1.25rem; /* h-5 */
            border-radius: 9999px; /* rounded-full */
            background-color: #9ca3af; /* gray-400 */
            color: #ffffff; /* text-white */
            font-size: 0.75rem; /* text-xs */
            font-weight: bold;
            cursor: pointer;
            margin-left: 0.5rem; /* ml-2 */
            transition: background-color 0.2s;
        }
        .help-icon:hover {
            background-color: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="h-screen bg-gray-100 flex flex-col items-center p-4 sm:p-6 md:p-8">

    <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-800 mb-4 text-center">
        ToonStart Animation Editor <span class="text-xs font-normal align-top ml-2 text-gray-600">S.H. - S.S.</span>
    </h1>

    <div id="messageDisplay" class="hidden bg-blue-500 text-white px-4 py-2 rounded-lg mb-4 shadow-md transition-opacity duration-500 opacity-0"></div>

    <div class="flex w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow flex-grow-container">
        <div id="staticToolbox">
            <div class="flex flex-col space-y-4">
                <div class="toolbox-section">
                    <h2>Tools</h2>
                    <div class="flex flex-wrap gap-1">
                        <button id="brushTool" class="tool-button bg-blue-600 text-white shadow-md">‚úé</button>
                        <button id="eraserTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü©π</button>
                        <button id="fillTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™£</button>
                    </div>
                    <div class="mt-4 flex items-center">
                        <input type="checkbox" id="stylusOnlyModeToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="stylusOnlyModeToggle" class="text-sm font-medium text-gray-700">Palm Rejection</label>
                        <span id="palmRejectionHelpIcon" class="help-icon">?</span>
                    </div>
                </div>

                <div class="toolbox-section">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#000000" class="rounded-lg border-2 border-gray-300 cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="brushSize">Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <h2>Frames</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="addFrame" class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-blue-600 text-sm">Add New</button>
                        <button id="deleteFrame" class="bg-red-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-red-600 text-sm">Delete</button>
                        <button id="duplicateFrame" class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-green-600 text-sm">Duplicate</button>
                        <button id="clearCurrentFrame" class="bg-orange-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-orange-600 text-sm">Clear</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>History</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="undoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü©Ô∏è Undo</button>
                        <button id="redoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü™Ô∏è Redo</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Project</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="saveProject" class="bg-indigo-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-indigo-600 text-sm">Save</button>
                        <button id="loadProject" class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-purple-600 text-sm">Load</button>
                        <button id="exportGif" class="bg-teal-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-teal-600 text-sm">
                            üñºÔ∏è Export GIF
                        </button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Ideas</h2>
                    <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-yellow-600 text-sm w-full">
                        ‚ú® Generate Idea
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Help</h2>
                    <button id="helpBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                        ‚ùì Help
                    </button>
                </div>
            </div>
        </div>

        <div class="flex flex-col relative flex-grow p-4 sm:p-6">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                        üé¨
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200">
                        ‚è∏Ô∏è
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200">
                        üõë
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed" class="text-gray-700">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner overflow-x-auto">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Timeline</h3>
                <div id="timeline" class="flex space-x-2 pb-2">
                    </div>
            </div>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚ùì Help & View Tips</h3>
            <p class="zoom-info mb-4">
                If parts of the editor content appear cut off or you want to see more, you can adjust your browser's zoom level:
            </p>
            <ul class="zoom-info list-disc list-inside space-y-2">
                <li>
                    <span class="font-semibold">Zoom Out:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>-</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>-</kbd> (Windows)
                </li>
                <li>
                    <span class="font-semibold">Reset Zoom to 100%:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>0</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>0</kbd> (Windows)
                </li>
            </ul>
            <button id="closeHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="palmRejectionHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">üñêÔ∏è What is Palm Rejection?</h3>
            <p class="text-gray-700 mb-4">
                When "Palm Rejection" is enabled, the drawing canvas will **only respond to input from a digital pen or stylus**.
            </p>
            <p class="text-gray-700 mb-4">
                Touches from your fingers or palm will be ignored, allowing you to rest your hand on the screen while drawing without making accidental marks.
            </p>
            <p class="text-gray-700 text-sm italic">
                Note: This feature relies on your device and browser accurately reporting stylus input. Passive styluses (rubber-tip) may still be detected as finger touches.
            </p>
            <button id="closePalmRejectionHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const context = canvas.getContext('2d');
        const messageDisplay = document.getElementById('messageDisplay');

        const brushToolBtn = document.getElementById('brushTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');

        const stylusOnlyModeToggle = document.getElementById('stylusOnlyModeToggle');
        let isStylusOnlyModeEnabled = false;

        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');

        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animationSpeedInput = document.getElementById('animationSpeed');
        const animationSpeedValueSpan = document.getElementById('animationSpeedValue');

        const timelineDiv = document.getElementById('timeline');

        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');

        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        // New Palm Rejection Help elements
        const palmRejectionHelpIcon = document.getElementById('palmRejectionHelpIcon');
        const palmRejectionHelpModal = document.getElementById('palmRejectionHelpModal');
        const closePalmRejectionHelpModalBtn = document.getElementById('closePalmRejectionHelpModalBtn');

        let isDrawing = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let tool = 'brush';

        let frames = [];
        let currentFrameIndex = 0;

        let isPlaying = false;
        let animationSpeed = 10;
        let animationInterval = null;

        let isExporting = false;
        let exportProgress = 0;

        // History for Undo/Redo
        let history = [];
        let historyPointer = -1;
        const MAX_HISTORY_STATES = 50; 

        function showMessage(msg) {
            // Clear any existing timeout to prevent messages from overlapping or being cut short
            if (messageDisplay._timeoutId) {
                clearTimeout(messageDisplay._timeoutId);
            }
            messageDisplay.textContent = msg;
            messageDisplay.classList.remove('hidden', 'opacity-0');
            messageDisplay.classList.add('opacity-100');
            
            // Set a new timeout
            messageDisplay._timeoutId = setTimeout(() => {
                messageDisplay.classList.remove('opacity-100');
                messageDisplay.classList.add('opacity-0');
                // After fade out, hide the element completely
                messageDisplay._timeoutId = setTimeout(() => messageDisplay.classList.add('hidden'), 500);
            }, 2000); // Message visible for 2 seconds before fading out
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        const loadImage = (src) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        };

        async function renderCanvasContent() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);

            const currentFrameData = frames[currentFrameIndex];
            if (currentFrameData && currentFrameData.startsWith('data:image/png;base64,')) {
                try {
                    const img = await loadImage(currentFrameData);
                    context.save();
                    context.globalCompositeOperation = 'source-over';
                    context.globalAlpha = 1.0;
                    context.drawImage(img, 0, 0, canvas.width, canvas.height);
                    context.restore();
                } catch (error) {
                    console.error("Error loading current frame image data:", error);
                    context.fillStyle = '#ffffff';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                }
            } else {
                context.fillStyle = '#ffffff';
                context.fillRect(0, 0, canvas.width, canvas.height);
            }

            context.globalAlpha = 1.0;
            context.globalCompositeOperation = 'source-over';
        }

        function saveCurrentFrame() {
            frames[currentFrameIndex] = canvas.toDataURL('image/png');
        }

        // --- History Management ---
        function saveState() {
            if (historyPointer < history.length - 1) {
                history = history.slice(0, historyPointer + 1);
            }
            history.push(JSON.parse(JSON.stringify(frames)));
            historyPointer++;

            if (history.length > MAX_HISTORY_STATES) {
                history.shift();
                historyPointer--;
            }
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyPointer > 0) {
                historyPointer--;
                frames = JSON.parse(JSON.stringify(history[historyPointer]));
                renderCanvasContent();
                updateTimeline();
                updateUndoRedoButtons();
                showMessage('Undo successful!');
            }
        }

        function redo() {
            if (historyPointer < history.length - 1) {
                historyPointer++;
                frames = JSON.parse(JSON.stringify(history[historyPointer]));
                renderCanvasContent();
                updateTimeline();
                updateUndoRedoButtons();
                showMessage('Redo successful!');
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = !(historyPointer > 0);
            redoBtn.disabled = !(historyPointer < history.length - 1);
        }
        // --- End History Management ---

        // Unified event handler for mouse and touch start
        function startDrawing(e) {
            e.preventDefault(); // Prevent scrolling/zooming on touch devices

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            // Handle Stylus Only Mode
            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct'; // Default to 'direct' if touchType is not provided
                if (touchType === 'direct') {
                    // This is a finger or palm touch, ignore it
                    showMessage('Palm Rejection: Finger/palm input ignored.');
                    isDrawing = false; // Ensure drawing state is off
                    return; 
                }
            }
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const offsetX = clientX - rect.left;
            const offsetY = clientY - rect.top;

            if (tool === 'fill') {
                floodFill(offsetX, offsetY, hexToRgba(brushColor));
                saveCurrentFrame();
                renderCanvasContent();
                saveState(); 
                return;
            }

            context.beginPath();
            context.moveTo(offsetX, offsetY);
            isDrawing = true;
        }

        // Unified event handler for mouse and touch move
        function draw(e) {
            e.preventDefault(); // Prevent scrolling/zooming on touch devices

            // Handle Stylus Only Mode for ongoing touch
            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    // This is a finger or palm touch, ignore it
                    isDrawing = false; // Stop drawing if it somehow started with finger/palm
                    return;
                }
            }

            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const offsetX = clientX - rect.left;
            const offsetY = clientY - rect.top;

            context.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
            context.lineTo(offsetX, offsetY);
            context.stroke();
        }

        // Unified event handler for mouse and touch end/cancel
        function stopDrawing(e) {
            e.preventDefault(); // Prevent default touch actions

            if (tool !== 'fill') {
                // If isDrawing is true here, it means we were drawing with a stylus
                if (isDrawing) { 
                    context.closePath();
                    context.globalCompositeOperation = 'source-over';
                    saveCurrentFrame();
                    renderCanvasContent();
                    saveState(); 
                }
                isDrawing = false; // Always reset drawing state
            }
        }

        function floodFill(startX, startY, fillColor) {
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            const getPixelColor = (x, y) => {
                const index = (y * width + x) * 4;
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            const setPixelColor = (x, y, color) => {
                const index = (y * width + x) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            const startColor = getPixelColor(startX, startY);

            if (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3]) {
                return;
            }

            const pixelStack = [[startX, startY]];
            const visited = new Set();

            const matchColor = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x >= 0 && x < width && y >= 0 && y < height && matchColor(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor);

                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            context.putImageData(imageData, 0, 0);
        }

        function updateTimeline() {
            timelineDiv.innerHTML = '';
            frames.forEach((_, index) => {
                const button = document.createElement('button');
                button.textContent = `F${index + 1}`;
                button.classList.add('flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold', 'transition-all', 'duration-200');
                if (index === currentFrameIndex) {
                    button.classList.add('border-blue-600', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                } else {
                    button.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                }
                button.onclick = () => {
                    if (isPlaying) pauseAnimation();
                    currentFrameIndex = index;
                    renderCanvasContent();
                    updateTimeline();
                };
                timelineDiv.appendChild(button);
            });
        }

        function addFrame() {
            saveCurrentFrame();

            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);
            const blankCanvasData = canvas.toDataURL('image/png');

            frames.splice(currentFrameIndex + 1, 0, blankCanvasData);
            currentFrameIndex++;
            renderCanvasContent();
            updateTimeline();
            saveState(); 
            showMessage('New frame added!');
        }

        function deleteFrame() {
            if (frames.length <= 1) {
                showMessage('Cannot delete the last frame!');
                return;
            }
            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) {
                currentFrameIndex = frames.length - 1;
            }
            renderCanvasContent();
            updateTimeline();
            saveState(); 
            showMessage('Frame deleted!');
        }

        function duplicateFrame() {
            const currentFrameData = frames[currentFrameIndex];
            frames.splice(currentFrameIndex + 1, 0, currentFrameData);
            currentFrameIndex++;
            renderCanvasContent();
            updateTimeline();
            saveState(); 
            showMessage('Frame duplicated!');
        }

        function clearCurrentFrame() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);
            saveCurrentFrame();
            renderCanvasContent();
            saveState(); 
            showMessage('Current frame cleared!');
        }

        function saveProject() {
            saveCurrentFrame();
            localStorage.setItem('animationProject', JSON.stringify(frames));
            localStorage.setItem('currentFrameIndex', currentFrameIndex.toString());
            showMessage('Animation project saved!');
        }

        function loadProject() {
            const savedProject = localStorage.getItem('animationProject');
            const savedIndex = localStorage.getItem('currentFrameIndex');

            if (!savedProject) {
                showMessage('No saved animation project found!');
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProject);
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    frames = loadedFrames;
                    currentFrameIndex = Math.min(parseInt(savedIndex, 10) || 0, frames.length - 1);
                    renderCanvasContent();
                    updateTimeline();
                    
                    history = [];
                    historyPointer = -1;
                    saveState();
                    showMessage('Animation project loaded!');
                } else {
                    showMessage('Saved project data is corrupt or empty.');
                }
            } catch (error) {
                console.error("Error parsing loaded project:", error);
                showMessage('Error loading project data.');
            }
        }

        function playAnimation() {
            if (frames.length === 0) {
                showMessage('No frames to play!');
                return;
            }
            if (isPlaying) return;

            isPlaying = true;
            
            renderCanvasContent();

            const interval = 1000 / animationSpeed;
            animationInterval = setInterval(() => {
                currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                renderCanvasContent();
                updateTimeline();
            }, interval);
            showMessage('Playing animation...');
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            isPlaying = false;
            showMessage('Animation paused.');
            playBtn.disabled = false;
            pauseBtn.disabled = true;
        }

        function stopAnimation() {
            pauseAnimation();
            currentFrameIndex = 0;
            renderCanvasContent();
            updateTimeline();
            showMessage('Animation stopped.');
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
        }

        function exportGif() {
            if (typeof GIF === 'undefined') {
                showMessage('GIF.js library not loaded. Cannot export GIF.');
                console.error('GIF.js is not available. Ensure the script is loaded.');
                return;
            }
            if (frames.length === 0) {
                showMessage('No frames to export!');
                return;
            }

            isExporting = true;
            exportProgress = 0;
            exportGifBtn.textContent = `Exporting GIF... ${exportProgress}%`;
            exportGifBtn.disabled = true;
            showMessage('Generating GIF...');

            const gif = new GIF({
                workers: 2,
                quality: 10,
                delay: 1000 / animationSpeed,
                width: canvas.width,
                height: canvas.height,
                background: '#ffffff',
                transparent: '#ffffff'
            });

            frames.forEach(frameData => {
                const img = new Image();
                img.src = frameData;
                gif.addFrame(img, { delay: 1000 / animationSpeed });
            });

            gif.on('progress', function(p) {
                exportProgress = Math.floor(p * 100);
                exportGifBtn.textContent = `Exporting GIF... ${exportProgress}%`;
            });

            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.gif';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showMessage('GIF exported successfully!');
            });

            gif.on('error', function(error) {
                console.error('GIF generation error:', error);
                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showMessage('Error exporting GIF.');
            });

            gif.render();
        }

        async function generateFrameIdea() {
            const prompt = ideaPromptInput.value.trim();
            if (!prompt) {
                showMessage('Please enter a prompt for the idea generator.');
                return;
            }

            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden');
            ideaText.textContent = '';

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${prompt}". Keep it concise and focused on visual elements."` }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = text;
                    generatedIdeaOutput.classList.remove('hidden');
                    showMessage('Idea generated successfully!');
                } else {
                    ideaText.textContent = 'Could not generate an idea. Please try again.';
                    generatedIdeaOutput.classList.remove('hidden');
                    showMessage('Error generating idea.');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to an error.';
                generatedIdeaOutput.classList.remove('hidden');
                showMessage('Error generating idea.');
            } finally {
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }

        window.onload = function() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            context.lineCap = 'round';
            context.lineJoin = 'round';
            context.strokeStyle = brushColor;
            context.lineWidth = brushSize;

            frames.push(canvas.toDataURL('image/png'));
            updateTimeline();
            renderCanvasContent();
            saveState(); // Save initial blank frame to history

            brushToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
            brushToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            eraserToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            fillToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');

            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            exportGifBtn.disabled = false;

            brushToolBtn.addEventListener('click', () => {
                tool = 'brush';
                brushToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                brushToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                eraserToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                eraserToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                fillToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                fillToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                context.strokeStyle = brushColor;
            });
            eraserToolBtn.addEventListener('click', () => {
                tool = 'eraser';
                eraserToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                eraserToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                brushToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                brushToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                fillToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                fillToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });
            fillToolBtn.addEventListener('click', () => {
                tool = 'fill';
                fillToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
                fillToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                brushToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                brushToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                eraserToolBtn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                eraserToolBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            stylusOnlyModeToggle.addEventListener('change', (e) => {
                isStylusOnlyModeEnabled = e.target.checked;
                if (isStylusOnlyModeEnabled) {
                    showMessage('Palm Rejection Enabled (Stylus Only).');
                } else {
                    showMessage('Palm Rejection Disabled (All Touch Inputs).');
                }
            });

            // Event listener for the new Palm Rejection help icon
            palmRejectionHelpIcon.addEventListener('click', () => {
                palmRejectionHelpModal.classList.remove('hidden');
            });
            closePalmRejectionHelpModalBtn.addEventListener('click', () => {
                palmRejectionHelpModal.classList.add('hidden');
            });


            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                context.strokeStyle = brushColor;
            });

            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`;
                context.lineWidth = brushSize;
            });

            // Event listeners for mouse
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            // Event listeners for touch
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing); // Handle when touch is interrupted

            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
            duplicateFrameBtn.addEventListener('click', duplicateFrame);
            clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGif);

            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            stopBtn.addEventListener('click', stopAnimation);
            animationSpeedInput.addEventListener('input', (e) => {
                animationSpeed = parseInt(e.target.value);
                animationSpeedValueSpan.textContent = animationSpeed;
                if (isPlaying) {
                    pauseAnimation();
                    playAnimation();
                }
            });

            generateIdeaBtn.addEventListener('click', () => {
                ideaModal.classList.remove('hidden');
                generatedIdeaOutput.classList.add('hidden');
                ideaText.textContent = '';
                ideaPromptInput.value = '';
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                ideaModal.classList.add('hidden');
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea);

            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            window.addEventListener('resize', () => {
                const currentFrameData = canvas.toDataURL('image/png');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                const img = new Image();
                img.src = currentFrameData;
                img.onload = () => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.drawImage(img, 0, 0, canvas.width, canvas.height);
                    context.lineCap = 'round';
                    context.lineJoin = 'round';
                    context.strokeStyle = brushColor;
                    context.lineWidth = brushSize;
                    renderCanvasContent();
                };
            });
        };
    </script>
</body>
</html>
