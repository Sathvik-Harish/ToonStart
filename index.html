<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToonStart Animation Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #drawingCanvas {
            background-color: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            width: 100%; /* Display canvas fills its container */
            height: 100%; /* Display canvas fills its container */
            touch-action: none; /* Disable default touch actions like pinch-zoom */
        }
        .flex-grow-container {
            flex-grow: 1;
            min-height: 0;
        }
        .overflow-y-auto-custom {
            overflow-y: auto;
        }
        #staticToolbox {
            flex-shrink: 0;
            width: 256px;
            background-color: #f9fafb;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .toolbox-section {
            padding-top: 0.75rem;
            margin-top: 0.75rem;
            border-top: 1px solid #e5e7eb;
        }
        .toolbox-section:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        .toolbox-section h2 {
            font-size: 1.125rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 0.75rem;
        }
        .toolbox-section label {
            font-size: 0.875rem;
            color: #4b5563;
            margin-bottom: 0.25rem;
            display: block;
        }
        .toolbox-section input[type="range"] {
            width: 100%;
            height: 0.5rem;
        }
        .toolbox-section input[type="color"] {
            width: 100%;
            height: 2.5rem;
        }
        .tool-button {
            padding: 0.625rem 0.75rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
            min-width: 50px;
        }
        .zoom-info {
            font-size: 0.875rem;
            color: #4b5563;
            line-height: 1.5;
        }
        .zoom-info ul {
            padding-left: 1.25rem;
        }
        .zoom-info kbd {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            font-size: 0.875em;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            line-height: 1;
            color: #4a5568;
            background-color: #edf2f7;
            border: 1px solid #cbd5e0;
            border-bottom-color: #a0aec0;
            border-radius: 0.25rem;
            box-shadow: inset 0 -1px 0 #a0aec0;
        }
        .help-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 9999px;
            background-color: #9ca3af;
            color: #ffffff;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.2s;
        }
        .help-icon:hover {
            background-color: #6b7280;
        }
    </style>
</head>
<body class="h-screen bg-gray-100 flex flex-col items-center p-4 sm:p-6 md:p-8">

    <h1 class="text-4xl sm:text-5xl font-extrabold text-blue-800 mb-4 text-center">
        ToonStart Animation Editor <span class="text-xs font-normal align-top ml-2 text-gray-600">S.H. - S.S.</span>
    </h1>

    <div id="messageDisplay" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md transition-opacity duration-500 opacity-0 z-1000 hidden"></div>

    <div class="flex w-full max-w-6xl bg-white rounded-xl shadow-lg overflow-hidden flex-grow flex-grow-container">
        <div id="staticToolbox">
            <div class="flex flex-col space-y-4">
                <div class="toolbox-section">
                    <h2>Tools</h2>
                    <div class="flex flex-wrap gap-1">
                        <button id="brushTool" class="tool-button bg-blue-600 text-white shadow-md">‚úé</button>
                        <button id="eraserTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü©π</button>
                        <button id="fillTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">ü™£</button>
                        <button id="eyedropperTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">üíâ</button>
                        <button id="panTool" class="tool-button bg-gray-200 text-gray-700 hover:bg-blue-100">‚úã</button>
                    </div>
                    <div class="mt-4 flex items-center">
                        <input type="checkbox" id="stylusOnlyModeToggle" class="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                        <label for="stylusOnlyModeToggle" class="text-sm font-medium text-gray-700">Palm Rejection</label>
                        <span id="palmRejectionHelpIcon" class="help-icon">?</span>
                    </div>
                </div>

                <div class="toolbox-section">
                    <label for="brushColor">Brush Color:</label>
                    <input type="color" id="brushColor" value="#000000" class="rounded-lg border-2 border-gray-300 cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <label for="brushSize">Size: <span id="brushSizeValue" class="font-bold">5px</span></label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" class="bg-gray-300 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="toolbox-section">
                    <h2>Frames</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="addFrame" class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-blue-600 text-sm">Add New</button>
                        <button id="deleteFrame" class="bg-red-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-red-600 text-sm">Delete</button>
                        <button id="duplicateFrame" class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-green-600 text-sm">Duplicate</button>
                        <button id="clearCurrentFrame" class="bg-orange-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-orange-600 text-sm">Clear</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>History</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="undoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü©Ô∏è Undo</button>
                        <button id="redoBtn" class="bg-gray-300 text-gray-800 px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-400 text-sm" disabled>‚Ü™Ô∏è Redo</button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Project</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="saveProject" class="bg-indigo-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-indigo-600 text-sm">Save</button>
                        <button id="loadProject" class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-purple-600 text-sm">Load</button>
                        <button id="exportGif" class="bg-teal-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-teal-600 text-sm">
                            üñºÔ∏è Export GIF
                        </button>
                        <button id="customizeBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚öôÔ∏è Customize
                        </button>
                    </div>
                </div>

                <div class="toolbox-section">
                    <h2>Ideas</h2>
                    <button id="generateIdeaBtn" class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-yellow-600 text-sm w-full">
                        ‚ú® Generate Idea
                    </button>
                </div>

                <div class="toolbox-section">
                    <h2>Info</h2>
                    <div class="flex flex-col space-y-1">
                        <button id="helpBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì Help
                        </button>
                        <button id="faqBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ùì FAQ
                        </button>
                        <button id="updatesBtn" class="bg-gray-400 text-white px-3 py-1.5 rounded-lg shadow-sm hover:bg-gray-500 text-sm w-full">
                            ‚ú® Updates
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="flex flex-col relative flex-grow p-4 sm:p-6">
            <div class="flex-grow flex justify-center items-center relative">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="mt-4 p-4 bg-gray-100 rounded-lg shadow-inner flex flex-col sm:flex-row items-center justify-center gap-4">
                <h3 class="text-lg font-semibold text-gray-700">Playback:</h3>
                <div class="flex gap-2">
                    <button id="playBtn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                        üé¨
                    </button>
                    <button id="pauseBtn" class="bg-orange-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-orange-700 transition-colors duration-200">
                        ‚è∏Ô∏è
                    </button>
                    <button id="stopBtn" class="bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 transition-colors duration-200">
                        üõë
                    </button>
                </div>
                <div class="flex items-center gap-2 mt-2 sm:mt-0">
                    <label for="animationSpeed">FPS:</label>
                    <input type="range" id="animationSpeed" min="1" max="30" value="10" class="w-24 h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer">
                    <span id="animationSpeedValue" class="font-bold text-gray-800">10</span>
                </div>
            </div>

            <div class="mt-6 p-4 bg-gray-100 rounded-lg shadow-inner max-h-24">
                <div id="timelineContainer" class="overflow-x-auto pb-2">
                    <div id="timeline" class="flex flex-nowrap space-x-2 items-center">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="ideaModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚ú® Generate Frame Idea</h3>
            <p class="text-gray-600 mb-4">
                Describe what kind of idea you're looking for, e.g., "a character running through a forest," or "a magical creature appearing."
            </p>
            <input type="text" id="ideaPromptInput" placeholder="Enter your prompt here..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button id="getIdeaBtn" class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                Get Idea
            </button>

            <div id="generatedIdeaOutput" class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg hidden">
                <h4 class="text-lg font-semibold text-blue-800 mb-2">Your Idea:</h4>
                <p id="ideaText" class="text-gray-700 whitespace-pre-wrap"></p>
            </div>

            <button id="closeIdeaModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">‚ùì Help & View Tips</h3>
            <p class="zoom-info mb-4">
                If parts of the editor content appear cut off or you want to see more, you can adjust your browser's zoom level.
            </p>
            <ul class="zoom-info list-disc list-inside space-y-2">
                <li>
                    <span class="font-semibold">Browser Zoom Out:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>-</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>-</kbd> (Windows)
                </li>
                <li>
                    <span class="font-semibold">Browser Reset Zoom to 100%:</span>
                    <br>
                    <kbd>Cmd</kbd> + <kbd>0</kbd> (Mac)
                    <br>
                    <kbd>Ctrl</kbd> + <kbd>0</kbd> (Windows)
                </li>
                <li>
                    <span class="font-semibold">If browser zooming in and out doesn't work as expected, try setting your browser zoom to 150% and then refresh the page. This can sometimes resolve layout issues and bring the timeline back into view.</span>
                </li>
                <li>
                    <span class="font-semibold">Canvas Pan:</span> Click and drag with the "‚úã Hand" tool to pan.
                </li>
                <li>
                    <span class="font-semibold">Line Smoothness:</span> If lines appear jagged or pixelated (especially at smaller brush sizes or high canvas resolutions), ensure your browser's "image smoothing" is enabled. This feature is enabled by default in ToonStart to improve line quality.
                </li>
            </ul>
            <button id="closeHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="palmRejectionHelpModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="2xl font-bold text-gray-800 mb-4">üñêÔ∏è What is Palm Rejection?</h3>
            <p class="text-gray-700 mb-4">
                When "Palm Rejection" is enabled, the drawing canvas will <strong>only respond to input from a digital pen or stylus</strong>.
            </p>
            <p class="text-gray-700 mb-4">
                Touches from your fingers or palm will be ignored, allowing you to rest your hand on the screen while drawing without making accidental marks.
            </p>
            <p class="text-gray-700 text-sm italic">
                Note: This feature relies on your device and browser accurately reporting stylus input. Passive styluses (rubber-tip) may still be detected as finger touches.
            </p>
            <button id="closePalmRejectionHelpModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="updatesModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md max-h-[80vh] overflow-y-auto">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚ú® ToonStart Updates</h3>
            <div id="updatesContent" class="text-gray-700 space-y-4">
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 26, 2025 - Improved Drawing Smoothness</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Brush Shape & Diagonal Lines:</strong> Fixed issues where circular brush strokes would appear square or jagged, especially on diagonals or after canvas resizing. Image smoothing is now explicitly enabled for both drawing and display contexts to ensure smoother line rendering.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Added FAQ Button</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>FAQ Button:</strong> Added a new "FAQ" button in the "Info" section linking to the help page.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Fixed Canvas Resizing</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Canvas Resizing:</strong> Lines and existing drawings now maintain their original thickness when resizing the project canvas.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 30, 2025 - Zoom Feature Removed</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature Removed:</strong> Zoom functionality has been removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 29, 2025 - Zoom Feature & UI Polish</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Zoom Feature:</strong> Added zoom functionality via scroll wheel and a dedicated slider in the new "Zoom & Pan" section.</li>
                        <li><strong>"Zoom & Pan" Section:</strong> New toolbox section for zoom and pan controls.</li>
                        <li><strong>Timeline Text Removed:</strong> "Timeline" heading removed as requested.</li>
                        <li><strong>Help Text Updated:</strong> Included instructions for the new zoom feature.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 28, 2025 - Canvas Resizing & UI Refinements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Canvas Resizing:</strong> Added ability to change project width and height in Customize modal. Existing frames scale proportionally.</li>
                        <li><strong>Customize Button Relocated:</strong> Moved to the "Project" section for better organization.</li>
                        <li><strong>Onion Skinning Removed:</strong> Feature removed as per user request.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 27, 2025 - Layout & Drawing Stability</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Brush Offset:</strong> Drawing now consistently aligns with cursor regardless of timeline changes.</li>
                        <li><strong>Timeline Horizontal Scroll:</strong> Timeline now scrolls horizontally when many frames are added, preventing vertical layout shifts.</li>
                        <li><strong>Improved GIF Export:</strong> More reliable GIF generation due to consistent internal canvas dimensions.</li>
                        <li>**Help Text Updated:** Added a new tip regarding browser zoom and refreshing.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 25, 2025 - Critical Bug Fixes & Improvements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Fixed Drawing:</strong> Drawing tools now work correctly and responsively.</li>
                        <li><strong>Fixed Undo/Redo:</strong> History system is fully functional.</li>
                        <li><strong>Fixed Generate Idea:</strong> AI idea generator now works as expected.</li>
                        <li><strong>Fixed Updates Button:</strong> The updates modal now opens correctly.</li>
                        <li><strong>Restored Message Display:</strong> Temporary on-screen messages are back for user feedback.</li>
                        <li><strong>Fixed Fill Tool:</strong> Now accurately fills areas regardless of pan.</li>
                        <li><strong>Fixed Eyedropper Tool:</strong> Accurately picks colors from the canvas.</li>
                        <li>**Enhanced Responsiveness:** Significant performance improvements for drawing and canvas interactions.</li>
                        <li>**Removed Zoom Feature:** Canvas no longer supports zoom, focusing on direct drawing.</li>
                        <li>**Pipette Icon Update:** Changed to üíâ emoji.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 23, 2025 - Initial Feature Enhancements</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Undo/Redo History:</strong> Easily correct mistakes with multiple steps.</li>
                        <li><strong>Pan Tool:</strong> Navigate the canvas for detailed work or overview.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-lg text-blue-700">May 22, 2025 - Basic Drawing & Animation</h4>
                    <ul class="list-disc list-inside ml-4 text-sm">
                        <li><strong>Basic Drawing Tools:</strong> Brush, Eraser, Fill.</li>
                        <li><strong>Frame Management:</strong> Add, delete, duplicate, clear frames.</li>
                        <li><strong>Animation Playback:</strong> Play, pause, stop animation with adjustable speed.</li>
                        <li><strong>Project Save/Load:</strong> Save and load your animation projects locally.</li>
                        <li><strong>GIF Export:</strong> Export your animation as a GIF.</li>
                        <li><strong>AI Idea Generator:</strong> Get creative ideas for your frames.</li>
                        <li><strong>Touch Support:</strong> Basic drawing on touch devices like iPad.</li>
                        <li><strong>Palm Rejection:</strong> Option to enable stylus-only drawing.</li>
                    </ul>
                </div>
            </div>
            <button id="closeUpdatesModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>

    <div id="customizeModal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">‚öôÔ∏è Customize Editor</h3>
            <div class="space-y-4">
                <div>
                    <label for="projectWidth" class="block text-sm font-medium text-gray-700">Project Width (px):</label>
                    <input type="number" id="projectWidth" min="100" max="2000" value="800"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="projectHeight" class="block text-sm font-medium text-gray-700">Project Height (px):</label>
                    <input type="number" id="projectHeight" min="100" max="1500" value="600"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button id="applyCanvasSizeBtn" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    Apply Canvas Size
                </button>
                <button id="resetCanvasSizeBtn" class="w-full bg-gray-300 text-gray-800 px-4 py-2 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                    Reset to Default (800x600)
                </button>
            </div>
            <button id="closeCustomizeModalBtn" class="mt-6 w-full bg-gray-300 text-gray-800 px-4 py-3 rounded-lg shadow-md hover:bg-gray-400 transition-colors duration-200">
                Close
            </button>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('drawingCanvas');
        const context = canvas.getContext('2d');

        const drawingBufferCanvas = document.createElement('canvas');
        const drawingBufferContext = drawingBufferCanvas.getContext('2d');

        // Define a fixed internal resolution for the drawing buffer
        let PROJECT_WIDTH = 800;
        let PROJECT_HEIGHT = 600;

        const messageDisplay = document.getElementById('messageDisplay');

        const brushToolBtn = document.getElementById('brushTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const fillToolBtn = document.getElementById('fillTool');
        const eyedropperToolBtn = document.getElementById('eyedropperTool');
        const panToolBtn = document.getElementById('panTool');
        const brushColorInput = document.getElementById('brushColor');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');

        const stylusOnlyModeToggle = document.getElementById('stylusOnlyModeToggle');
        let isStylusOnlyModeEnabled = false;

        const addFrameBtn = document.getElementById('addFrame');
        const deleteFrameBtn = document.getElementById('deleteFrame');
        const duplicateFrameBtn = document.getElementById('duplicateFrame');
        const clearCurrentFrameBtn = document.getElementById('clearCurrentFrame');

        const saveProjectBtn = document.getElementById('saveProject');
        const loadProjectBtn = document.getElementById('loadProject');
        const exportGifBtn = document.getElementById('exportGif');

        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const animationSpeedInput = document.getElementById('animationSpeed');
        const animationSpeedValueSpan = document.getElementById('animationSpeedValue');

        const timelineDiv = document.getElementById('timeline'); // The flex container for frame buttons
        const timelineContainer = document.getElementById('timelineContainer'); // The scrolling container

        const generateIdeaBtn = document.getElementById('generateIdeaBtn');
        const ideaModal = document.getElementById('ideaModal');
        const ideaPromptInput = document.getElementById('ideaPromptInput');
        const getIdeaBtn = document.getElementById('getIdeaBtn');
        const generatedIdeaOutput = document.getElementById('generatedIdeaOutput');
        const ideaText = document.getElementById('ideaText');
        const closeIdeaModalBtn = document.getElementById('closeIdeaModalBtn');

        const helpBtn = document.getElementById('helpBtn'); 
        const helpModal = document.getElementById('helpModal');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');

        const faqBtn = document.getElementById('faqBtn'); // New FAQ button
        const updatesBtn = document.getElementById('updatesBtn');
        const updatesModal = document.getElementById('updatesModal');
        const closeUpdatesModalBtn = document.getElementById('closeUpdatesModalBtn');

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        const palmRejectionHelpIcon = document.getElementById('palmRejectionHelpIcon');
        const palmRejectionHelpModal = document.getElementById('palmRejectionHelpModal');
        const closePalmRejectionHelpModalBtn = document.getElementById('closePalmRejectionHelpModalBtn');

        const customizeBtn = document.getElementById('customizeBtn');
        const customizeModal = document.getElementById('customizeModal');
        const closeCustomizeModalBtn = document.getElementById('closeCustomizeModalBtn');
        const projectWidthInput = document.getElementById('projectWidth');
        const projectHeightInput = document.getElementById('projectHeight');
        const applyCanvasSizeBtn = document.getElementById('applyCanvasSizeBtn');
        const resetCanvasSizeBtn = document.getElementById('resetCanvasSizeBtn');

        let isDrawing = false;
        let brushColor = '#000000';
        let brushSize = 5;
        let tool = 'brush';

        let frames = [];
        let currentFrameIndex = 0;

        let isPlaying = false;
        let animationSpeed = 10;
        let animationInterval = null;

        let isExporting = false;
        let exportProgress = 0;

        let history = [];
        let historyPointer = -1;
        const MAX_HISTORY_STATES = 50;

        let panOffset = { x: 0, y: 0 };
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };

        const loadedImageCache = new Map();

        function showMessage(msg) {
            if (messageDisplay._timeoutId) {
                clearTimeout(messageDisplay._timeoutId);
            }
            messageDisplay.textContent = msg;
            messageDisplay.classList.remove('hidden', 'opacity-0');
            messageDisplay.classList.add('opacity-100');
            
            messageDisplay._timeoutId = setTimeout(() => {
                messageDisplay.classList.remove('opacity-100');
                messageDisplay.classList.add('opacity-0');
                messageDisplay._timeoutId = setTimeout(() => messageDisplay.classList.add('hidden'), 500);
            }, 2000);
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function rgbaToHex(r, g, b) {
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
        }

        function loadImage(src) {
            if (loadedImageCache.has(src)) {
                return Promise.resolve(loadedImageCache.get(src));
            }
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    loadedImageCache.set(src, img);
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        function saveState() {
            if (historyPointer < history.length - 1) {
                history = history.slice(0, historyPointer + 1);
            }
            history.push(JSON.parse(JSON.stringify(frames)));
            historyPointer++;

            if (history.length > MAX_HISTORY_STATES) {
                history.shift();
                historyPointer--;
            }
            updateUndoRedoButtons();
        }

        function undo() {
            if (historyPointer > 0) {
                historyPointer--;
                frames = JSON.parse(JSON.stringify(history[historyPointer]));
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
                updateTimeline();
                updateUndoRedoButtons();
                showMessage('Undo successful!');
            }
        }

        function redo() {
            if (historyPointer < history.length - 1) {
                historyPointer++;
                frames = JSON.parse(JSON.stringify(history[historyPointer]));
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
                updateTimeline();
                updateUndoRedoButtons();
                showMessage('Redo successful!');
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = !(historyPointer > 0);
            redoBtn.disabled = !(historyPointer < history.length - 1);
        }

        async function loadFrameIntoBuffer(frameData) {
            drawingBufferContext.clearRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);

            if (frameData && typeof frameData === 'string' && frameData.startsWith('data:image/png;base64,')) {
                try {
                    const img = loadedImageCache.get(frameData) || await loadImage(frameData);
                    drawingBufferContext.drawImage(img, 0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
                } catch (error) {
                    console.error("Error loading frame data into buffer:", error);
                }
            }
        }

        async function renderCanvasContent() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.save();
            // Apply pan transforms (zoom is removed)
            context.translate(panOffset.x, panOffset.y);
            
            const aspectRatio = PROJECT_WIDTH / PROJECT_HEIGHT;
            let drawWidth = canvas.width;
            let drawHeight = canvas.width / aspectRatio;

            if (drawHeight > canvas.height) {
                drawHeight = canvas.height;
                drawWidth = canvas.height * aspectRatio;
            }

            const offsetX = (canvas.width - drawWidth) / 2;
            const offsetY = (canvas.height - drawHeight) / 2;

            // Draw current frame from buffer
            context.globalAlpha = 1.0;
            context.globalCompositeOperation = 'source-over';
            context.drawImage(drawingBufferCanvas, offsetX, offsetY, drawWidth, drawHeight);

            // Draw dashed border around the drawing area
            context.strokeStyle = '#888888'; // Gray color for the border
            context.lineWidth = 2; // Thickness of the border
            context.setLineDash([5, 5]); // Dashed line pattern (5px line, 5px gap)
            context.strokeRect(offsetX, offsetY, drawWidth, drawHeight);
            context.setLineDash([]); // Reset line dash to solid for other drawings

            context.restore();
            context.globalAlpha = 1.0;
            context.globalCompositeOperation = 'source-over';
        }

        function saveCurrentFrame() {
            frames[currentFrameIndex] = drawingBufferCanvas.toDataURL('image/png');
        }

        function getTransformedCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            // Reverse the offset applied in renderCanvasContent (no scaling now)
            const aspectRatio = PROJECT_WIDTH / PROJECT_HEIGHT;
            let displayContentWidth = canvas.width;
            let displayContentHeight = canvas.width / aspectRatio;

            if (displayContentHeight > canvas.height) {
                displayContentHeight = canvas.height;
                displayContentWidth = canvas.height * aspectRatio;
            }

            const displayOffsetX = (canvas.width - displayContentWidth) / 2;
            const displayOffsetY = (canvas.height - displayContentHeight) / 2;

            // Apply pan offset first, then subtract the content's offset on the display canvas
            const transformedX = (canvasX - panOffset.x - displayOffsetX);
            const transformedY = (canvasY - panOffset.y - displayOffsetY);

            // Scale these coordinates from the display content area back to the project's internal resolution
            const x = transformedX * (PROJECT_WIDTH / displayContentWidth);
            const y = transformedY * (PROJECT_HEIGHT / displayContentHeight);

            return { x, y };
        }

        function startDrawing(e) {
            e.preventDefault();

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    isDrawing = false;
                    return;
                }
            }

            if (tool === 'eyedropper') {
                const rect = canvas.getBoundingClientRect();
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                
                const imageData = context.getImageData(canvasX, canvasY, 1, 1).data;
                brushColorInput.value = rgbaToHex(imageData[0], imageData[1], imageData[2]);
                brushColor = brushColorInput.value;
                drawingBufferContext.strokeStyle = brushColor; // Update drawing buffer context
                tool = 'brush';
                updateToolButtons();
                showMessage('Color picked!');
                return;
            }

            if (tool === 'pan') {
                isPanning = true;
                lastPanPoint = { x: clientX, y: clientY };
                return;
            }

            if (tool === 'fill') {
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(() => {
                    const { x, y } = getTransformedCoords(clientX, clientY);
                    floodFill(x, y, hexToRgba(brushColor), drawingBufferContext, drawingBufferCanvas.width, drawingBufferCanvas.height);
                    frames[currentFrameIndex] = drawingBufferCanvas.toDataURL('image/png');
                    renderCanvasContent();
                    saveState();
                    showMessage('Fill applied!');
                }).catch(error => {
                    console.error("Error loading frame for fill:", error);
                    showMessage('Error applying fill.');
                });
                return;
            }

            // Set drawing properties explicitly before starting a path
            drawingBufferContext.lineCap = 'round';
            drawingBufferContext.lineJoin = 'round';
            drawingBufferContext.strokeStyle = brushColor;
            drawingBufferContext.lineWidth = brushSize;

            const { x, y } = getTransformedCoords(clientX, clientY);
            drawingBufferContext.beginPath();
            drawingBufferContext.moveTo(x, y);
            isDrawing = true;
        }

        function draw(e) {
            e.preventDefault();

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            if (isStylusOnlyModeEnabled && e.touches && e.touches.length > 0) {
                const touchType = e.touches[0].touchType || 'direct';
                if (touchType === 'direct') {
                    isDrawing = false;
                    return;
                }
            }

            if (tool === 'pan' && isPanning) {
                const dx = clientX - lastPanPoint.x;
                const dy = clientY - lastPanPoint.y;
                panOffset.x += dx;
                panOffset.y += dy;
                lastPanPoint = { x: clientX, y: clientY };
                renderCanvasContent();
                return;
            }

            if (!isDrawing) return;

            const { x, y } = getTransformedCoords(clientX, clientY);
            drawingBufferContext.globalCompositeOperation = tool === 'eraser' ? 'destination-out' : 'source-over';
            drawingBufferContext.lineTo(x, y);
            drawingBufferContext.stroke();
            renderCanvasContent();
        }

        function stopDrawing(e) {
            e.preventDefault();

            if (tool !== 'fill' && tool !== 'eyedropper' && tool !== 'pan') {
                if (isDrawing) {
                    drawingBufferContext.closePath();
                    drawingBufferContext.globalCompositeOperation = 'source-over';
                    saveCurrentFrame();
                    saveState();
                }
            }
            isDrawing = false;
            isPanning = false;
            renderCanvasContent();
        }

        function floodFill(startX, startY, fillColor, ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;

            const getPixelColor = (x, y) => {
                if (x < 0 || x >= width || y < 0 || y >= height) return [-1, -1, -1, -1];
                const index = (y * width + x) * 4;
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            };

            const setPixelColor = (x, y, color) => {
                const index = (y * width + x) * 4;
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            };

            const startColor = getPixelColor(Math.floor(startX), Math.floor(startY));

            if (startColor[0] === -1 || (startColor[0] === fillColor[0] &&
                startColor[1] === fillColor[1] &&
                startColor[2] === fillColor[2] &&
                startColor[3] === fillColor[3])) {
                return;
            }

            const pixelStack = [[Math.floor(startX), Math.floor(startY)]];
            const visited = new Set();

            const matchColor = (color1, color2, tolerance = 5) => {
                return Math.abs(color1[0] - color2[0]) < tolerance &&
                       Math.abs(color1[1] - color2[1]) < tolerance &&
                       Math.abs(color1[2] - color2[2]) < tolerance &&
                       Math.abs(color1[3] - color2[3]) < tolerance;
            };

            while (pixelStack.length > 0) {
                const [x, y] = pixelStack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x >= 0 && x < width && y >= 0 && y < height && matchColor(getPixelColor(x, y), startColor)) {
                    setPixelColor(x, y, fillColor);

                    pixelStack.push([x + 1, y]);
                    pixelStack.push([x - 1, y]);
                    pixelStack.push([x, y + 1]);
                    pixelStack.push([x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function updateTimeline() {
            timelineDiv.innerHTML = '';
            frames.forEach((_, index) => {
                const button = document.createElement('button');
                button.textContent = `F${index + 1}`;
                button.classList.add('flex-shrink-0', 'w-16', 'h-16', 'border-2', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-sm', 'font-bold', 'transition-all', 'duration-200');
                if (index === currentFrameIndex) {
                    button.classList.add('border-blue-600', 'bg-blue-100', 'text-blue-800', 'shadow-md', 'scale-105');
                } else {
                    button.classList.add('border-gray-300', 'bg-white', 'text-gray-600', 'hover:border-blue-400');
                }
                button.onclick = () => {
                    if (isPlaying) pauseAnimation();
                    currentFrameIndex = index;
                    loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
                    updateTimeline();
                };
                timelineDiv.appendChild(button);
            });
        }

        function addFrame() {
            saveCurrentFrame();

            drawingBufferContext.clearRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            const blankCanvasData = drawingBufferCanvas.toDataURL('image/png');

            frames.splice(currentFrameIndex + 1, 0, blankCanvasData);
            currentFrameIndex++;
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
            updateTimeline();
            saveState();
            showMessage('New frame added!');
        }

        function deleteFrame() {
            if (frames.length <= 1) {
                showMessage('Cannot delete the last frame!');
                return;
            }
            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) {
                currentFrameIndex = frames.length - 1;
            }
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
            updateTimeline();
            saveState();
            showMessage('Frame deleted!');
        }

        function duplicateFrame() {
            const currentFrameData = frames[currentFrameIndex];
            frames.splice(currentFrameIndex + 1, 0, currentFrameData);
            currentFrameIndex++;
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
            updateTimeline();
            saveState();
            showMessage('Frame duplicated!');
        }

        function clearCurrentFrame() {
            drawingBufferContext.clearRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);
            saveCurrentFrame();
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
            saveState();
            showMessage('Current frame cleared!');
        }

        function saveProject() {
            saveCurrentFrame();
            localStorage.setItem('animationProject', JSON.stringify(frames));
            localStorage.setItem('currentFrameIndex', currentFrameIndex.toString());
            // Also save current project dimensions
            localStorage.setItem('projectWidth', PROJECT_WIDTH.toString());
            localStorage.setItem('projectHeight', PROJECT_HEIGHT.toString());
            showMessage('Animation project saved!');
        }

        function loadProject() {
            const savedProject = localStorage.getItem('animationProject');
            const savedIndex = localStorage.getItem('currentFrameIndex');
            const savedWidth = localStorage.getItem('projectWidth');
            const savedHeight = localStorage.getItem('projectHeight');

            if (!savedProject) {
                showMessage('No saved animation project found!');
                return;
            }

            try {
                const loadedFrames = JSON.parse(savedProject);
                if (loadedFrames && Array.isArray(loadedFrames) && loadedFrames.length > 0) {
                    frames = loadedFrames;
                    currentFrameIndex = Math.min(parseInt(savedIndex, 10) || 0, frames.length - 1);
                    
                    // Update project dimensions if saved
                    const newWidth = parseInt(savedWidth, 10) || 800;
                    const newHeight = parseInt(savedHeight, 10) || 600;
                    
                    if (newWidth !== PROJECT_WIDTH || newHeight !== PROJECT_HEIGHT) {
                        PROJECT_WIDTH = newWidth;
                        PROJECT_HEIGHT = newHeight;
                        projectWidthInput.value = PROJECT_WIDTH;
                        projectHeightInput.value = PROJECT_HEIGHT;
                        // No need to call resizeDrawingBufferAndFrames here, as loadFrameIntoBuffer will handle it
                        // based on the updated PROJECT_WIDTH and PROJECT_HEIGHT
                    }
                    
                    history = [];
                    historyPointer = -1;
                    saveState();
                    loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent); // Load and render after setting dimensions
                    updateTimeline();
                    showMessage('Animation project loaded!');
                } else {
                    showMessage('Saved project data is corrupt or empty.');
                }
            } catch (error) {
                console.error("Error parsing loaded project:", error);
                showMessage('Error loading project data.');
            }
        }

        function playAnimation() {
            if (frames.length === 0) {
                showMessage('No frames to play!');
                return;
            }
            if (isPlaying) return;

            isPlaying = true;
            
            renderCanvasContent(); 

            const interval = 1000 / animationSpeed;
            animationInterval = setInterval(() => {
                currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
                updateTimeline();
            }, interval);
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            showMessage('Playing animation...');
        }

        function pauseAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            isPlaying = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            showMessage('Animation paused.');
        }

        function stopAnimation() {
            pauseAnimation();
            currentFrameIndex = 0;
            loadFrameIntoBuffer(frames[currentFrameIndex]).then(renderCanvasContent);
            updateTimeline();
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            showMessage('Animation stopped.');
        }

        async function exportGif() {
            if (typeof GIF === 'undefined') {
                showMessage('GIF.js library not loaded. Cannot export GIF.');
                console.error('GIF.js is not available. Ensure the script is loaded.');
                return;
            }
            if (frames.length === 0) {
                showMessage('No frames to export!');
                return;
            }

            isExporting = true;
            exportProgress = 0;
            exportGifBtn.textContent = `Exporting GIF... 0%`;
            exportGifBtn.disabled = true;
            showMessage('Generating GIF...');

            const gif = new GIF({
                workers: 2,
                quality: 10,
                delay: 1000 / animationSpeed,
                width: drawingBufferCanvas.width, // Use fixed internal resolution
                height: drawingBufferCanvas.height, // Use fixed internal resolution
                background: '#ffffff',
                transparent: '#ffffff'
            });

            for (let i = 0; i < frames.length; i++) {
                try {
                    const img = await loadImage(frames[i]);
                    gif.addFrame(img, { delay: 1000 / animationSpeed });
                }
                catch (error) {
                    console.error(`Error loading frame ${i} for GIF export:`, error);
                }
            }

            gif.on('progress', function(p) {
                exportProgress = Math.floor(p * 100);
                exportGifBtn.textContent = `Exporting GIF... ${exportProgress}%`;
            });

            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.gif';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showMessage('GIF exported successfully!');
            });

            gif.on('error', function(error) {
                console.error('GIF generation error:', error);
                isExporting = false;
                exportProgress = 0;
                exportGifBtn.textContent = 'üñºÔ∏è Export GIF';
                exportGifBtn.disabled = false;
                showMessage('Error exporting GIF.');
            });

            gif.render();
        }

        async function generateFrameIdea() {
            const prompt = ideaPromptInput.value.trim();
            if (!prompt) {
                showMessage('Please enter a prompt for the idea generator.');
                return;
            }

            getIdeaBtn.disabled = true;
            ideaPromptInput.disabled = true;
            getIdeaBtn.textContent = 'Generating...';
            generatedIdeaOutput.classList.add('hidden');
            ideaText.textContent = '';

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a creative drawing idea for an animation frame based on this prompt: "${prompt}". Keep it concise and focused on visual elements."` }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Replace with your actual Gemini API Key
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    ideaText.textContent = text;
                    generatedIdeaOutput.classList.remove('hidden');
                    showMessage('Idea generated successfully!');
                } else {
                    ideaText.textContent = 'Could not generate an idea. Please try again.';
                    generatedIdeaOutput.classList.remove('hidden');
                    showMessage('Error generating idea.');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                ideaText.textContent = 'Failed to generate an idea due to an error.';
                generatedIdeaOutput.classList.remove('hidden');
                showMessage('Error generating idea.');
            } finally {
                getIdeaBtn.disabled = false;
                ideaPromptInput.disabled = false;
                getIdeaBtn.textContent = 'Get Idea';
            }
        }

        function updateToolButtons() {
            const allTools = [brushToolBtn, eraserToolBtn, fillToolBtn, eyedropperToolBtn, panToolBtn];
            allTools.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md');
                btn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
            });

            const currentToolBtn = document.getElementById(`${tool}Tool`);
            if (currentToolBtn) {
                currentToolBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-blue-100');
                currentToolBtn.classList.add('bg-blue-600', 'text-white', 'shadow-md');
            }
        }

        /**
         * Resizes the internal drawing buffer and ensures existing frames are redrawn
         * without scaling their content, maintaining original line thickness.
         * @param {number} newWidth The new width for the project.
         * @param {number} newHeight The new height for the project.
         */
        async function resizeDrawingBufferAndFrames(newWidth, newHeight) {
            const oldFrames = [...frames]; // Copy current frames
            const newFrames = [];

            // Store old project dimensions to correctly draw existing content
            const oldProjectWidth = PROJECT_WIDTH;
            const oldProjectHeight = PROJECT_HEIGHT;

            // Update global project dimensions
            PROJECT_WIDTH = newWidth;
            PROJECT_HEIGHT = newHeight;

            // Temporarily set drawing buffer to new dimensions
            drawingBufferCanvas.width = newWidth;
            drawingBufferCanvas.height = newHeight;
            // Ensure smoothing is enabled after resize
            drawingBufferContext.imageSmoothingEnabled = true;

            // Iterate through old frames, draw them onto the new buffer without scaling the content
            for (let i = 0; i < oldFrames.length; i++) {
                const frameData = oldFrames[i];
                // Create a temporary canvas for processing each frame
                const tempFrameCanvas = document.createElement('canvas');
                const tempFrameContext = tempFrameCanvas.getContext('2d');
                tempFrameCanvas.width = newWidth;
                tempFrameCanvas.height = newHeight;
                tempFrameContext.imageSmoothingEnabled = true; // Ensure smoothing for temp context

                // Fill with white background for the new frame
                tempFrameContext.fillStyle = '#ffffff';
                tempFrameContext.fillRect(0, 0, newWidth, newHeight);

                if (frameData && frameData.startsWith('data:image/png;base64,')) {
                    try {
                        const img = await loadImage(frameData);
                        // Calculate centering offsets for the OLD image onto the NEW canvas
                        // This will keep the original drawing at its original pixel size
                        const offsetX = (newWidth - oldProjectWidth) / 2;
                        const offsetY = (newHeight - oldProjectHeight) / 2;

                        // Draw the original image onto the new canvas at its original dimensions
                        // It will be centered, and if the new canvas is smaller, it will be clipped.
                        tempFrameContext.drawImage(img, offsetX, offsetY, oldProjectWidth, oldProjectHeight);
                    } catch (error) {
                        console.error("Error scaling frame during resize:", error);
                        // If image fails, the frame remains white (already filled)
                    }
                }
                newFrames.push(tempFrameCanvas.toDataURL('image/png'));
            }
            
            frames = newFrames; // Update global frames array

            // Ensure current frame is loaded into buffer and canvas is rendered
            await loadFrameIntoBuffer(frames[currentFrameIndex]);
            renderCanvasContent();
            updateTimeline();
            saveState(); // Save this new state to history
            showMessage(`Canvas resized to ${newWidth}x${newHeight}!`);
        }

        window.onload = async function() {
            // Initialize PROJECT_WIDTH and PROJECT_HEIGHT from localStorage or default
            PROJECT_WIDTH = parseInt(localStorage.getItem('projectWidth')) || 800;
            PROJECT_HEIGHT = parseInt(localStorage.getItem('projectHeight')) || 600;
            projectWidthInput.value = PROJECT_WIDTH;
            projectHeightInput.value = PROJECT_HEIGHT;

            // Set drawing buffer dimensions to fixed project size
            drawingBufferCanvas.width = PROJECT_WIDTH;
            drawingBufferCanvas.height = PROJECT_HEIGHT;

            // Explicitly enable image smoothing for both contexts
            context.imageSmoothingEnabled = true;
            drawingBufferContext.imageSmoothingEnabled = true;

            // Initialize drawing buffer context properties
            drawingBufferContext.lineCap = 'round';
            drawingBufferContext.lineJoin = 'round';
            drawingBufferContext.strokeStyle = brushColor;
            drawingBufferContext.lineWidth = brushSize;
            
            // Ensure the drawing buffer is initialized with a white background
            drawingBufferContext.fillStyle = '#ffffff';
            drawingBufferContext.fillRect(0, 0, drawingBufferCanvas.width, drawingBufferCanvas.height);

            // Set visible canvas dimensions based on its container
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;


            if (frames.length === 0) {
                const initialCanvasData = drawingBufferCanvas.toDataURL('image/png');
                frames.push(initialCanvasData);
                saveState();
            }
            
            await loadFrameIntoBuffer(frames[currentFrameIndex]);
            renderCanvasContent();
            
            updateTimeline();
            updateToolButtons();
            updateUndoRedoButtons();

            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            exportGifBtn.disabled = false;

            brushToolBtn.addEventListener('click', () => {
                tool = 'brush';
                updateToolButtons();
            });
            eraserToolBtn.addEventListener('click', () => {
                tool = 'eraser';
                updateToolButtons();
            });
            fillToolBtn.addEventListener('click', () => {
                tool = 'fill';
                updateToolButtons();
            });
            eyedropperToolBtn.addEventListener('click', () => {
                tool = 'eyedropper';
                updateToolButtons();
            });
            panToolBtn.addEventListener('click', () => {
                tool = 'pan';
                updateToolButtons();
            });

            stylusOnlyModeToggle.addEventListener('change', (e) => {
                isStylusOnlyModeEnabled = e.target.checked;
            });

            brushColorInput.addEventListener('input', (e) => {
                brushColor = e.target.value;
                drawingBufferContext.strokeStyle = brushColor;
            });

            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeValueSpan.textContent = `${brushSize}px`;
                drawingBufferContext.lineWidth = brushSize;
            });

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);

            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);

            addFrameBtn.addEventListener('click', addFrame);
            deleteFrameBtn.addEventListener('click', deleteFrame);
            duplicateFrameBtn.addEventListener('click', duplicateFrame);
            clearCurrentFrameBtn.addEventListener('click', clearCurrentFrame);

            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            exportGifBtn.addEventListener('click', exportGif);

            playBtn.addEventListener('click', playAnimation);
            pauseBtn.addEventListener('click', pauseAnimation);
            stopBtn.addEventListener('click', stopAnimation);
            animationSpeedInput.addEventListener('input', (e) => {
                animationSpeed = parseInt(e.target.value);
                animationSpeedValueSpan.textContent = animationSpeed;
                if (isPlaying) {
                    pauseAnimation();
                    playAnimation();
                }
            });

            generateIdeaBtn.addEventListener('click', () => {
                ideaModal.classList.remove('hidden');
                generatedIdeaOutput.classList.add('hidden');
                ideaText.textContent = '';
                ideaPromptInput.value = '';
            });
            closeIdeaModalBtn.addEventListener('click', () => {
                ideaModal.classList.add('hidden');
            });
            getIdeaBtn.addEventListener('click', generateFrameIdea);

            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
            });
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('hidden');
            });

            // New FAQ button event listener
            faqBtn.addEventListener('click', () => {
                window.open('https://sathvik-harish.github.io/ToonStart-Help/', '_blank');
            });

            palmRejectionHelpIcon.addEventListener('click', () => {
                palmRejectionHelpModal.classList.remove('hidden');
            });
            closePalmRejectionHelpModalBtn.addEventListener('click', () => {
                palmRejectionHelpModal.classList.add('hidden');
            });

            updatesBtn.addEventListener('click', () => {
                updatesModal.classList.remove('hidden');
            });
            closeUpdatesModalBtn.addEventListener('click', () => {
                updatesModal.classList.add('hidden');
            });

            customizeBtn.addEventListener('click', () => {
                customizeModal.classList.remove('hidden');
            });
            closeCustomizeModalBtn.addEventListener('click', () => {
                customizeModal.classList.add('hidden');
            });

            applyCanvasSizeBtn.addEventListener('click', () => {
                const newWidth = parseInt(projectWidthInput.value, 10);
                const newHeight = parseInt(projectHeightInput.value, 10);
                if (isNaN(newWidth) || newWidth < 100 || newWidth > 2000 || isNaN(newHeight) || newHeight < 100 || newHeight > 1500) {
                    showMessage('Please enter valid dimensions (Width: 100-2000, Height: 100-1500).');
                    return;
                }
                resizeDrawingBufferAndFrames(newWidth, newHeight);
                showMessage(`Canvas size set to ${newWidth}x${newHeight}.`);
            });

            resetCanvasSizeBtn.addEventListener('click', () => {
                projectWidthInput.value = 800;
                projectHeightInput.value = 600;
                resizeDrawingBufferAndFrames(800, 600);
                showMessage('Canvas size reset to default (800x600).');
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            window.addEventListener('resize', () => {
                const currentFrameData = drawingBufferCanvas.toDataURL('image/png');
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                // Ensure smoothing is enabled after resize on display canvas
                context.imageSmoothingEnabled = true;

                loadFrameIntoBuffer(currentFrameData).then(() => {
                    // These properties are set in startDrawing now, but good to have fallback
                    drawingBufferContext.lineCap = 'round';
                    drawingBufferContext.lineJoin = 'round';
                    drawingBufferContext.strokeStyle = brushColor;
                    drawingBufferContext.lineWidth = brushSize;
                    
                    renderCanvasContent();
                });
            });
        };
    </script>
</body>
</html>
